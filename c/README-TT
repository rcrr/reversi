
To do list:

 (5) Modificare la tabella regab_prng_gp con un campo GAME_VALUE_CHECK che ci consente di fare un secondo run e validare il risultato ( potrebbe essere una data ? ).
     Credo sia piu' semplice duplicare i dati da testare in una nuova tabella:
       psql> CREATE TABLE regab_prng_gp_dupe AS (SELECT seq, cst_time, status, game_value, best_move, leaf_count, node_count, solver FROM regab_prng_gp WHERE batch_id = X AND empty_count = Y AND status = 'ZZZ');
     poi con la stessa WHERE clouse vanno resettati i valori:
       status = 'INS'
       game_value = 0
       best_move = 'UN'::game_move
       leaf_count = 0
       node_count = 0
       solver = NULL::bpchar
     nella tabella regab_prng_gp.
     Va quindi rilanciato il comando rgab -a solve .... sullo stesso set di dati.
     Nel caso in cui si volesse ripristinare lo status se qusto invece di CMP fosse stato CMS, va fatto.
     Poi si puo' quindi confrontare con una JOIN che il campo game_value abbia sempre lo stesso valore.
     
 (8) Aggiungere i Model Weight per EC = 0,1


DONE or ADDRESSED:

 (1) GVE ID (iterative deepening) deve essere revisionato nella sostanza.
     In questo momento e' inutile perche' le info nella TT accumulate nelle iterazioni [0..N-1] non sono usate per il sorting nella iterazione N.
     In pratica nella itrazione N per OGNI livello (e quello 1 e' il piu' importante) il sorting delle mosse deve usare la TT.
     Il sorting nella iterazione N di un livello M che quindi e' compreso nell'intervallo [1..N-1] deve usare i dati nella TT che sono:
       - Esatti. Valore trovato nella finestra di ricerca con profondita' (N-1) - M
       - Incompleti. Abbiamo solo un valore di boundary.
       - Assenti. Un cut-off non ha permesso di esplorare il nodo.
     C'e' da pensarci sopra ....
     In realta' quello che serve e' l'ordinamento delle mosse figlio .... quindi serve di disegnare con precisione l'oggetto NODO delle search
       e di disegnare bene i campi registrati nella TT.
       Poi serve di avere un approccio "tipo memoizzazione", -mi servono le mosse legali ?-, chiamo la funzione lms, se sono gia' calcolate non le ricalcolo, altrimenti le calcolo .... ad esempio
       la funzione is_terminal calcola le mosse lgali, che poi vanno perse e vengono ricalcolate da generate_child_nodes.

 (2) Migliorare le due funzioni:
     - rglm_eval_gp
     - board_pattern_packed_to_index
     Sono il cuore della parte NON ottimizzata sia del solver RGLM che di quello GVE
 
 (2.1) vettorizzare board_pattern_packed_to_index ...
 
 (2.2) Una seconda idea è quella di capire quante volte di seguito è chiamata la funzione ...
       sicuramente per un edge è chiamata 4 volte, e poi diventa più triky perchè le configurazioni dei pattern sono distinte.
       E fare una TABLE anche parziale per entrare sull'indice ?
       Si potrebbe poi proprio eliminare l'index ed andare sul valore del PARAMETRO direttamente.
	 
 (2.3) La funzione board_pattern_compute_rotated si può migliorare rimuovendo i calcoli eseguiti più volte.
       Ad esempio board_trans_flip_diag_h1a8 e board_trans_flip_horizontal sono chiamate più volte.
       Va seguito un preciso ordine che evita i ricalcoli.
	 
 (2.4) Appena un indice è calcolato, prefetch parameter values.
       Prefetch va studiato bene , ha molta potenzialità. Mentre faccio i conti di rotazioni e PACKED2INDEX ... si fa la prefetch ...
       Dopo molti tentativi, la cosa e' archiviata, nessun miglioramento ottenuto.
 
 (3) Passare da negascout a MTDf.
 
 (4) Una miriade di sistemazioni "pratiche" del codice. ( si ma andrebbero listate )
     [done] File di configurazione da riga di comando
     [done] Interferenze tra id_min_empty_count, id_step, search_depth ... e presenza dei files di model_weight
     [done] Documentazione funzione game_position_value_estimator nel file game_value_estimator.h
     [done] Inserire diversi verbose_tematici ....
     [done] Inserire il "planner" della search ... on i LIVELLI di ID, dove passiamo ad AB, dove ci fermiamo ...
     [done] Inserire il check della presenza corretta dei Model-Weight che servono.
     [tested:no gain] La funzione order_moves deve avere anche la sort "fastest-first", quando manca la valutazione euristica ...
     [done] Aggiungere una funzione di inizializzazione di node_t
 
 (6) Rimuovere il "clutter" in GVE dato da negamax e da OLD TT.

 (7) Calcolo HASH ottimizzato, con funzione delta hash.
 
 (9) Rimuovere limitazione che bisogna avere il MODEL-WEIGHT anche per gli EC elevati, serve un fallback su algoritmo BASICO in quel caso.



Appunti al 26-12-2021

Qualche lavoretto generico, ed infine una gan bella sorpresa.
Quando l'algoritmo passa dalla fase MTDF a quella LEAF_NEGAMAX le mosse non sono piu' ordinate.
Ordinando per legal_move_count ci sono evidenti vantaggi in termini di prestazioni.

La baseline per la posizione woc18-FKvsAP-g1-22 oggi e' la seguente:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 21.586s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.629s
  GVE(MTDF) : [ node_count =  33.225.425, leaf_count =  4.675.180 ]  4.251s

Con i CFLAGS da codice produttivo invece:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 21.348s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 13.545s
  GVE(MTDF) : [ node_count =  33.225.425, leaf_count =  4.675.180 ]  3.925s

Avendo accelerato la parte di ricerca terminale, c'e' un ulteriore guadagno alzando il parametro id_min_empty_count dove
il massimo delle prestazioni si ottiene con il valore settato a 12.

  GVE(MTDF) : [ node_count =  41.893.757, leaf_count =  6.227.936 ]  3.176s



Appunti al 18-12-2021

Sto lavorando sul tema config-file.


Appunti al 28-11-2021

Per una analisi precisa sul perche' le chiamate alla funzione rglm_eval_gp sono cosi' tante ...

Rimuoviamo i flag: -DNDEBUG -flto
Aggiungiaamo: -fno-inline

La baseline per la posizione woc18-FKvsAP-g1-22 e' la seguente:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 25.002s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.693s
  GVE(MTDF) : [ node_count =  21.131.468, leaf_count =  2.163.094 ] 19.304s

Nel caso GVE rglm_eval_gp e' chiamato per due strade diverse:

  (1) alphabeta_with_memory->heuristic_game_value->rglm_eval_gp
  (2) alphabeta_with_memory->order_moves->heuristic_game_value->rglm_eval_gp

La #2 copre il 99.99% dei casi.

Concentriamoci quindi su order_moves, che viene chiamato 432.074 volte.

Nel caso della poszione ffo-29 i numeri sono 10x e coincidono esattamente con quelli di callgrind.

  GVE  : rglm_eval_gp_call_count = 1.005.287 [node_count = 1.206.578, leaf_count = 118.718 ]
  RGLM : rglm_eval_gp_call_count =   151.774 [node_count = 4.756.528, leaf_count = 755.464 ]

Calls to alphabeta_with memory :
  650.333 - alphabeta_with memory
       16 - mtdf

Calls to order_moves:
  432.074 - alphabeta_with memory

order_moves_a =   161.432
order_moves_b =   270.658
                  -------
                  432.090

order_moves_c = 1.005.193

Bisogna studiare order_moves ... non sono convinto di come funziona.
ORA HO CAPITO !
E' nel config file, l'uso del modello per fare la EVAL della posizione viene effettuato solo fino a EC=10.

Invece GVE ha un min_empty_count = 4.
Facendo un po' di prove risulta che il valore ottimale sia tra 9-10 ... e il guadagno e' ENORME !

Solver GVE(MTDF), posizione woc18-FKvsAP-g1-22 (ultima colonna rglm_eval_gp_call_count):

   4 : [node_count =  21.131.468, leaf_count =  2.163.094 ] 19.052s  21.170.391
   5 : [node_count =  21.765.780, leaf_count =  2.424.051 ] 16.078s  18.391.697
   6 : [node_count =  24.759.521, leaf_count =  3.073.491 ] 13.395s  14.485.729
   7 : [node_count =  35.006.180, leaf_count =  5.474.127 ] 10.610s  11.458.989
   8 : [node_count =  48.171.539, leaf_count =  8.064.984 ]  8.081s   7.743.848
   9 : [node_count =  64.738.048, leaf_count = 11.332.997 ]  7.312s   6.175.355
  10 : [node_count = 114.350.911, leaf_count = 21.023.310 ]  6.705s   2.923.389
  11 : [node_count = 181.741.225, leaf_count = 34.354.733 ]  8.404s   2.037.288
  12 : [node_count = 329.757.893, leaf_count = 63.435.427 ] 13.066s     931.295

Tempi con assetto PROD:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 21.335s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 13.379s ( 5.681.198 )
  GVE(MTDF) : [ node_count = 114.350.911, leaf_count = 21.023.310 ]  5.394s ( 2.923.389 )

E con CFLAGS da sviluppo: 

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 25.036s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.944s ( 5.681.198 )
  GVE(MTDF) : [ node_count = 114.350.911, leaf_count = 21.023.310 ]  6.681s ( 2.923.389 )




Appunti al 21-11-2021

Proviamo a eseguire l'algoritmo di ID (Iterative Deepening) con passo diverso da 1. Ecco i risultati: 

  GVE(MTDF) ID-increment=1 : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 21.039s
  GVE(MTDF) ID-increment=2 : [ node_count =  26.092.048, leaf_count =  2.278.180 ] 20.367s
  GVE(MTDF) ID-increment=3 : [ node_count =  21.131.468, leaf_count =  2.163.094 ] 15.764s
  GVE(MTDF) ID-increment=4 : [ node_count =  22.639.887, leaf_count =  2.150.485 ] 17.606s
  GVE(MTDF) ID-increment=5 : [ node_count =  20.504.601, leaf_count =  2.083.586 ] 15.745s
  GVE(MTDF) ID-increment=6 : [ node_count =  29.466.467, leaf_count =  3.645.594 ] 21.194s
  GVE(MTDF) ID-increment=7 : [ node_count =  26.542.457, leaf_count =  3.053.506 ] 19.719s

Appare evidente the passo 3 e passo 5 diano risultati ben superiori a passo 1.

Teniamo buono il passo 3, in altri agme la cosa non e' univoca, comunqu passo 3 e sempre meglio di passo 1.

Comunque, nonostante il miglioramento, RGLM rimane piu' veloce del 30-50% (la posizione usata per le varie statistiche ha un 30% di gap,
altre posizioni hanno fino ad un 50%).
Noto che nonostante il contenuto numro di nodi navigati (1/5 - 1/10) da GVE rispetto a RGLM, il numero di call alla funzione rglm_eval_gp e'
quattro volte piu' alto.

  GVE(MTDF) : rglm_eval_gp_call_count = 21 170 391
  RGLM      : rglm_eval_gp_call_count =  5 681 198

Questo e' un tema da investigare a fondo.



Appunti al 14-11-2021

Ogni tentativo di usare efficacemente la PREFETCH non ha dato risultati.
Dopo aver calcolato l'indice del peso, la lookup al valore del peso per il calcolo del game value stalla la CPU, che va in cache-miss.
Una soluzione a qusto inconveniente non la ho trovata.



Appunti al 6-11-2021

Aggiungendo il flag --simulate-cache=yes alla esecuzione di valgrind:

  $ valgrind --tool=callgrind --dump-instr=yes --collect-jumps=yes --simulate-cache=yes ./build/bin/endgame_solver -s gve -f db/gpdb-ffo.txt -q ffo-29

Si puo osservare come e dove ci siano i cache misses.
Prima modifica fatta sul codice della hashtable, le LLd writes sono state dimezzate, ma i tempi generali sono i medesimi.

Compiliamo il software rimuovendo il flag -fno-inline e aggiungendo -DNDEBUG e -flto. I tempi diventano:


  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 24.978s --> 21.436s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.890s --> 13.244s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 24.722s --> 20.846s




Appunti al 1-11-2021

Lo studio sulle trasformazioni non e' ancora partito, intanto ho rimosso le duplicazioni di trasformazioni presenti nella funzione

  board_pattern_compute_rotated

Eseguendo : "time ./build/bin/endgame_solver -s gve -f db/gpdb-sample-games.txt -q woc18-FKvsAP-g1-22" si ottiene:

            OLD            NEW
         ------         ------
         25.443		25.126			
         25.330		25.382			
         25.436		25.160			
         25.744		24.978			
         25.315		24.969			
					
AVERAGE: 25.454		25.123		0.3300  1.30%
BEST:    25.315		24.969		0.3460	1.37%

Con un miglioramento di 1.3%

Sviluppando tutte le funzioni di trasformazione della board in board_trans vettorizzate a 128 bits, in pratica operando contemporaneamente su
mover e opponent, si guadagna un altro 1.75% globalmente, arrivando ad un 3% complessivo.

Siamo a questo punto:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 24.978s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.890s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 24.722s



Appunti al 31-10-2021

Cominciamo a studiare come migliorare le trasformazioni della board ... ecco del materiale interessante ...

  https://programming.sirrida.de/calcperm.php
  https://github.com/kfrlib/fft/blob/master/include/kfr/base/digitreverse.hpp

  constexpr inline u32 bit_permute_step_simple(u32 x, u32 m, u32 shift) {
    return ((x & m) << shift) | ((x >> shift) & m);
  }

Partiamo con lo studio ...


Appunti al 30-10-2021

Queste due opzioni di codice sono performanti allo stesso modo:

  if (false) {
    n->hash = game_position_x_hash(&n->gpx);
  } else {
    game_position_x_deltas(&n->parent->gpx, &n->gpx, n->parent_flips, &n->parent_flip_count);
    const uint64_t delta_hash = game_position_x_delta_hash(n->parent->hash, n->parent_flips, n->parent_flip_count, n->gpx.player);
    n->hash = delta_hash;
  }

La seconda pero' ha un potenziale di ottimizzazione ben rilevante.
Rimuovere completamente il calcolo game_position_x_deltas e game_position_x_delta_hash inglobando
il delta hash nella funzione make move.

Creo la funzione game_position_x_make_move_delta_hash ... non un grande miglioramento ...
Tengo comunque la nuova formulazione che risulta un po' piu' semplice.


  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 25.096s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 15.227s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 25.349s


Appunti al 24-10-2021

Inserendo il calcolo dell'hash della posizione come delta si passa da 29.1 a 25.4, con un risparmio di 3.7 secondi ( 13% ) !!!

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 25.359s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.971s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 25.425s

La modifica non e' completa, una review piu' spinta potrebbe essere interessante.


Appunti al 23-10-2021

Rimossi gli assert nel modulo board inserendo una linea "#define NDEBUG" prima di "#include <assert.h>".

Le prestazioni nella risoluzione del game woc18-FKvsAP-g1-22 diventano:


  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 25.359s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 14.971s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 29.135s



Appunti al 17-10-2021

Vettorizzata la funzione board_pattern_packed_to_index aggiungendo una versione basata su Intel Intrinsics board_pattern_packed_to_index_vec
Le prestazioni della funzione sono 3x rispetto a quella originale.
Sono quindi migliorate sia le prestazioni del solver gve che quello rglm:


  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 33.943s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 19.112s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 33.106s

Eseguito un secondo change sulla funzione alphabeta_with_memory,

  } else if (depth == 0) {
    if (n->value == out_of_range_win_score) heuristic_game_value(n);

Aggiunto test per calcolare heuristic_game_value solo se necessario, 2,2s di miglioramento:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 33.943s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 19.112s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 30.900s



Appunti al 10-10-2021

Riscritta la funzione board_pattern_packed_to_index, non la vettorizza, ma facendo sempre 10 iterazioni completamente unrolle e' lo stesso piu' veloce.

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 33.943s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 20.866s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 39.183s

Inserendo invece il check che le iterazioni non siano piu' di n_squares si isparmia mezzo secondo:

  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 38.795s

ma non ci siamo, non e' una miglioria rilevante.
Il codice comunque NON viene parallelizzato ... sarebbe da capire perche' ???


Appunti al 09-10-2021

Si parte con le ottimizzazioni al codice.
Creato il file optimization_mtdf.ods con il dataabase dei run VALGRIND, e' salvato in c/out e per il momento non e' salvato su git.
Scelta la posizione ffo-29 come test, e' un buon compomesso tra velocita' e capacita' rappresentativa.
Il primo run, ID=1337873 ci da spunti nuovi e conferma le considerazioni gia' proposte precedentemente:

  - 99.99% del tempo e' speso dentro la funzione game_position_value_estimator, che e' ovvio, ma e' giusto che sia verificato.
  - il 14.41% de tempo va nella creazione della transposition table ttab_new ... e 11.16% va in __memset_avx2_unaligned_erms , serve davvero ?
  - la funzione mtdf non ha overhed, tutto il lavoro e' svolto da alphabeta_with_memory ... qui la prima cosa da fare in assoluto e' analizzare rglm_eval_gp
    come del resto era gia' stato evidenziato.
  - nella funzione rglm_eval_gp fatto 100 il suo costo, board_pattern_packed_to_index costa 60, board_patetrn_compute_rotaded 5, e rglmdf_model_weights_table_lookup_record 7
    in totale rglm_eval_gp costa il 69.61% del tempo di esecuzione

Rivista la TO DO list. Partiamo con il lavoro sul codice ...

Rimosse le due inizializzazioni della TTAB a zero ( hashtable e binary-hap ) , le prestazioni sul game woc18-FKvsAP-g1-22 diventano:

  ES        : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 34.066s
  RGLM      : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 20.702s
  GVE(MTDF) : [ node_count =  32.017.443, leaf_count =  2.104.442 ] 41.469s

Ora ( vedi ID=1355514 ) rglm_eval_gp costa 82.51% tel tempo di esecuzione totale.


Appunti al 03-10-2021

Sviluppate 3 differenti funzioni ( che sembrano funzionare tutte e tre ):

  - negascout
  - alphabeta_with_memory
  - mtdf

Tutte e 3 poi vanno sia "standard" che in modalita' iterative deepening.

Le tre funzioni non sono radicalmente diverse nel numero dei nodi navigati, mtdf e' meglio di negascout che a sua volta e' meglio di alphabeta_with_memory.
In qualche test sono molto simili, in altri test c'e' un gap di 5-8 punti percentuali.

Iterative deepening, oltre che essere fondamentale in una eventuale modalita' torneo con un vincolo di tempo, ' anche migliorativa nei tempi. Non sempre, non sostanzialmente, ma migliorativa comunque.



Appunti al 26-9-2021

Pulito un po' il codice in game_value_estimator.c: rimosse le funzioni order_moves e order_moves2. order_moves3 rinominata order_moves.



Appunti al 29-8-2021

Sviluppata nuova funzione di ordinamento order_moves2. Funziona, consegue more pruning, e' piu' veloce.
Sorta le mosse usando le info salvate nella TT.
8 mosse salvate ... c'e' uno schiacciamento delle mosse diverse dalla prima a causa dei cut-off.
Si potrebbe verificare se sia possibile usare un qualche ordinamento ulteriore per le mosse con lo stesso valore.
Comunque ottimo.

Qualche dato sul game woc18-FKvsAP-g1-22 (db/gpdb-sample-games.txt) WOC18 Final Game 1 - Fukuchi Keisuke vs Aunchulee Piyanat - 22 EC
  Legal move count: 12 - [Index:Move:Value]: [00:F1:+00] [01:G1:-02] [02:A3:-02] [03:G7:-02] [04:D1:-04] [05:H6:-04] [06:H2:-06] [07:H3:-06] [08:H7:-12] [09:B2:-18] [10:A2:-20] [11:G2:-28] 

  ES   : [ node_count = 378.034.158, leaf_count = 60.770.918 ] 34.066s
  RGLM : [ node_count = 149.986.155, leaf_count = 21.535.119 ] 20.702s
  GVE  : [ node_count =  33.595.347, leaf_count =  2.115.245 ] 45.399s

NOTA: la hashtable della TT e' piccola, ha troppe poche entry.
Fissato!! Aggiunti alcuni Primes nel codice di hashtable.c .... guadagnato 1 secondo.
La TT va tunata, ma va comunque molto bene, non e' il collo di bottiglia.


Appunti al 22-8-2021

Sviluppato una forma embrionale del sorting delle mosse sulla base dei risultati di navigazione del tree.
child_nodes_tt_ordered puo' essere sostituito da child_nodes_p ... e va calcolato per tutti i liveli.
Cosa succede quando c'e' un CUTOFF e non tutti i nodi sono quindi esplorati ? Bisogna essere sicuri che ci siano dei valori congrui nel campo VALUE,
  oppure si deve eseguire il sorting direttamente nel loop ( forse meglio ).
Poi vanno salvati nella TT, va aggiunto il campo moves e values ( quante ? 2,4,8 o tutte ? )
Infine vanno rilette ed usate per ordinare le mosse in order_moves2 ...
Se tutto va bene sarebbe quindi il caso di porsi la domanda di come riorganizzare la lettura dei dati dalla TT, che dovrebbero essere omogenei con il NODO.


Appunti al 20-8-2021

Ora il sorting delle mosse usa la TT, la prima mossa e' la BEST MOVE della TT.
Risolvendo con GVE la posizione FFO-36 passiamo da [node_count=54.108.716, leaf_count=4.878.005] a [node_count=14.394.404, leaf_count=1.228.874]

  GVE  : [ node_count =   588.325, leaf_count =  47.663 ] 1.321s

Next step e' di avere almeno le prime 4 mosse nella TT, ma serve ? Bisogna provare ... .


Appunti al 16-8-2021

Added -DNDEBUG flag in the Makefaile

  ES   : [ node_count = 4.324.349, leaf_count = 713.632 ] 0.277s
  RGLM : [ node_count = 1.249.479, leaf_count = 197.091 ] 0.239s
  GVE  : [ node_count =   908.452, leaf_count =  77.380 ] 2.164s

rimunovendo -no-inline:

  ES   : [ node_count = 4.324.349, leaf_count = 713.632 ] 0.246s
  RGLM : [ node_count = 1.249.479, leaf_count = 197.091 ] 0.150s
  GVE  : [ node_count =   908.452, leaf_count =  77.380 ] 1.884s

aggiungendo -flto:

  ES   : [ node_count = 4.324.349, leaf_count = 713.632 ] 0.240s
  RGLM : [ node_count = 1.249.479, leaf_count = 197.091 ] 0.153s
  GVE  : [ node_count =   908.452, leaf_count =  77.380 ] 1.660s


Appunti al 11-8-2021

Commentato la riga che esegue il check del DIGEST dei file da caricare con i pesi. I nuovi tempi ora sono:

  RGLM : 0.266s
  GVE  : 5.268s

Cambiando la dimensione della TT i tempi migliorano per GVE, la dimensione ottimale ( compromesso tra tempo di allocazione e tempo di esecuzione ) e' 19 o 20.

  GVE  : 2.361s

Eseguiamo di nuovo i programmi sotto valgrind.

  $ valgrind --tool=callgrind --dump-instr=yes --collect-jumps=yes ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s es -q ffo-22
  $ valgrind --tool=callgrind --dump-instr=yes --collect-jumps=yes ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s rglm -q ffo-22
  $ valgrind --tool=callgrind --dump-instr=yes --collect-jumps=yes ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s gve -q ffo-22

E' evidente per il caso GVE che il 92% del tempo e' speso nella funzione rglm_eval_gp.
Solo il 18% del tempo e' invece consumato da questa funzione nella esecuzione RGLM, questo non lo capisco .... e' da verificare come si sviluppa RGLM.
Per velocizzare rglm_eval_gp si potrebbe tentare di avere una funzione con la dimensione del LOOP fissa,
una funzione per ogni dimensione [3:10] e vedere se il compilatore fa qualcosa di piu' furbo ....

Rimuovendo da rglmdf_model_weights_table_lookup_record assertions e checks:

  GVE  : 2.194s

Si potrebbe anche fare qualche esperimento sul PREFETCH dei dati .... da studiare bene ...

GVE fa iterative deepening ID ... ma e' inutile se i dati dalla TT non vengono usati per il move ordering ....
Questo e' il prossimo lavoro da fare.


Appunti vari al 9-8-2021

Cosa c'e' da fare per far decollare il nuovo solver.

game_value_estimator :

Attualmente l'algoritmo impiegato e' negascout, bisogna passare a MTDf.

Depurare nel computo del tempo il caricamento dei files dei parametri e la allocazione della TT.
Il 99% del tempo va nel check dell'HASH del file.
Noto che rglm_eval_gp viene chiamato solo da look_haead_and_... ma viene chiamato solo 19663 volte, come mai ???


Caso di esempio : ffo-22

  ES   : [ node_count = 4.324.349, leaf_count = 713.632 ] 0.375s
  RGLM : [ node_count = 1.249.479, leaf_count = 197.091 ] 1.197s
  GVE  : [ node_count =   908.452, leaf_count =  77.380 ] 7.001s


$ time ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s es -q ffo-22

Entry id: ffo-22
Description:  G8:+2. A6:+0. F8:-4. A7:-4. H2:-4. B2:-6. D8:-8. B7:-14. G7:-26
Game Position:
    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

Solving game position ffo-22, from source db/gpdb-ffo.txt, using solver es (exact solver) ...

    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

[node_count=4324349, leaf_count=713632]
Final outcome: best move=G8, position value=2


real	0m0.375s
user	0m0.371s
sys	0m0.004s

$ time ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s rglm -q ffo-22

Entry id: ffo-22
Description:  G8:+2. A6:+0. F8:-4. A7:-4. H2:-4. B2:-6. D8:-8. B7:-14. G7:-26
Game Position:
    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

Solving game position ffo-22, from source db/gpdb-ffo.txt, using solver rglm (rglm solver) ...

    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

[node_count=1249479, leaf_count=197091]
Final outcome: best move=G8, position value=2


real	0m1.197s
user	0m1.157s
sys	0m0.040s

$ time ./build/bin/endgame_solver -f db/gpdb-ffo.txt -s gve -q ffo-22

Entry id: ffo-22
Description:  G8:+2. A6:+0. F8:-4. A7:-4. H2:-4. B2:-6. D8:-8. B7:-14. G7:-26
Game Position:
    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

Solving game position ffo-22, from source db/gpdb-ffo.txt, using solver gve (game value estimator) ...
Empty count = 17, Search depth = -1, Minimum empty count = 4
Node Level 0: estimated game value =  1.557 [+02] (0.5119)
id_limit = 13
 ### ### ### id = 1
00 - H2 (+00) [-66..+66]: (success)       f  = +00 - cumulated node count 2
01 - B2 (-04) [+00..+66]: (failing low)   f+ = -04 - cumulated node count 3
02 - A6 (-04) [+00..+66]: (failing low)   f+ = -04 - cumulated node count 4
03 - D8 (-06) [+00..+66]: (failing low)   f+ = -06 - cumulated node count 5
04 - F8 (-06) [+00..+66]: (failing low)   f+ = -06 - cumulated node count 6
05 - A7 (-08) [+00..+66]: (failing low)   f+ = -08 - cumulated node count 7
06 - G8 (-08) [+00..+66]: (failing low)   f+ = -08 - cumulated node count 8
07 - B7 (-12) [+00..+66]: (failing low)   f+ = -12 - cumulated node count 9
08 - G7 (-30) [+00..+66]: (failing low)   f+ = -30 - cumulated node count 10
 ### ### ### id = 2
00 - H2 (+00) [-66..+66]: (success)       f  = -06 - cumulated node count 18
01 - B2 (-04) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 20
02 - A6 (-04) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 22
03 - D8 (-06) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 24
04 - F8 (-06) [-06..+66]: (success)       f  = -02 - cumulated node count 37
05 - A7 (-08) [-02..+66]: (success)       f  = +02 - cumulated node count 50
06 - G8 (-08) [+02..+66]: (failing low)   f+ = -06 - cumulated node count 52
07 - B7 (-12) [+02..+66]: (failing low)   f+ = -16 - cumulated node count 54
08 - G7 (-30) [+02..+66]: (failing low)   f+ = -28 - cumulated node count 56
 ### ### ### id = 3
00 - H2 (+00) [-66..+66]: (success)       f  = -08 - cumulated node count 78
01 - B2 (-04) [-08..+66]: (success)       f  = -06 - cumulated node count 110
02 - A6 (-04) [-06..+66]: (success)       f  = -04 - cumulated node count 140
03 - D8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 149
04 - F8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 167
05 - A7 (-08) [-04..+66]: (success)       f  = -02 - cumulated node count 198
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 213
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -14 - cumulated node count 222
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -28 - cumulated node count 228
 ### ### ### id = 4
00 - H2 (+00) [-66..+66]: (success)       f  = -08 - cumulated node count 284
01 - B2 (-04) [-08..+66]: (success)       f  = -04 - cumulated node count 386
02 - A6 (-04) [-04..+66]: (failing low)   f+ = -12 - cumulated node count 402
03 - D8 (-06) [-04..+66]: (failing low)   f+ = -08 - cumulated node count 418
04 - F8 (-06) [-04..+66]: (success)       f  = -02 - cumulated node count 546
05 - A7 (-08) [-02..+66]: (failing low)   f+ = -04 - cumulated node count 581
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -04 - cumulated node count 620
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -12 - cumulated node count 636
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -34 - cumulated node count 646
 ### ### ### id = 5
00 - H2 (+00) [-66..+66]: (success)       f  = -04 - cumulated node count 783
01 - B2 (-04) [-04..+66]: (success)       f  = -02 - cumulated node count 1021
02 - A6 (-04) [-02..+66]: (failing low)   f+ = -08 - cumulated node count 1075
03 - D8 (-06) [-02..+66]: (failing low)   f+ = -08 - cumulated node count 1128
04 - F8 (-06) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 1175
05 - A7 (-08) [-02..+66]: (success)       f  = +00 - cumulated node count 1542
06 - G8 (-08) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 1609
07 - B7 (-12) [+00..+66]: (failing low)   f+ = -12 - cumulated node count 1660
08 - G7 (-30) [+00..+66]: (failing low)   f+ = -26 - cumulated node count 1680
 ### ### ### id = 6
00 - H2 (+00) [-66..+66]: (success)       f  = -12 - cumulated node count 1905
01 - B2 (-04) [-12..+66]: (success)       f  = -04 - cumulated node count 2520
02 - A6 (-04) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 2612
03 - D8 (-06) [-04..+66]: (failing low)   f+ = -08 - cumulated node count 2702
04 - F8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 3131
05 - A7 (-08) [-04..+66]: (success)       f  = -02 - cumulated node count 4074
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -04 - cumulated node count 4346
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -10 - cumulated node count 4432
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -26 - cumulated node count 4460
 ### ### ### id = 7
00 - H2 (+00) [-66..+66]: (success)       f  = -10 - cumulated node count 4970
01 - B2 (-04) [-10..+66]: (success)       f  = -08 - cumulated node count 5888
02 - A6 (-04) [-08..+66]: (failing low)   f+ = -08 - cumulated node count 6224
03 - D8 (-06) [-08..+66]: (failing low)   f+ = -08 - cumulated node count 6498
04 - F8 (-06) [-08..+66]: (success)       f  = -04 - cumulated node count 9013
05 - A7 (-08) [-04..+66]: (success)       f  = -02 - cumulated node count 11059
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 11335
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -10 - cumulated node count 11536
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -26 - cumulated node count 11584
 ### ### ### id = 8
00 - H2 (+00) [-66..+66]: (success)       f  = -12 - cumulated node count 12402
01 - B2 (-04) [-12..+66]: (success)       f  = -06 - cumulated node count 14549
02 - A6 (-04) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 14937
03 - D8 (-06) [-06..+66]: (failing low)   f+ = -08 - cumulated node count 15548
04 - F8 (-06) [-06..+66]: (success)       f  = -04 - cumulated node count 22048
05 - A7 (-08) [-04..+66]: (success)       f  = -02 - cumulated node count 26398
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 28803
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -04 - cumulated node count 29108
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -24 - cumulated node count 29173
 ### ### ### id = 9
00 - H2 (+00) [-66..+66]: (success)       f  = -10 - cumulated node count 31013
01 - B2 (-04) [-10..+66]: (success)       f  = -04 - cumulated node count 34643
02 - A6 (-04) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 35500
03 - D8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 36498
04 - F8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 40314
05 - A7 (-08) [-04..+66]: (success)       f  = -02 - cumulated node count 48521
06 - G8 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 49253
07 - B7 (-12) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 49897
08 - G7 (-30) [-02..+66]: (failing low)   f+ = -16 - cumulated node count 49992
 ### ### ### id = 10
00 - H2 (+00) [-66..+66]: (success)       f  = -08 - cumulated node count 52906
01 - B2 (-04) [-08..+66]: (success)       f  = +00 - cumulated node count 58918
02 - A6 (-04) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 60134
03 - D8 (-06) [+00..+66]: (failing low)   f+ = -02 - cumulated node count 61323
04 - F8 (-06) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 64052
05 - A7 (-08) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 67151
06 - G8 (-08) [+00..+66]: (failing low)   f+ = -04 - cumulated node count 68349
07 - B7 (-12) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 69311
08 - G7 (-30) [+00..+66]: (failing low)   f+ = -16 - cumulated node count 69434
 ### ### ### id = 11
00 - H2 (+00) [-66..+66]: (success)       f  = -06 - cumulated node count 75214
01 - B2 (-04) [-06..+66]: (success)       f  = -02 - cumulated node count 82947
02 - A6 (-04) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 85155
03 - D8 (-06) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 87184
04 - F8 (-06) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 93160
05 - A7 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 99030
06 - G8 (-08) [-02..+66]: (success)       f  = +00 - cumulated node count 114071
07 - B7 (-12) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 115755
08 - G7 (-30) [+00..+66]: (failing low)   f+ = -10 - cumulated node count 115925
 ### ### ### id = 12
00 - H2 (+00) [-66..+66]: (success)       f  = -08 - cumulated node count 124783
01 - B2 (-04) [-08..+66]: (success)       f  = -06 - cumulated node count 137699
02 - A6 (-04) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 141008
03 - D8 (-06) [-06..+66]: (failing low)   f+ = -06 - cumulated node count 145439
04 - F8 (-06) [-06..+66]: (success)       f  = -04 - cumulated node count 195124
05 - A7 (-08) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 207239
06 - G8 (-08) [-04..+66]: (success)       f  = +02 - cumulated node count 228637
07 - B7 (-12) [+02..+66]: (failing low)   f+ = +02 - cumulated node count 230903
08 - G7 (-30) [+02..+66]: (failing low)   f+ = -06 - cumulated node count 231120
 ### ### ### id = 13
00 - H2 (+00) [-66..+66]: (success)       f  = -06 - cumulated node count 243582
01 - B2 (-04) [-06..+66]: (success)       f  = -04 - cumulated node count 262495
02 - A6 (-04) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 267826
03 - D8 (-06) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 273789
04 - F8 (-06) [-04..+66]: (success)       f  = -02 - cumulated node count 364710
05 - A7 (-08) [-02..+66]: (failing low)   f+ = -02 - cumulated node count 378105
06 - G8 (-08) [-02..+66]: (success)       f  = +02 - cumulated node count 408835
07 - B7 (-12) [+02..+66]: (failing low)   f+ = +02 - cumulated node count 412441
08 - G7 (-30) [+02..+66]: (failing low)   f+ = -06 - cumulated node count 412729
 ### ### ### LAST ### search_depth = 34
00 - H2 (+00) [-66..+66]: (success)       f  = -04 - cumulated node count 489569
01 - B2 (-04) [-04..+66]: (failing low)   f+ = -04 - cumulated node count 521205
02 - A6 (-04) [-04..+66]: (success)       f  = +00 - cumulated node count 594974
03 - D8 (-06) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 608747
04 - F8 (-06) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 661696
05 - A7 (-08) [+00..+66]: (failing low)   f+ = +00 - cumulated node count 714384
06 - G8 (-08) [+00..+66]: (success)       f  = +02 - cumulated node count 896357
07 - B7 (-12) [+02..+66]: (failing low)   f+ = +02 - cumulated node count 907736
08 - G7 (-30) [+02..+66]: (failing low)   f+ = +02 - cumulated node count 908452
Negascout evaluation CPU time: [     2.333329044][     2.333273485]
game_position_value_estimator: search_depth = 34, estimated_value = 2
Transposition Table pointer: 0x55c37765f1b0
  max_n_item:            268435456  -  Number of items that could be stored in the table
  items:            0x7fb08a1cb010  -  Array of items
  next_item:        0x7fb189d18d60  -  Next item to be used when inserting
  n_item:                   307754  -  The number of item currently held in the table
  ht:               0x7fb0891cb010  -  Hashtable containing <Key:item , Item:item>
  pq:               0x7fb0891cb010  -  Priority queue
  ht.size:                 2097143  -  Hashtable size
  ht.length:                307754  -  Hashtable length
TT hashtable stats:
     0;   1810964
     1;    265674
     2;     19472
     3;       997
     4;        35
     5;         1
     6;         0
     7;         0
     8;         0
     9;         0
    10;         0
    11;         0
    12;         0
    13;         0
    14;         0
    15;         0
    16;         0
    17;         0
    18;         0
    19;         0
    20;         0
    21;         0
    22;         0
    23;         0
    24;         0
    25;         0
    26;         0
    27;         0
    28;         0
    29;         0
    30;         0
    31;         0
    32;         0
    33;         0
    34;         0
    35;         0
    36;         0
    37;         0
    38;         0
    39;         0
    40;         0
    41;         0

    a b c d e f g h 
 1  . . O O O O . . 
 2  @ . O O O O O . 
 3  @ @ O O @ O @ @ 
 4  @ O @ O @ @ @ @ 
 5  @ @ @ O @ @ @ @ 
 6  . @ @ O @ O @ @ 
 7  . . O @ @ @ . @ 
 8  . . . . @ . . . 
Player to move: WHITE

[node_count=908452, leaf_count=77380]
Final outcome: best move=G8, position value=2


real	0m7.001s
user	0m4.721s
sys	0m2.280s

