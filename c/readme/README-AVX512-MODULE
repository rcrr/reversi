
  README-AVX512-MODULE

  Copyright (c) 2024 Roberto Corradini. All rights reserved.

  This file is part of the reversi program
  http://github.com/rcrr/reversi

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 3, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  or visit the site <http://www.gnu.org/licenses/>.

This file describes the configuration and settings done to prepare the AVX512 REVERSI module.

In order to run AVX512 code it is needed that the CPU reports avx512 flags.
The AMD Ryzen 9 7940HS reports among many others:
flags : avx512f avx512dq avx512ifma avx512cd avx512bw avx512vl avx512_bf16 avx512vbmi avx512_vbmi2 avx512_vnni avx512_bitalg avx512_vpopcntdq

Adding to Makefile:

AVX512_FLAGS := -mavx512f -mavx512cd -mavx512vl -mavx512bw -mavx512dq -mavx512ifma -mavx512vbmi
ARCH_FLAGS := ... $(AVX512_FLAGS)

generates many compiler warnings. The offending flags are:
-mavx512bw -mavx512vbmi

Removing them is safe in order to run the Kogge-Stone LMS (Legal Moves Set) and MM (Make Move) functions.

The KOST macro defined in board.c establish the option to be selected between the assembly or the C code.

Writing a new LMS or MM function leveraging AVX-512 requires effort and time.

  Note: The ASM instruction "vpbroadcastq %rdi, %zmm0" should broadcast the 64 bit of register RDI into the 8 partitions of
        the ZMM0 register.
        For a reason not clear to me, just the first 4 are populated.
        The same instruction generated by the GCC Compiler does the right job.

But it is not really required. The GCC compiler does a great job in optimising the C code. Changing the compile
flags the code moves from AVX2 to AVX-512.

I am testing on two different hardware:

  0 - alpha: AMD Ryzen Threadripper PRO 5965WX - 3.8 GHz
  1 - beta:  AMD Ryzen 9 7940HS                - 5.1 GHz

Beta is capable to run AVX512 code, alpha is not.

What are the results running the following command:

  $ time ./build/bin/endgame_solver -s es -f db/gpdb-ffo.txt -q ffo-46

  # | System | Time      | Seconds | CPU Speed | Inst. Set | LMS Impl. | Harmonised Speed
____|________|___________|_________|___________|___________|___________|__________________
  0 | alpha  | 2m25.807s | 145.807 | 3.8GHz    | AVX2      | C         | 1.000 (  reference )
  1 | beta   | 1m49.928s | 109.928 | 5.1GHz    | AVX512    | C         | 0.984 (  2% slower )
  2 | beta   | 1m43.723s | 103.723 | 5.1GHz    | AVX2      | C         | 1.043 (  4% faster )
  3 | beta   | 1m34.879s |  94.879 | 5.1GHz    | AVX2      | ASM       | 1.141 ( 14% faster )

So, beta is much faster, and there is no benefit to compile AVX512 code. AVX2 is good enough. It is even slightly better.
But is AMD ZEN 4 (Genoa) IPC (Instruction Per Clock) better than ZEN 3 (Milan) ?

Harmonising the time taken with the CPU speed (GHz) the results are quite interesting. AMD Zen 4 is just 4% faster.

The ASM kogge_stone implementation is faster than the C implementation by around 10%.

here we compare just the kogge-stone function, calling it one billion times.

FUNCTION | IMPLEMENTATION |    FLAGS | MACHINE |  GHz |    CALL_COUNT | ELAPSED_TIME |  CALL_X_SEC | K_CALL_X_SEC | M_CALL_X_SEC | M_CALL_X_SEC_X_GHZ
_________|________________|__________|_________|______|_______________|______________|_____________|______________|______________|____________________
     LMS |           KOST | ASM_AVX2 |    beta | 5.12 | 1,000,000,000 |         3.20 | 312,500,000 |      312,500 |          313 |                 61
     LMS |    KOGGE_STONE |     AVX2 |    beta | 5.12 | 1,000,000,000 |         3.59 | 278,551,532 |      278,552 |          279 |                 54
     LMS |    KOGGE_STONE |   AVX512 |    beta | 5.12 | 1,000,000,000 |         4.65 | 215,053,763 |      215,054 |          215 |                 42
     LMS |    KOGGE_STONE |     AVX2 |   alpha | 3.79 | 1,000,000,000 |         4.53 | 220,750,552 |      220,751 |          221 |                 58
     LMS |           KOST | ASM_AVX2 |   alpha | 3.79 | 1,000,000,000 |         4.52 | 221,238,938 |      221,239 |          221 |                 58

Again, beta is much faster becouse of the clock speed, but harmonizing by it, it is just 5% faster.
The ASM implementation is faster, around 10%.
The AVX512 C compiled version is much slower, 20% compared to the same code compiled with AVX2 flags.