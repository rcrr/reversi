
  README-GLM

  Copyright (c) 2018, 2019, 2020, 2021, 2023 Roberto Corradini. All rights reserved.

  This file is part of the reversi program
  http://github.com/rcrr/reversi

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 3, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  or visit the site <http://www.gnu.org/licenses/>.



This file describes how to use the REGAB (REversi GAme Base) program, database, and procedures in section 1.
The procedure to compose and solve the GLM (Generalized Linear Model) problem in section two, and how to add
new Patterns and Features (or GLM covariates) to the program in section three ( see also the README-ADD-NEW-PATTERN ).

###
### Section --1--
###
### This section describes the procedures to generate new data sets for the RGLM (Reversi Generalized Linear Model) optimizer.
###

First step is to insert the BATCH of game positions into the REGAB database.
The seq field is assigned by the database (this is going to change most likely because the batch_id is the name used by the
REGAB program to name the batches), the png_seed is unique, and it is the "real name" of the batch.

$ time ./build/bin/regab -v -a generate -c cfg/regab.cfg -e test -s 77357 -n 2000000

tst_regab=> SELECT * FROM regab_prng_gp_h ORDER BY ngames;
 seq |          ins_time          | status | prng_seed | ngames  | npositions 
-----+----------------------------+--------+-----------+---------+------------
   1 | 2017-12-17 18:19:16.440571 | CMP    |     97531 |       1 |         61
   7 | 2018-01-03 16:38:51.097299 | CMP    |       277 |      10 |        614
   8 | 2018-01-03 16:39:24.466546 | CMP    |       607 |     100 |       6140
   4 | 2018-01-03 16:25:52.05024  | CMP    |         0 |    1000 |      61356
   5 | 2018-01-03 16:27:08.188697 | CMP    |      5577 |   10000 |     614283
   6 | 2018-01-03 16:30:24.238143 | CMP    |       881 |  100000 |    6142003
  10 | 2021-07-24 17:58:18.845845 | CMP    |     25487 |  200000 |   12281722
  11 | 2021-07-25 20:51:04.829293 | CMP    |     40132 |  400000 |   24566078
   3 | 2017-12-17 18:42:13.782953 | CMP    |     13579 | 1000000 |   61412190
   9 | 2020-12-20 18:02:16.47252  | CMP    |     77357 | 2000000 |  122829157
  12 | 2021-08-21 17:55:04.407724 | CMP    |     33057 | 4000000 |  245656852
(11 rows)

After the batch is loaded, we can start solving the game positions.
Here we are solving 10 positions, having 10 empty_positions, from the batch_id 9.

$ ./build/bin/regab -v -a solve -c cfg/regab.cfg -e test -b 9 -n 10 -y 10

tst_regab=> SELECT * FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 10 AND status = 'CMP';
    seq    | batch_id | game_id | pos_id |          ins_time          | status |          cst_time          |        mover         |       opponent       | player | empty_count |    legal_move_set    | legal_move_count | legal_move_count_adjusted | parent_move | game_value | best_move | leaf_count | node_count | parent_gp_id 
-----------+----------+---------+--------+----------------------------+--------+----------------------------+----------------------+----------------------+--------+-------------+----------------------+------------------+---------------------------+-------------+------------+-----------+------------+------------+--------------
 121251820 |        9 |       0 |     50 | 2020-12-20 12:45:08.461138 | CMP    | 2020-12-20 19:11:02.072029 | -8126914241586325758 |  4631980193233266808 |      0 |          10 |  3494934048353058948 |                9 |                         9 | G1          |         46 | A4        |       1336 |       7441 |             
 121251882 |        9 |       1 |     50 | 2020-12-20 12:45:08.472645 | CMP    | 2020-12-20 19:11:02.074865 |  -364534762366528462 |   291632734808394500 |      0 |          10 |      844433520205897 |                8 |                         8 | A5          |         26 | A1        |        561 |       3386 |             
 121251944 |        9 |       2 |     50 | 2020-12-20 12:45:08.476641 | CMP    | 2020-12-20 19:11:02.076976 |  4765656358079874688 | -8872957360183625612 |      0 |          10 |  2882321903458976008 |                6 |                         6 | H8          |         -4 | D1        |        799 |       4154 |             
 121252007 |        9 |       3 |     50 | 2020-12-20 12:45:08.480801 | CMP    | 2020-12-20 19:11:02.078886 |    14359685600542289 |   -86421132224233332 |      0 |          10 |         549755846658 |                3 |                         3 | H6          |        -28 | H5        |        886 |       4467 |             
 121252068 |        9 |       4 |     50 | 2020-12-20 12:45:08.484482 | CMP    | 2020-12-20 19:11:02.080525 | -9151878496980305672 |  1008807416446060032 |      0 |          10 |           4294967559 |                5 |                         5 | C2          |         34 | A5        |         70 |        446 |             
 121252129 |        9 |       5 |     50 | 2020-12-20 12:45:08.488424 | CMP    | 2020-12-20 19:11:02.082709 | -1210572089017039104 |    55398784596244512 |      0 |          10 |     2251799813947608 |                6 |                         6 | D2          |         48 | H1        |        757 |       4084 |             
 121252190 |        9 |       6 |     50 | 2020-12-20 12:45:08.491951 | CMP    | 2020-12-20 19:11:02.084698 |      311811455810365 |   -36587313543773182 |      0 |          10 |    36029211483340800 |                5 |                         5 | G7          |          0 | H2        |        816 |       4037 |             
 121252252 |        9 |       7 |     50 | 2020-12-20 12:45:08.495761 | CMP    | 2020-12-20 19:11:02.086777 |  2536409961289187089 |   343571631670067206 |      0 |          10 | -8644659484737666936 |                5 |                         5 | C8          |         18 | D1        |       1029 |       5636 |             
 121252313 |        9 |       8 |     50 | 2020-12-20 12:45:08.49937  | CMP    | 2020-12-20 19:11:02.08884  |      292283404878342 |  2251437161518366136 |      0 |          10 |  2359956573504143425 |                8 |                         8 | B7          |         30 | A1        |       1225 |       6371 |             
 121252374 |        9 |       9 |     50 | 2020-12-20 12:45:08.502952 | CMP    | 2020-12-20 19:11:02.090841 |   157418227048670208 |  4328131815292771103 |      0 |          10 |  4611721204946960416 |                4 |                         4 | E1          |        -36 | F1        |       1092 |       5864 |             
(10 rows)

When game positions are solved we need to generate offsprings. It means that from STATUS = 'CMP' we derive the 'CMS' and 'CMR' statuses.

Here a brief explanation of the different status that a game position can take:
  - INS: Inserted.
  - WIP: Selected for game_value calculation.
  - CMP: game_value has been coputed and saved.
  - CMQ: Marked for offspring generation.
  - CMW: Selected and locked for offspring generation.
  - CMR: It is the offspring generated by a parent game position by playing the best move.
  - CMS: Offspring has been generated.

The first step is to move our game position from status CMP to status CMQ running the following database procedure:

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count < 20 GROUP BY empty_count, status ORDER BY empty_count, status;
=> UPDATE regab_prng_gp SET status = 'CMQ', cst_time = now() WHERE status = 'CMP' AND batch_id = 9


Then run the REGAB program with the action "offspring" to generate from the CMQ the CMR record, and update status from CMQ to CMS.

$ ./build/bin/regab -v -a offspring -c cfg/regab.cfg -e test -b 9 -y 10 -n 20
=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count < 20 GROUP BY empty_count, status ORDER BY empty_count, status;

It is relevant to notice that, tacking off the case of a pass-move, a CMQ record having an empty_count field equal to Y, generates a CMR record having empty_count
equal to Y-1, and a CMS record having empty_count equal to Y.
When we select the game positions, extracted with the REGAB program, for an RGLM model we select records with a given empty_count Y having status IN('CMS', CMR'), so the solved game positions belong
to Y and Y+1 empty_count.

Let's make a real example:

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMP    | 1980705
(1 row)

=> UPDATE regab_prng_gp SET status = 'CMQ', cst_time = now() WHERE status = 'CMP' AND batch_id = 9 AND empty_count = 0;
UPDATE 1980705

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMQ    | 1980705
(1 row)

$ ./build/bin/regab -a offspring -c cfg/regab.cfg -e production -b 9 -y 0 -n 2000000 > ./build/out/regab.o.00.txt &

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMR    | 1980705
           0 | CMS    | 1980705
(2 rows)

######################## REMENBER TO CLASSIFY !!!
######################## SELECT * FROM regab_gp_populate_pattern_class_table(1, 20, 30, '{CMR,CMS}', FALSE, FALSE);
########################
#
# This query checks what is missing to be classified.
#
# SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id
#   WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') GROUP BY t1.batch_id, t1.empty_count;
#


###
### Section --2--
###
### This section describes the procedure to compose and solve the GLM (Generalized Linear Model) problem.
###

First step is to extract the data from the REGAB database. Data is structured as a set of solved positions.
Extraction happens by selecting:

 - a set of batch_id values
 - a set of game position statuses
 - one single empty_count value
 - an ordered set of board patterns

And by specifying an output file:

 $ regab --action extract --config-file regab.cfg --env test --batch-id 1,3,5 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4 --out-file solved_positions.dat



#
# Some examples to extract and then to run the GLM ....
#


#
# Batches
#

tst_regab=> SELECT * FROM regab_prng_gp_h ORDER BY seq;
 seq |          ins_time          | status | prng_seed | ngames  | npositions 
-----+----------------------------+--------+-----------+---------+------------
   1 | 2017-12-17 18:19:16.440571 | CMP    |     97531 |       1 |         61
   3 | 2017-12-17 18:42:13.782953 | CMP    |     13579 | 1000000 |   61412190
   4 | 2018-01-03 16:25:52.05024  | CMP    |         0 |    1000 |      61356
   5 | 2018-01-03 16:27:08.188697 | CMP    |      5577 |   10000 |     614283
   6 | 2018-01-03 16:30:24.238143 | CMP    |       881 |  100000 |    6142003
   7 | 2018-01-03 16:38:51.097299 | CMP    |       277 |      10 |        614
   8 | 2018-01-03 16:39:24.466546 | CMP    |       607 |     100 |       6140


#
# Prepares the imput files for the GLM computations.
#

# batch:id 5 : 10,000 games .... 20,000 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 5 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_05_p_EDGE_00.dat

# batch:id 6 : 100,000 games .... 199,932 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_06_p_EDGE_00.dat

# batch:id 3 : 1,000,000 games .... 1,999,179 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_03_p_EDGE_00.dat

# Solves the GLM problem and writes results in tmp/bid_05_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_05_p_EDGE_00.dat -o tmp/bid_05_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_06_p_EDGE_00.dat -o tmp/bid_06_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_EDGE_00.dat -o tmp/bid_03_p_EDGE_01.dat

# Dumps the evaluation function weights in tmp/bid_05_p_EDGE_01_weights.dat
./build/bin/rglm -v -i tmp/bid_05_p_EDGE_01.dat -b tmp/bid_05_p_EDGE_01_weights.dat -W tmp/bid_05_p_EDGE_01_weights.csv
./build/bin/rglm -v -i tmp/bid_06_p_EDGE_01.dat -b tmp/bid_06_p_EDGE_01_weights.dat -W tmp/bid_06_p_EDGE_01_weights.csv
./build/bin/rglm -v -i tmp/bid_03_p_EDGE_01.dat -b tmp/bid_03_p_EDGE_01_weights.dat -W tmp/bid_03_p_EDGE_01_weights.csv

# batch:id 4 : 1,000 games .... 1,998 positions
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 4 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_04_game_positions.dat

# Computes the fitting of the evaluation function with the given weights on the set of solved game positions.
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_05_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_05_p_EDGE_01_weights.csv
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_06_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_06_p_EDGE_01_weights.csv
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_03_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_03_p_EDGE_01_weights.csv


#
# RDS : Ranks and diagonals
#

./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4,DIAG8,DIAG7,DIAG6,DIAG5,DIAG4,DIAG3 --out-file tmp/bid_03_p_RDS_00.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_RDS_00.dat -o tmp/bid_03_p_RDS_01.dat
./build/bin/rglm -v -i tmp/bid_03_p_RDS_01.dat -b tmp/bid_03_p_RDS_01_weights.dat -W tmp/bid_03_p_RDS_01_weights.csv
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_06_game_positions.dat
./build/bin/rglm_fit_utility -v -p tmp/bid_06_game_positions.dat -w tmp/bid_03_p_RDS_01_weights.dat -R tmp/eval_bid_06_by_bid_03_p_RDS_01_weights.csv


#
# CORNER : Corners, ranks, and diagonals
#

./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4,DIAG8,DIAG7,DIAG6,DIAG5,DIAG4,CORNER --out-file tmp/bid_03_p_CORNER_00.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_CORNER_00.dat -o tmp/bid_03_p_CORNER_01.dat
./build/bin/rglm -v -i tmp/bid_03_p_CORNER_01.dat -b tmp/bid_03_p_CORNER_01_weights.dat -W tmp/bid_03_p_CORNER_01_weights.csv
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_06_game_positions.dat
./build/bin/rglm_fit_utility -v -p tmp/bid_06_game_positions.dat -w tmp/bid_03_p_CORNER_01_weights.dat -R tmp/eval_bid_06_by_bid_03_p_CORNER_01_weights.csv

###
### Section --3--
###
### How to create a new Pattern or a new GLM covariate
###

# 2020-06-02 how to create a new PATTERN ? For instance the MEAN pattern ?

# First: let's see where an existing pattern is declared. The DIAG3 and diag3 strings come out from the source and sql files in:

./src/board_pattern.h
./src/board_pattern.c
./src/endgame_solver.c

./sql/0103_up_patterns.sql
./sql/0104_up_pattern_functions.sql
./sql/0107_down_pattern_data.sql
./sql/0107_up_pattern_data.sql
./sql/0109_up_action_extract.sql


rcrr@acheron:~/base/prj/reversi/c$ find ./src | grep "\.[ch]$" | sort | xargs grep "DIAG3"
./src/board_pattern.h: *               - DIAG3
./src/board_pattern.h: * The `DIAG3` pattern has four instances ranging from `[0..3]`:
./src/board_pattern.h:  BOARD_PATTERN_DIAG3,               /**< A3 B2 C1 */
./src/board_pattern.h:    { BOARD_PATTERN_DIAG3,
./src/board_pattern.h:      "DIAG3",
./src/endgame_solver.c:  "  -P, --pattern          Pattern                  - Used with the rand solver - Must be in [EDGE|CORNER|XEDGE|R2|R3|R4|DIAG4|DIAG5|DIAG6|DIAG7|DIAG8|2X5COR|DIAG3].\n"

rcrr@acheron:~/base/prj/reversi/c$ find ./src | grep "\.[ch]$" | sort | xargs grep "diag3"
./src/board_pattern.c:board_pattern_pack_diag3 (SquareSet s)
./src/board_pattern.c:  const SquareSet diag3 = 0x0000000000010204;
./src/board_pattern.c:  s &= diag3;
./src/board_pattern.c:board_pattern_unpack_diag3 (SquareSet s)
./src/board_pattern.c:  const SquareSet diag3 = 0x0000000000010204;
./src/board_pattern.c:  return s & diag3;
./src/board_pattern.h:board_pattern_pack_diag3 (SquareSet s);
./src/board_pattern.h:board_pattern_unpack_diag3 (SquareSet s);
./src/board_pattern.h:      board_pattern_pack_diag3,
./src/board_pattern.h:      board_pattern_unpack_diag3,

rcrr@acheron:~/base/prj/reversi/c$ find ./sql | grep "\.sql$" | sort | xargs grep "DIAG3"
./sql/0104_up_pattern_functions.sql:-- Packs DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:-- Un-packs DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:-- Computes the mirror value for the given index, for the DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:    --- DIAG3
./sql/0107_down_pattern_data.sql:DELETE FROM regab_prng_pattern_ranges WHERE pattern_id = (SELECT pattern_id FROM regab_prng_patterns WHERE pattern_name = 'DIAG3');
./sql/0107_down_pattern_data.sql:DELETE FROM regab_prng_patterns WHERE pattern_name = 'DIAG3';
./sql/0107_up_pattern_data.sql:--- Populates the patter table with EDGE, CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR, and DIAG3 patterns.
./sql/0107_up_pattern_data.sql:    (now(), 12, 'DIAG3',   4,  3, 'Three square diagonal, C1-B2-A3')
./sql/0107_up_pattern_data.sql:  pn := 'DIAG3';
./sql/0107_up_pattern_data.sql:-- DIAG3
./sql/0107_up_pattern_data.sql:SELECT 'Loading frequencies for the DIAG3 pattern ...' AS message;
./sql/0107_up_pattern_data.sql:\COPY regab_staging_ec_pidx_cnt_tmp  FROM '0107_data_pattern_index_frequencies_DIAG3_628_1000000000.sql' WITH (FORMAT CSV, DELIMITER ';', HEADER true);
./sql/0107_up_pattern_data.sql:SELECT regab_update_prob_into_pattern_probs_from_staging('DIAG3');
./sql/0109_up_action_extract.sql:--- Populates the patter table with EDGE, CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR, and DIAG3 patterns.

rcrr@acheron:~/base/prj/reversi/c$ find ./sql | grep "\.sql$" | sort | xargs grep "diag3"
./sql/0103_up_patterns.sql:                                          i_diag3_0  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_1  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_2  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_3  INTEGER,
./sql/0104_down_pattern_functions.sql:DROP FUNCTION regab_mirror_value_diag3_pattern;
./sql/0104_down_pattern_functions.sql:DROP FUNCTION square_set_pattern_unpack_diag3;
./sql/0104_down_pattern_functions.sql:DROP FUNCTION square_set_pattern_pack_diag3;
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION square_set_pattern_pack_diag3 (s square_set)
./sql/0104_up_pattern_functions.sql:  packed_diag3_mask square_set := (x'0000000000000007')::BIGINT;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3(empty_) = empty_, 'Expected result is empty_.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3(full_) = packed_diag3_mask, 'Expected result is packed_diag4_mask.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000000004')::square_set) = (x'0000000000000004')::square_set, 'Expected result is 0000000000000004.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000000200')::square_set) = (x'0000000000000002')::square_set, 'Expected result is 0000000000000002.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000010000')::square_set) = (x'0000000000000001')::square_set, 'Expected result is 0000000000000001.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'fffffffffffefdfb')::square_set) = (x'0000000000000000')::square_set, 'Expected result is 0000000000000000.');
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION square_set_pattern_unpack_diag3 (s square_set)
./sql/0104_up_pattern_functions.sql:  packed_diag3_mask square_set := (x'0000000000000007')::BIGINT;
./sql/0104_up_pattern_functions.sql:  diag3             square_set := (x'0000000000010204')::BIGINT;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3(empty_) = empty_, 'Expected result is empty_.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3(packed_diag3_mask) = diag3, 'Expected result is diag3.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000004')::square_set) = (x'0000000000000004')::square_set, 'Expected result is 0000000000000004.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000002')::square_set) = (x'0000000000000200')::square_set, 'Expected result is 0000000000000200.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000001')::square_set) = (x'0000000000010000')::square_set, 'Expected result is 0000000000010000.');
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION regab_mirror_value_diag3_pattern (index_value INTEGER)
./sql/0104_up_pattern_functions.sql:  mo := square_set_pattern_unpack_diag3(mo);
./sql/0104_up_pattern_functions.sql:  op := square_set_pattern_unpack_diag3(op);
./sql/0104_up_pattern_functions.sql:  mo := square_set_pattern_pack_diag3(mo);
./sql/0104_up_pattern_functions.sql:  op := square_set_pattern_pack_diag3(op);
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern( 0) =  0, 'Expected value is  0.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(13) = 13, 'Expected value is 13.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(26) = 26, 'Expected value is 26.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(19) = 11, 'Expected value is 11.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(15) =  7, 'Expected value is  7.');
./sql/0104_up_pattern_functions.sql:    PERFORM p_assert(regab_mirror_value_diag3_pattern(regab_mirror_value_diag3_pattern(i)) = i, 'Comuputing mirror of mirror of an diag3 pattern index should return itself');
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_0  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_1  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_2  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_3  INTEGER)
./sql/0104_up_pattern_functions.sql:  i_diag3_0  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_identity),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_identity));
./sql/0104_up_pattern_functions.sql:  i_diag3_1  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_90a),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_90a));
./sql/0104_up_pattern_functions.sql:  i_diag3_2  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_180),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_180));
./sql/0104_up_pattern_functions.sql:  i_diag3_3  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_90c),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_90c));
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_0  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_0;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_1  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_1;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_2  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_2;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_3  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_3;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_0 = 13, 'Expected value for i_diag3_0 is 13.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_1 =  6, 'Expected value for i_diag3_1 is  6.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_2 = 14, 'Expected value for i_diag3_2 is 14.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_3 = 17, 'Expected value for i_diag3_3 is 17.');
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_0  <> gp_pattern_class_n_rec.i_diag3_0
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_1  <> gp_pattern_class_n_rec.i_diag3_1
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_2  <> gp_pattern_class_n_rec.i_diag3_2
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_3  <> gp_pattern_class_n_rec.i_diag3_3
./sql/0104_up_pattern_functions.sql:                                               i_diag3_0  = gp_pattern_class_n_rec.i_diag3_0,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_1  = gp_pattern_class_n_rec.i_diag3_1,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_2  = gp_pattern_class_n_rec.i_diag3_2,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_3  = gp_pattern_class_n_rec.i_diag3_3
./sql/0107_up_pattern_data.sql:  UPDATE regab_prng_pattern_ranges SET mirror_value = regab_mirror_value_diag3_pattern(index_value) WHERE pattern_id = pid;
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_0 = 13, 'Expected value for i_diag3_0 is 13.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_1 =  6, 'Expected value for i_diag3_1 is  6.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_2 = 14, 'Expected value for i_diag3_2 is 14.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_3 = 17, 'Expected value for i_diag3_3 is 17.');
./sql/0109_up_action_extract.sql:    (now(), 12, 0, 'i_diag3_0'),
./sql/0109_up_action_extract.sql:    (now(), 12, 1, 'i_diag3_1'),
./sql/0109_up_action_extract.sql:    (now(), 12, 2, 'i_diag3_2'),
./sql/0109_up_action_extract.sql:    (now(), 12, 3, 'i_diag3_3')


###
### Section --4--
###
### How to create a new Feature for the GLM model
###

TO BE COMPLETED