
  README-GLM

  Copyright (c) 2018, 2019, 2020, 2021, 2023, 2024, 2025 Roberto Corradini. All rights reserved.

  This file is part of the reversi program
  http://github.com/rcrr/reversi

  This program is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 3, or (at your option) any
  later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  or visit the site <http://www.gnu.org/licenses/>.



This file describes how to use the REGAB (REversi GAme Base) program, database, and procedures in section one.
The procedure to compose and solve the GLM (Generalized Linear Model) problem in section two, and how to add
new Patterns and Features (or GLM covariates) to the program in section three ( see also the README-ADD-NEW-PATTERN ).

###
### Section --1--
###
### This section describes the procedures to generate new data sets for the RGLM (Reversi Generalized Linear Model) optimizer.
###

First step is to insert the BATCH of game positions into the REGAB database.
The seq field is assigned by the database (this is going to change most likely because the batch_id is the name used by the
REGAB program to name the batches), the png_seed is unique, and it is the "real name" of the batch.

$ time ./build/bin/regab -v -a generate -c cfg/regab.cfg -e test -s 77357 -n 2000000

tst_regab=> SELECT * FROM regab_prng_gp_h ORDER BY ngames;
 seq |          ins_time          | status | prng_seed | ngames  | npositions 
-----+----------------------------+--------+-----------+---------+------------
   1 | 2017-12-17 18:19:16.440571 | CMP    |     97531 |       1 |         61
   7 | 2018-01-03 16:38:51.097299 | CMP    |       277 |      10 |        614
   8 | 2018-01-03 16:39:24.466546 | CMP    |       607 |     100 |       6140
   4 | 2018-01-03 16:25:52.05024  | CMP    |         0 |    1000 |      61356
   5 | 2018-01-03 16:27:08.188697 | CMP    |      5577 |   10000 |     614283
   6 | 2018-01-03 16:30:24.238143 | CMP    |       881 |  100000 |    6142003
  10 | 2021-07-24 17:58:18.845845 | CMP    |     25487 |  200000 |   12281722
  11 | 2021-07-25 20:51:04.829293 | CMP    |     40132 |  400000 |   24566078
   3 | 2017-12-17 18:42:13.782953 | CMP    |     13579 | 1000000 |   61412190
   9 | 2020-12-20 18:02:16.47252  | CMP    |     77357 | 2000000 |  122829157
  12 | 2021-08-21 17:55:04.407724 | CMP    |     33057 | 4000000 |  245656852
(11 rows)

After the batch is loaded, we can start solving the game positions.
Here we are solving 10 positions, having 10 empty_positions, from the batch_id 9.

$ ./build/bin/regab -v -a solve -c cfg/regab.cfg -e test -b 9 -n 10 -y 10

tst_regab=> SELECT * FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 10 AND status = 'CMP';
    seq    | batch_id | game_id | pos_id |          ins_time          | status |          cst_time          |        mover         |       opponent       | player | empty_count |    legal_move_set    | legal_move_count | legal_move_count_adjusted | parent_move | game_value | best_move | leaf_count | node_count | parent_gp_id 
-----------+----------+---------+--------+----------------------------+--------+----------------------------+----------------------+----------------------+--------+-------------+----------------------+------------------+---------------------------+-------------+------------+-----------+------------+------------+--------------
 121251820 |        9 |       0 |     50 | 2020-12-20 12:45:08.461138 | CMP    | 2020-12-20 19:11:02.072029 | -8126914241586325758 |  4631980193233266808 |      0 |          10 |  3494934048353058948 |                9 |                         9 | G1          |         46 | A4        |       1336 |       7441 |             
 121251882 |        9 |       1 |     50 | 2020-12-20 12:45:08.472645 | CMP    | 2020-12-20 19:11:02.074865 |  -364534762366528462 |   291632734808394500 |      0 |          10 |      844433520205897 |                8 |                         8 | A5          |         26 | A1        |        561 |       3386 |             
 121251944 |        9 |       2 |     50 | 2020-12-20 12:45:08.476641 | CMP    | 2020-12-20 19:11:02.076976 |  4765656358079874688 | -8872957360183625612 |      0 |          10 |  2882321903458976008 |                6 |                         6 | H8          |         -4 | D1        |        799 |       4154 |             
 121252007 |        9 |       3 |     50 | 2020-12-20 12:45:08.480801 | CMP    | 2020-12-20 19:11:02.078886 |    14359685600542289 |   -86421132224233332 |      0 |          10 |         549755846658 |                3 |                         3 | H6          |        -28 | H5        |        886 |       4467 |             
 121252068 |        9 |       4 |     50 | 2020-12-20 12:45:08.484482 | CMP    | 2020-12-20 19:11:02.080525 | -9151878496980305672 |  1008807416446060032 |      0 |          10 |           4294967559 |                5 |                         5 | C2          |         34 | A5        |         70 |        446 |             
 121252129 |        9 |       5 |     50 | 2020-12-20 12:45:08.488424 | CMP    | 2020-12-20 19:11:02.082709 | -1210572089017039104 |    55398784596244512 |      0 |          10 |     2251799813947608 |                6 |                         6 | D2          |         48 | H1        |        757 |       4084 |             
 121252190 |        9 |       6 |     50 | 2020-12-20 12:45:08.491951 | CMP    | 2020-12-20 19:11:02.084698 |      311811455810365 |   -36587313543773182 |      0 |          10 |    36029211483340800 |                5 |                         5 | G7          |          0 | H2        |        816 |       4037 |             
 121252252 |        9 |       7 |     50 | 2020-12-20 12:45:08.495761 | CMP    | 2020-12-20 19:11:02.086777 |  2536409961289187089 |   343571631670067206 |      0 |          10 | -8644659484737666936 |                5 |                         5 | C8          |         18 | D1        |       1029 |       5636 |             
 121252313 |        9 |       8 |     50 | 2020-12-20 12:45:08.49937  | CMP    | 2020-12-20 19:11:02.08884  |      292283404878342 |  2251437161518366136 |      0 |          10 |  2359956573504143425 |                8 |                         8 | B7          |         30 | A1        |       1225 |       6371 |             
 121252374 |        9 |       9 |     50 | 2020-12-20 12:45:08.502952 | CMP    | 2020-12-20 19:11:02.090841 |   157418227048670208 |  4328131815292771103 |      0 |          10 |  4611721204946960416 |                4 |                         4 | E1          |        -36 | F1        |       1092 |       5864 |             
(10 rows)

When game positions are solved we need to generate offsprings. It means that from STATUS = 'CMP' we derive the 'CMS' and 'CMR' statuses.

Here a brief explanation of the different status that a game position can take:
  - INS: Inserted.
  - WIP: Selected for game_value calculation.
  - CMP: game_value has been coputed and saved.
  - CMQ: Marked for offspring generation.
  - CMW: Selected and locked for offspring generation.
  - CMR: It is the offspring generated by a parent game position by playing the best move.
  - CMS: Offspring has been generated.

The first step is to move our game position from status CMP to status CMQ running the following database procedure:

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count < 20 GROUP BY empty_count, status ORDER BY empty_count, status;
=> UPDATE regab_prng_gp SET status = 'CMQ', cst_time = now() WHERE status = 'CMP' AND batch_id = 9


Then run the REGAB program with the action "offspring" to generate from the CMQ the CMR record, and update status from CMQ to CMS.

$ ./build/bin/regab -v -a offspring -c cfg/regab.cfg -e test -b 9 -y 10 -n 20
=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count < 20 GROUP BY empty_count, status ORDER BY empty_count, status;

It is relevant to notice that, tacking off the case of a pass-move, a CMQ record having an empty_count field equal to Y, generates a CMR record having empty_count
equal to Y-1, and a CMS record having empty_count equal to Y.
When we select the game positions, extracted with the REGAB program, for an RGLM model we select records with a given empty_count Y having status IN('CMS', CMR'), so the solved game positions belong
to Y and Y+1 empty_count.

Let's make a real example:

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMP    | 1980705
(1 row)

=> UPDATE regab_prng_gp SET status = 'CMQ', cst_time = now() WHERE status = 'CMP' AND batch_id = 9 AND empty_count = 0;
UPDATE 1980705

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMQ    | 1980705
(1 row)

$ ./build/bin/regab -a offspring -c cfg/regab.cfg -e production -b 9 -y 0 -n 2000000 > ./build/out/regab.o.00.txt &

=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE batch_id = 9 AND empty_count = 0 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
           0 | CMR    | 1980705
           0 | CMS    | 1980705
(2 rows)

######################## REMENBER TO CLASSIFY !!!
######################## SELECT * FROM regab_gp_populate_pattern_class_table(1, 20, 30, '{CMR,CMS}', FALSE, FALSE);
########################
#
# This query checks what is missing to be classified.
#
# SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id
#   WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') GROUP BY t1.batch_id, t1.empty_count;
#


###
### Section --2--
###
### This section describes the procedure to compose and solve the GLM (Generalized Linear Model) problem.
###

First step is to extract the data from the REGAB database. Data is structured as a set of solved positions.
Extraction happens by selecting:

 - a set of batch_id values
 - a set of game position statuses
 - one single empty_count value
 - an ordered set of board patterns

And by specifying an output file:

 $ regab --action extract --config-file regab.cfg --env test --batch-id 1,3,5 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4 --out-file solved_positions.dat



#
# Some examples to extract and then to run the GLM ....
#


#
# Batches
#

tst_regab=> SELECT * FROM regab_prng_gp_h ORDER BY seq;
 seq |          ins_time          | status | prng_seed | ngames  | npositions 
-----+----------------------------+--------+-----------+---------+------------
   1 | 2017-12-17 18:19:16.440571 | CMP    |     97531 |       1 |         61
   3 | 2017-12-17 18:42:13.782953 | CMP    |     13579 | 1000000 |   61412190
   4 | 2018-01-03 16:25:52.05024  | CMP    |         0 |    1000 |      61356
   5 | 2018-01-03 16:27:08.188697 | CMP    |      5577 |   10000 |     614283
   6 | 2018-01-03 16:30:24.238143 | CMP    |       881 |  100000 |    6142003
   7 | 2018-01-03 16:38:51.097299 | CMP    |       277 |      10 |        614
   8 | 2018-01-03 16:39:24.466546 | CMP    |       607 |     100 |       6140


#
# Prepares the imput files for the GLM computations.
#

# batch:id 5 : 10,000 games .... 20,000 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 5 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_05_p_EDGE_00.dat

# batch:id 6 : 100,000 games .... 199,932 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_06_p_EDGE_00.dat

# batch:id 3 : 1,000,000 games .... 1,999,179 positions
./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE --out-file tmp/bid_03_p_EDGE_00.dat

# Solves the GLM problem and writes results in tmp/bid_05_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_05_p_EDGE_00.dat -o tmp/bid_05_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_06_p_EDGE_00.dat -o tmp/bid_06_p_EDGE_01.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_EDGE_00.dat -o tmp/bid_03_p_EDGE_01.dat

# Dumps the evaluation function weights in tmp/bid_05_p_EDGE_01_weights.dat
./build/bin/rglm -v -i tmp/bid_05_p_EDGE_01.dat -b tmp/bid_05_p_EDGE_01_weights.dat -W tmp/bid_05_p_EDGE_01_weights.csv
./build/bin/rglm -v -i tmp/bid_06_p_EDGE_01.dat -b tmp/bid_06_p_EDGE_01_weights.dat -W tmp/bid_06_p_EDGE_01_weights.csv
./build/bin/rglm -v -i tmp/bid_03_p_EDGE_01.dat -b tmp/bid_03_p_EDGE_01_weights.dat -W tmp/bid_03_p_EDGE_01_weights.csv

# batch:id 4 : 1,000 games .... 1,998 positions
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 4 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_04_game_positions.dat

# Computes the fitting of the evaluation function with the given weights on the set of solved game positions.
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_05_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_05_p_EDGE_01_weights.csv
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_06_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_06_p_EDGE_01_weights.csv
./build/bin/rglm_fit_utility -v -p tmp/bid_04_game_positions.dat -w tmp/bid_03_p_EDGE_01_weights.dat -R tmp/eval_bid_04_by_bid_03_p_EDGE_01_weights.csv


#
# RDS : Ranks and diagonals
#

./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4,DIAG8,DIAG7,DIAG6,DIAG5,DIAG4,DIAG3 --out-file tmp/bid_03_p_RDS_00.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_RDS_00.dat -o tmp/bid_03_p_RDS_01.dat
./build/bin/rglm -v -i tmp/bid_03_p_RDS_01.dat -b tmp/bid_03_p_RDS_01_weights.dat -W tmp/bid_03_p_RDS_01_weights.csv
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_06_game_positions.dat
./build/bin/rglm_fit_utility -v -p tmp/bid_06_game_positions.dat -w tmp/bid_03_p_RDS_01_weights.dat -R tmp/eval_bid_06_by_bid_03_p_RDS_01_weights.csv


#
# CORNER : Corners, ranks, and diagonals
#

./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env test --batch-id 3 --position-status CMS,CMR --empty-count 20 --pattern EDGE,R2,R3,R4,DIAG8,DIAG7,DIAG6,DIAG5,DIAG4,CORNER --out-file tmp/bid_03_p_CORNER_00.dat
./build/bin/rglm -v -s -i tmp/bid_03_p_CORNER_00.dat -o tmp/bid_03_p_CORNER_01.dat
./build/bin/rglm -v -i tmp/bid_03_p_CORNER_01.dat -b tmp/bid_03_p_CORNER_01_weights.dat -W tmp/bid_03_p_CORNER_01_weights.csv
./build/bin/regab -v --action extract --game-positions --config-file cfg/regab.cfg --env test --batch-id 6 --position-status CMS,CMR --empty-count 20 --out-file tmp/bid_06_game_positions.dat
./build/bin/rglm_fit_utility -v -p tmp/bid_06_game_positions.dat -w tmp/bid_03_p_CORNER_01_weights.dat -R tmp/eval_bid_06_by_bid_03_p_CORNER_01_weights.csv

###
### Section --3--
###
### How to create a new Pattern or a new GLM covariate
###

# 2020-06-02 how to create a new PATTERN ? For instance the MEAN pattern ?

# First: let's see where an existing pattern is declared. The DIAG3 and diag3 strings come out from the source and sql files in:

./src/board_pattern.h
./src/board_pattern.c
./src/endgame_solver.c

./sql/0103_up_patterns.sql
./sql/0104_up_pattern_functions.sql
./sql/0107_down_pattern_data.sql
./sql/0107_up_pattern_data.sql
./sql/0109_up_action_extract.sql


rcrr@acheron:~/base/prj/reversi/c$ find ./src | grep "\.[ch]$" | sort | xargs grep "DIAG3"
./src/board_pattern.h: *               - DIAG3
./src/board_pattern.h: * The `DIAG3` pattern has four instances ranging from `[0..3]`:
./src/board_pattern.h:  BOARD_PATTERN_DIAG3,               /**< A3 B2 C1 */
./src/board_pattern.h:    { BOARD_PATTERN_DIAG3,
./src/board_pattern.h:      "DIAG3",
./src/endgame_solver.c:  "  -P, --pattern          Pattern                  - Used with the rand solver - Must be in [EDGE|CORNER|XEDGE|R2|R3|R4|DIAG4|DIAG5|DIAG6|DIAG7|DIAG8|2X5COR|DIAG3].\n"

rcrr@acheron:~/base/prj/reversi/c$ find ./src | grep "\.[ch]$" | sort | xargs grep "diag3"
./src/board_pattern.c:board_pattern_pack_diag3 (SquareSet s)
./src/board_pattern.c:  const SquareSet diag3 = 0x0000000000010204;
./src/board_pattern.c:  s &= diag3;
./src/board_pattern.c:board_pattern_unpack_diag3 (SquareSet s)
./src/board_pattern.c:  const SquareSet diag3 = 0x0000000000010204;
./src/board_pattern.c:  return s & diag3;
./src/board_pattern.h:board_pattern_pack_diag3 (SquareSet s);
./src/board_pattern.h:board_pattern_unpack_diag3 (SquareSet s);
./src/board_pattern.h:      board_pattern_pack_diag3,
./src/board_pattern.h:      board_pattern_unpack_diag3,

rcrr@acheron:~/base/prj/reversi/c$ find ./sql | grep "\.sql$" | sort | xargs grep "DIAG3"
./sql/0104_up_pattern_functions.sql:-- Packs DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:-- Un-packs DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:-- Computes the mirror value for the given index, for the DIAG3 pattern.
./sql/0104_up_pattern_functions.sql:    --- DIAG3
./sql/0107_down_pattern_data.sql:DELETE FROM regab_prng_pattern_ranges WHERE pattern_id = (SELECT pattern_id FROM regab_prng_patterns WHERE pattern_name = 'DIAG3');
./sql/0107_down_pattern_data.sql:DELETE FROM regab_prng_patterns WHERE pattern_name = 'DIAG3';
./sql/0107_up_pattern_data.sql:--- Populates the patter table with EDGE, CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR, and DIAG3 patterns.
./sql/0107_up_pattern_data.sql:    (now(), 12, 'DIAG3',   4,  3, 'Three square diagonal, C1-B2-A3')
./sql/0107_up_pattern_data.sql:  pn := 'DIAG3';
./sql/0107_up_pattern_data.sql:-- DIAG3
./sql/0107_up_pattern_data.sql:SELECT 'Loading frequencies for the DIAG3 pattern ...' AS message;
./sql/0107_up_pattern_data.sql:\COPY regab_staging_ec_pidx_cnt_tmp  FROM '0107_data_pattern_index_frequencies_DIAG3_628_1000000000.sql' WITH (FORMAT CSV, DELIMITER ';', HEADER true);
./sql/0107_up_pattern_data.sql:SELECT regab_update_prob_into_pattern_probs_from_staging('DIAG3');
./sql/0109_up_action_extract.sql:--- Populates the patter table with EDGE, CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR, and DIAG3 patterns.

rcrr@acheron:~/base/prj/reversi/c$ find ./sql | grep "\.sql$" | sort | xargs grep "diag3"
./sql/0103_up_patterns.sql:                                          i_diag3_0  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_1  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_2  INTEGER,
./sql/0103_up_patterns.sql:                                          i_diag3_3  INTEGER,
./sql/0104_down_pattern_functions.sql:DROP FUNCTION regab_mirror_value_diag3_pattern;
./sql/0104_down_pattern_functions.sql:DROP FUNCTION square_set_pattern_unpack_diag3;
./sql/0104_down_pattern_functions.sql:DROP FUNCTION square_set_pattern_pack_diag3;
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION square_set_pattern_pack_diag3 (s square_set)
./sql/0104_up_pattern_functions.sql:  packed_diag3_mask square_set := (x'0000000000000007')::BIGINT;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3(empty_) = empty_, 'Expected result is empty_.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3(full_) = packed_diag3_mask, 'Expected result is packed_diag4_mask.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000000004')::square_set) = (x'0000000000000004')::square_set, 'Expected result is 0000000000000004.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000000200')::square_set) = (x'0000000000000002')::square_set, 'Expected result is 0000000000000002.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'0000000000010000')::square_set) = (x'0000000000000001')::square_set, 'Expected result is 0000000000000001.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_pack_diag3((x'fffffffffffefdfb')::square_set) = (x'0000000000000000')::square_set, 'Expected result is 0000000000000000.');
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION square_set_pattern_unpack_diag3 (s square_set)
./sql/0104_up_pattern_functions.sql:  packed_diag3_mask square_set := (x'0000000000000007')::BIGINT;
./sql/0104_up_pattern_functions.sql:  diag3             square_set := (x'0000000000010204')::BIGINT;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3(empty_) = empty_, 'Expected result is empty_.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3(packed_diag3_mask) = diag3, 'Expected result is diag3.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000004')::square_set) = (x'0000000000000004')::square_set, 'Expected result is 0000000000000004.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000002')::square_set) = (x'0000000000000200')::square_set, 'Expected result is 0000000000000200.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(square_set_pattern_unpack_diag3((x'0000000000000001')::square_set) = (x'0000000000010000')::square_set, 'Expected result is 0000000000010000.');
./sql/0104_up_pattern_functions.sql:CREATE FUNCTION regab_mirror_value_diag3_pattern (index_value INTEGER)
./sql/0104_up_pattern_functions.sql:  mo := square_set_pattern_unpack_diag3(mo);
./sql/0104_up_pattern_functions.sql:  op := square_set_pattern_unpack_diag3(op);
./sql/0104_up_pattern_functions.sql:  mo := square_set_pattern_pack_diag3(mo);
./sql/0104_up_pattern_functions.sql:  op := square_set_pattern_pack_diag3(op);
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern( 0) =  0, 'Expected value is  0.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(13) = 13, 'Expected value is 13.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(26) = 26, 'Expected value is 26.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(19) = 11, 'Expected value is 11.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(regab_mirror_value_diag3_pattern(15) =  7, 'Expected value is  7.');
./sql/0104_up_pattern_functions.sql:    PERFORM p_assert(regab_mirror_value_diag3_pattern(regab_mirror_value_diag3_pattern(i)) = i, 'Comuputing mirror of mirror of an diag3 pattern index should return itself');
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_0  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_1  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_2  INTEGER,
./sql/0104_up_pattern_functions.sql:                                                  OUT i_diag3_3  INTEGER)
./sql/0104_up_pattern_functions.sql:  i_diag3_0  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_identity),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_identity));
./sql/0104_up_pattern_functions.sql:  i_diag3_1  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_90a),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_90a));
./sql/0104_up_pattern_functions.sql:  i_diag3_2  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_180),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_180));
./sql/0104_up_pattern_functions.sql:  i_diag3_3  := regab_transformed_pattern_to_index(square_set_pattern_pack_diag3(mo_rot_90c),
./sql/0104_up_pattern_functions.sql:                                                   square_set_pattern_pack_diag3(op_rot_90c));
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_0  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_0;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_1  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_1;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_2  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_2;
./sql/0104_up_pattern_functions.sql:    SELECT principal_index_value INTO STRICT i_diag3_3  FROM regab_prng_pattern_ranges WHERE pattern_id = pid AND index_value = i_diag3_3;
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_0 = 13, 'Expected value for i_diag3_0 is 13.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_1 =  6, 'Expected value for i_diag3_1 is  6.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_2 = 14, 'Expected value for i_diag3_2 is 14.');
./sql/0104_up_pattern_functions.sql:  PERFORM p_assert(pattern_index_values.i_diag3_3 = 17, 'Expected value for i_diag3_3 is 17.');
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_0  <> gp_pattern_class_n_rec.i_diag3_0
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_1  <> gp_pattern_class_n_rec.i_diag3_1
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_2  <> gp_pattern_class_n_rec.i_diag3_2
./sql/0104_up_pattern_functions.sql:        OR gp_pattern_class_o_rec.i_diag3_3  <> gp_pattern_class_n_rec.i_diag3_3
./sql/0104_up_pattern_functions.sql:                                               i_diag3_0  = gp_pattern_class_n_rec.i_diag3_0,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_1  = gp_pattern_class_n_rec.i_diag3_1,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_2  = gp_pattern_class_n_rec.i_diag3_2,
./sql/0104_up_pattern_functions.sql:                                               i_diag3_3  = gp_pattern_class_n_rec.i_diag3_3
./sql/0107_up_pattern_data.sql:  UPDATE regab_prng_pattern_ranges SET mirror_value = regab_mirror_value_diag3_pattern(index_value) WHERE pattern_id = pid;
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_0 = 13, 'Expected value for i_diag3_0 is 13.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_1 =  6, 'Expected value for i_diag3_1 is  6.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_2 = 14, 'Expected value for i_diag3_2 is 14.');
./sql/0107_up_pattern_data.sql:  PERFORM p_assert(pattern_index_values.i_diag3_3 = 17, 'Expected value for i_diag3_3 is 17.');
./sql/0109_up_action_extract.sql:    (now(), 12, 0, 'i_diag3_0'),
./sql/0109_up_action_extract.sql:    (now(), 12, 1, 'i_diag3_1'),
./sql/0109_up_action_extract.sql:    (now(), 12, 2, 'i_diag3_2'),
./sql/0109_up_action_extract.sql:    (now(), 12, 3, 'i_diag3_3')


###
### Section --4--
###
### How to create a new Feature for the GLM model
###

See readme file: README-ADDING-NEW-PATTERN

###
### Section --5--
###
### How to PROCESS entries into the REGAB database that are computed but not yet ready to be used.
###

prd_regab=> SELECT * FROM regab_prng_gp_h ORDER BY ngames;
 seq |          ins_time          | status | prng_seed | ngames  | npositions 
-----+----------------------------+--------+-----------+---------+------------
   1 | 2017-12-17 18:19:16.440571 | CMP    |     97531 |       1 |         61
   7 | 2018-01-03 16:38:51.097299 | CMP    |       277 |      10 |        614
   8 | 2018-01-03 16:39:24.466546 | CMP    |       607 |     100 |       6140
   4 | 2018-01-03 16:25:52.05024  | CMP    |         0 |    1000 |      61356
   5 | 2018-01-03 16:27:08.188697 | CMP    |      5577 |   10000 |     614283
   6 | 2018-01-03 16:30:24.238143 | CMP    |       881 |  100000 |    6142003
  10 | 2021-07-24 17:58:18.845845 | CMP    |     25487 |  200000 |   12281722
  11 | 2021-07-25 20:51:04.829293 | CMP    |     40132 |  400000 |   24566078
   3 | 2017-12-17 18:42:13.782953 | CMP    |     13579 | 1000000 |   61412190
   9 | 2020-12-20 18:02:16.47252  | CMP    |     77357 | 2000000 |  122829157
  12 | 2021-08-21 17:55:04.407724 | CMP    |     33057 | 4000000 |  245656852
(11 rows)

prd_regab=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE empty_count > 22 AND empty_count < 28 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
          23 | CMR    | 7707842
          23 | CMS    | 7707838
          24 | CMR    |     542
          24 | CMS    | 7707819
          25 | CMP    | 7223851
          25 | INS    |  483839
          25 | WIP    |      48
          26 | CMP    |   28847
          26 | INS    | 7678929
          27 | INS    | 7707667
(10 rows)

Empty-count 23 is all set. EC 24 is done, but we are missing CMR entries coming from processing EC 25.
EC 25 has a substantial count into CMP status that need to be processed. There are also a residual number of
entries having INS status. Them are currently in the queue to be resolved ... at a speed of 20,000 per day on
average, it will take 24 days.
EC 26 has a few thousands entries resolved, but it is mostly to be worked out. EC 27 is virgin.

prd_regab=> SELECT empty_count, status, batch_id, count(1) FROM regab_prng_gp WHERE empty_count = 25 GROUP BY empty_count, status, batch_id ORDER BY empty_count, status, batch_id;
 empty_count | status | batch_id |  count  
-------------+--------+----------+---------
          25 | CMP    |        1 |       1
          25 | CMP    |        3 |  999538
          25 | CMP    |        4 |     999
          25 | CMP    |        5 |    9998
          25 | CMP    |        6 |   99966
          25 | CMP    |        7 |      10
          25 | CMP    |        8 |     100
          25 | CMP    |        9 | 1999180
          25 | CMP    |       10 |  199899
          25 | CMP    |       11 |  399832
          25 | CMP    |       12 | 3514455
          25 | INS    |       12 |  483712
          25 | WIP    |       12 |      48
(13 rows)

prd_regab=> UPDATE regab_prng_gp SET status = 'CMQ', cst_time = now() WHERE status = 'CMP' AND empty_count = 25 AND batch_id = 1;
UPDATE 1

prd_regab=> SELECT empty_count, status, batch_id, count(1) FROM regab_prng_gp WHERE empty_count = 25 GROUP BY empty_count, status, batch_id ORDER BY empty_count, status, batch_id;
 empty_count | status | batch_id |  count  
-------------+--------+----------+---------
          25 | CMP    |        3 |  999538
          25 | CMP    |        4 |     999
          25 | CMP    |        5 |    9998
          25 | CMP    |        6 |   99966
          25 | CMP    |        7 |      10
          25 | CMP    |        8 |     100
          25 | CMP    |        9 | 1999180
          25 | CMP    |       10 |  199899
          25 | CMP    |       11 |  399832
          25 | CMP    |       12 | 3514519
          25 | CMQ    |        1 |       1
          25 | INS    |       12 |  483648
          25 | WIP    |       12 |      48
(13 rows)

$ ./build/bin/regab -v -a offspring -c cfg/regab.cfg -e production -b 1 -y 25 -n 1

-----------------------------------------------------------
--- Last entries from the regab database connection log ---
-----------------------------------------------------------
seq                           con_time                      
11291                         2024-11-03 08:00:31.33982     
11292                         2024-11-03 08:00:31.352177    
11293                         2024-11-04 14:05:36.885741    
-----------------------------------------------------------

Selecting game position to process: 1 of 1 ... selected record [seq = 36, best_move = A8, game_value = +60]

prd_regab=> SELECT empty_count, status, batch_id, count(1) FROM regab_prng_gp WHERE empty_count = 25 GROUP BY empty_count, status, batch_id ORDER BY empty_count, status, batch_id;
 empty_count | status | batch_id |  count  
-------------+--------+----------+---------
          25 | CMP    |        3 |  999538
          25 | CMP    |        4 |     999
          25 | CMP    |        5 |    9998
          25 | CMP    |        6 |   99966
          25 | CMP    |        7 |      10
          25 | CMP    |        8 |     100
          25 | CMP    |        9 | 1999180
          25 | CMP    |       10 |  199899
          25 | CMP    |       11 |  399832
          25 | CMP    |       12 | 3516921
          25 | CMS    |        1 |       1
          25 | INS    |       12 |  481246
          25 | WIP    |       12 |      48
(13 rows)

prd_regab=> SELECT empty_count, status, count(1) FROM regab_prng_gp WHERE empty_count = 24 GROUP BY empty_count, status ORDER BY empty_count, status;
 empty_count | status |  count  
-------------+--------+---------
          24 | CMR    |     543
          24 | CMS    | 7707819
(2 rows)

Running regab -a offspring on batch_id=1 and empty_count=25 we trasform the one CMP record into one CMS having EC=25 and one CMR having EC=24.
We can check that the count of CMR records at EC=24 increase from 542 to 543.

We repeat this process for batch_id 7, 8, 4, 5, 6, 10, 11, 3, 9, 12 ...
We are almost done, but a few more position have to be resolved ...

prd_regab=> SELECT empty_count, status, batch_id, count(1) FROM regab_prng_gp WHERE empty_count = 25 GROUP BY empty_count, status, batch_id ORDER BY empty_count, status, batch_id;
 empty_count | status | batch_id |  count  
-------------+--------+----------+---------
          25 | CMP    |       12 |    2476
          25 | CMR    |        3 |      58
          25 | CMR    |        6 |       7
          25 | CMR    |        9 |     125
          25 | CMR    |       10 |      16
          25 | CMR    |       11 |      31
          25 | CMR    |       12 |     212
          25 | CMS    |        1 |       1
          25 | CMS    |        3 |  999538
          25 | CMS    |        4 |     999
          25 | CMS    |        5 |    9998
          25 | CMS    |        6 |   99966
          25 | CMS    |        7 |      10
          25 | CMS    |        8 |     100
          25 | CMS    |        9 | 1999180
          25 | CMS    |       10 |  199899
          25 | CMS    |       11 |  399832
          25 | CMS    |       12 | 3730831
          25 | INS    |       12 |  264860
          25 | WIP    |       12 |      48
(20 rows)

We are solving now, 48 position have WIP status, 264,860 are still to be resolved (INS), and 2,476 (CMP) have been just resolved and not yet moved to CMMQ status.
Waiting for completion is going to take sensible time, given the actual average speed of resolving around 20,000 position per day.


###
### Section --6--
###
### How to CLASSIFY positions.
###

In order to classify position we use the SQL function regab_gp_populate_pattern_class_table.
It has as arguments:
   - batch_id
   - minimum empty_count
   - maximum empty_count
   - status
   - verbose flag
   - simulation flag

We start to check if we have to classify positions having empty_count=23.

prd_regab=> SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') AND t1.empty_count = 23 GROUP BY t1.batch_id, t1.empty_count;
 batch_id | empty_count | count 
----------+-------------+-------
(0 rows)

No position to classify.
Let's check empty_count=24.

prd_regab=> SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') AND t1.empty_count = 24 GROUP BY t1.batch_id, t1.empty_count;
 batch_id | empty_count |  count  
----------+-------------+---------
        1 |          24 |       1
        3 |          24 |  999480
        4 |          24 |     999
        5 |          24 |    9998
        6 |          24 |   99959
        7 |          24 |      10
        8 |          24 |     100
        9 |          24 | 1999055
       10 |          24 |  199883
       11 |          24 |  399801
       12 |          24 | 3730619
(11 rows)

Here we have many ...let's start with batch_id=1, and classify the positions:

prd_regab=> SELECT * FROM regab_gp_populate_pattern_class_table(1, 24, 24, '{CMR,CMS}', FALSE, FALSE);
 rec_selected_cnt | rec_create_cnt | rec_update_cnt 
------------------+----------------+----------------
                2 |              1 |              1
(1 row)

Done. Let's check it:

prd_regab=> SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') AND t1.empty_count = 24 AND t1.batch_id = 1 GROUP BY t1.batch_id, t1.empty_count;
 batch_id | empty_count | count 
----------+-------------+-------
(0 rows)

All positions having empty_count=24 and batch_id=1 are classified. Now do the same for batch_id equal to 7,8,4,5,6 anc check again the status:

prd_regab=> SELECT t1.batch_id, t1.empty_count, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') AND t1.empty_count = 24 GROUP BY t1.batch_id, t1.empty_count;
 batch_id | empty_count |  count  
----------+-------------+---------
        3 |          24 |  999480
        9 |          24 | 1999055
       10 |          24 |  199883
       11 |          24 |  399801
       12 |          24 | 3730619
(5 rows)

Good. Now proceed with batch_id 10,11,3,9 .... and finally 12.

To check what is missing overall we can run:

prd_regab=> SELECT t1.batch_id, t1.empty_count, t1.status, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') GROUP BY t1.batch_id, t1.empty_count, t1.status ORDER BY t1.empty_count, t1.batch_id, t1.status;
 batch_id | empty_count | status |  count  
----------+-------------+--------+---------
       12 |          24 | CMR    | 3752210
        1 |          25 | CMS    |       1
        3 |          25 | CMR    |      58
        3 |          25 | CMS    |  999538
        4 |          25 | CMS    |     999
        5 |          25 | CMS    |    9998
        6 |          25 | CMR    |       7
        6 |          25 | CMS    |   99966
        7 |          25 | CMS    |      10
        8 |          25 | CMS    |     100
        9 |          25 | CMR    |     125
        9 |          25 | CMS    | 1999180
       10 |          25 | CMR    |      16
       10 |          25 | CMS    |  199899
       11 |          25 | CMR    |      31
       11 |          25 | CMS    |  399832
       12 |          25 | CMR    |     213
       12 |          25 | CMS    | 3752423
(18 rows)

All positions in CMS/CMR status have been classified:

prd_regab=> SELECT t1.batch_id, t1.empty_count, t1.status, count(1) FROM regab_prng_gp AS t1 LEFT JOIN regab_prng_gp_pattern_class AS t2 ON t1.seq = t2.gp_id WHERE t2.gp_id IS NULL AND t1.status IN('CMS','CMR') GROUP BY t1.batch_id, t1.empty_count, t1.status ORDER BY t1.empty_count, t1.batch_id, t1.status;
 batch_id | empty_count | status | count 
----------+-------------+--------+-------
(0 rows)

###
### Section --7--
###
### How to SOLVE the RGLM (Regab Generalized Linear Model) and generate the WEIGHTS for model parameters.
###

The archetype is given by A2050 where:

 -  A : stands for a data set based on batch_id = 3
 - 20 : stands for empy_count = 20
 - 50 : stands for a model based on feature=INTERCEPT,MOBILITY3 , pattern=XEDGE,CORNER,R2,R3,R4,DIAG3,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8,2X5COR

Look into the c/script/rglm.sh script for documentation.
It runs a sequence of commands that are doing the job.
Do it for the ec=23 ....

$ ./script/rglm.sh 23 INTERCEPT,MOBILITY3 XEDGE,CORNER,R2,R3,R4,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8,2X5COR A2350 3 6 production check_sentinel
The REGAB command is: "./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env production --batch-id 3 --position-status CMS,CMR --empty-count 23 --feature INTERCEPT,MOBILITY3 --pattern XEDGE,CORNER,R2,R3,R4,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8,2X5COR --out-file ./rglmdata/A2350_00.dat 2>&1 | tee ./rglmdata/A2350_00.log"
Output file "./rglmdata/A2350_00.dat" has been overwritten.

-----------------------------------------------------------
--- Last entries from the regab database connection log ---
-----------------------------------------------------------
seq                           con_time                      
11985                         2025-01-14 21:36:57.061808    
11986                         2025-01-14 21:36:57.062769    
11987                         2025-01-22 11:47:31.371835    
-----------------------------------------------------------

Time saved to file is Wed Jan 22 11:47:31 2025
_____________________________________

Searched batch_ids: 3
Batch ids found matching the query
_____________________________________
      |          |        |          
 ---- | batch_id | status |   ngames 
______|__________|________|__________
 0000 |        3 |   CMP  |  1000000

Searched position statuses: CMR, CMS

____________________________________________________

Searched patterns: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Patterns found matching the query
____________________________________________________
      |            |        |            |          
 ---- | pattern_id |  name  | ninstances | nsquares 
______|____________|________|____________|__________
 0000 |          1 | CORNER |          4 |        9
 0001 |          2 | XEDGE  |          4 |       10
 0002 |          3 | R2     |          4 |        8
 0003 |          4 | R3     |          4 |        8
 0004 |          5 | R4     |          4 |        8
 0005 |          6 | DIAG4  |          4 |        4
 0006 |          7 | DIAG5  |          4 |        5
 0007 |          8 | DIAG6  |          4 |        6
 0008 |          9 | DIAG7  |          4 |        7
 0009 |         10 | DIAG8  |          2 |        8
 0010 |         11 | 2X5COR |          8 |       10

Procedure regab_action_extract_count_positions() executed succesfully.

   ----------------------------
      Position Summary Table   
   ----------------------------
________________________________________________________
      |          |        |            |                
 rec  | batch_id | status |   gp_cnt   | classified_cnt 
______|__________|________|____________|________________
 0000 |        3 |   CMR  |     999551 |         999551
 0001 |        3 |   CMS  |     999552 |         999552

Procedure regab_action_extract_count_pattern_freqs() executed succesfully.
GLM variables are 76632, given by features are 4, and by patterns are 76628.
Procedure do_action_extract_game_pos_prepare_cursor() executed succesfully.
Total count of Game Position Records is 1999103.
Database transaction has been closed.
Binary output file written to ./rglmdata/A2350_00.dat, computed SHA3-256 digest, written to file ./rglmdata/A2350_00.dat.sha3-256.
The REGAB command is: "./build/bin/regab -v --action extract --config-file cfg/regab.cfg --env production --batch-id 6 --position-status CMS,CMR --empty-count 23 --game-positions --out-file ./rglmdata/A2350_positions_check.dat 2>&1 | tee ./rglmdata/A2350_positions_check.log"
Output file "./rglmdata/A2350_positions_check.dat" has been overwritten.

-----------------------------------------------------------
--- Last entries from the regab database connection log ---
-----------------------------------------------------------
seq                           con_time                      
11986                         2025-01-14 21:36:57.062769    
11987                         2025-01-22 11:47:31.371835    
11988                         2025-01-22 11:53:17.77448     
-----------------------------------------------------------

Time saved to file is Wed Jan 22 11:53:17 2025
_____________________________________

Searched batch_ids: 6
Batch ids found matching the query
_____________________________________
      |          |        |          
 ---- | batch_id | status |   ngames 
______|__________|________|__________
 0000 |        6 |   CMP  |   100000

Searched position statuses: CMR, CMS

Procedure regab_action_extract_count_positions() executed succesfully.

   ----------------------------
      Position Summary Table   
   ----------------------------
________________________________________________________
      |          |        |            |                
 rec  | batch_id | status |   gp_cnt   | classified_cnt 
______|__________|________|____________|________________
 0000 |        6 |   CMR  |      99971 |          99971
 0001 |        6 |   CMS  |      99971 |          99971

Procedure do_action_extract_game_pos_prepare_cursor() executed succesfully.
Total count of Game Position Records is 199942.
Database transaction has been closed.
Binary output file written to ./rglmdata/A2350_positions_check.dat, computed SHA3-256 digest, written to file ./rglmdata/A2350_positions_check.dat.sha3-256.
The RGLM command is: "./build/bin/rglm --verbose --solve --input-file ./rglmdata/A2350_00.dat --output-file ./rglmdata/A2350_01.dat 2>&1 | tee ./rglmdata/A2350_01.log"
Opening RGLM general data binary file: "./rglmdata/A2350_00.dat" - SHA3-256 file digest: 0097fa4e76ab5b203b72c0fc50eb22ffa1ee280c5460c4a487056b80102ec30f
Input file started to be written on (UTC) Wed Jan 22 11:47:31 2025
The format of the binary data file is: GENERAL
Selected batch_id values: 3
Selected empty_count value: 23
Selected position_statuses values: CMS, CMR
Selected feature values: INTERCEPT, MOBILITY3
Selected pattern values: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Position Summary Table: number of tuples = 2; game position count = 1999103
Feature and Pattern Frequency Summary Table: number of tuples = 76632
  Feature id:  0 [ INTERCEPT][     1][F_000:F_000], total_cnt =  1999103
  Feature id:  3 [ MOBILITY3][     3][F_001:F_003], total_cnt =  5997309
  Pattern id:  1     [CORNER][  5133][I_000:I_003], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  2     [ XEDGE][ 23131][I_004:I_007], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9993
  Pattern id:  3     [    R2][  3321][I_008:I_011], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  4     [    R3][  3318][I_012:I_015], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  5     [    R4][  1485][I_016:I_019], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  6     [ DIAG4][    45][I_020:I_023], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  7     [ DIAG5][   135][I_024:I_027], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  8     [ DIAG6][   378][I_028:I_031], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  9     [ DIAG7][   756][I_032:I_035], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 10     [ DIAG8][  1432][I_036:I_037], total_cnt =  3998206, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 11     [2X5COR][ 37494][I_038:I_045], total_cnt = 15992824, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9999
The reverse map "(entity_class, entity_id, principal_index_value) --> glm_variable_id" has been computed.
All 1999103 solved and classified game positions has been read succesfully.
Dumping factor for the diagonal of the Hessian matrix (Levemberg-Marquardt): lambda = 1.000000e-09
Max number of Newton-Raphson algorithm iterations = 12
Termination criteria:
   Epsilon on modulus of gradient: 1.000000e-09
Iteration[000]:
   Residual: mean =  0.011000403525, variance =  0.042669675877, standard deviation =  0.206566395807 (26.98) [26]
   Effe             =       42771.471797463229449932
   Residual modulus =         292.477253123942034563; abs min = [    0.000000000000000000,      25]; abs max = [    0.489999999999999991,     350]
   Gradient modulus =       32860.822839799322537147; abs min = [    0.000000000000000000,     213]; abs max = [ 9786.388352592191949952,       1]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [   152.691761247][   153.268701744]
   Cholesky Factorization ok, CPU time:                           [  3643.871684211][   923.558837386]
   Cholesky Solution CPU time:                                    [     7.391383000][     7.370765535]
   Delta w modulus  =          30.526304161939293635; abs min = [    0.000000302073299660,   22263]; abs max = [    2.042296164157041183,       1]
   Delta Effe       =       39452.351806321486947127
Iteration[001]:
   Residual: mean =  0.000915562403, variance =  0.003315111321, standard deviation =  0.057577003407 ( 7.52) [ 8]
   Effe             =        3319.119991141744776542
   Residual modulus =          81.418188568805788918; abs min = [    0.000000022726045268,  518788]; abs max = [    0.780524069349788685,  877586]
   Gradient modulus =        2499.743184293831745890; abs min = [    0.000000000005451421,   15496]; abs max = [  758.909810347628308591,       1]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [    38.682345691][    38.687996657]
   Cholesky Factorization ok, CPU time:                           [  3696.925742853][   932.643581578]
   Cholesky Solution CPU time:                                    [     7.212586852][     7.199948312]
   Delta w modulus  =           8.573601740856950926; abs min = [    0.000000048823662082,   42410]; abs max = [    4.189774965166042087,       2]
   Delta Effe       =         443.977651561255242996
Iteration[002]:
   Residual: mean = -0.000234157277, variance =  0.002870251397, standard deviation =  0.053574727225 ( 7.00) [ 6]
   Effe             =        2875.142339580489533546
   Residual modulus =          75.749817946280401770; abs min = [    0.000000081241238181, 1456741]; abs max = [    0.821956321900462306,  877586]
   Gradient modulus =         257.732656240207745668; abs min = [    0.000000000000415977,   25000]; abs max = [   78.448213243336454070,       1]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [    38.924432563][    38.950081460]
   Cholesky Factorization ok, CPU time:                           [  4079.968229202][  1029.285522884]
   Cholesky Solution CPU time:                                    [     7.219509362][     7.206821571]
   Delta w modulus  =           2.742976010860856739; abs min = [    0.000000042373005285,   43462]; abs max = [    1.348427368410243465,       2]
   Delta Effe       =           7.082110281032782950
Iteration[003]:
   Residual: mean = -0.000345631262, variance =  0.002862692009, standard deviation =  0.053504130763 ( 6.99) [ 6]
   Effe             =        2868.060229299456750596
   Residual modulus =          75.650856801711398703; abs min = [    0.000000026775723638,  230413]; abs max = [    0.828822855335550446,  877586]
   Gradient modulus =           5.105522671020739978; abs min = [    0.000000000000001362,    6737]; abs max = [    1.478603679580924535,       1]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [    39.358241397][    39.393464974]
   Cholesky Factorization ok, CPU time:                           [  3763.431496344][   949.657771126]
   Cholesky Solution CPU time:                                    [     7.236551685][     7.227482112]
   Delta w modulus  =           0.291007745572929077; abs min = [    0.000000001365383715,   71732]; abs max = [    0.083205211161206910,   14792]
   Delta Effe       =           0.006294238393365958
Iteration[004]:
   Residual: mean = -0.000346075940, variance =  0.002862662628, standard deviation =  0.053503856197 ( 6.99) [ 6]
   Effe             =        2868.053935061063384637
   Residual modulus =          75.650472665127253435; abs min = [    0.000000008217271474,  172501]; abs max = [    0.829049832300329248,  877586]
   Gradient modulus =           0.005487889956092047; abs min = [    0.000000000000000280,   10197]; abs max = [    0.001578933249720887,       1]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [    40.989835027][    40.995008976]
   Cholesky Factorization ok, CPU time:                           [  4077.310261849][  1028.553728018]
   Cholesky Solution CPU time:                                    [     6.984219482][     6.972713640]
   Delta w modulus  =           0.009690441769106025; abs min = [    0.000000000004338237,   58578]; abs max = [    0.005691967676367531,   14811]
   Delta Effe       =           0.000001610137587704
Iteration[005]:
   Residual: mean = -0.000346078102, variance =  0.002862662399, standard deviation =  0.053503854057 ( 6.99) [ 6]
   Effe             =        2868.053933450925796933
   Residual modulus =          75.650469659125462840; abs min = [    0.000000019088207071, 1822177]; abs max = [    0.829050085966902661,  877586]
   Gradient modulus =           0.000004874982499452; abs min = [    0.000000000000000000,   15399]; abs max = [    0.000001422289223235,       0]
   Function, Gradient, Hessian, and Residual evaluation CPU time: [    38.200352945][    38.210432735]
   Cholesky Factorization ok, CPU time:                           [  3770.751626717][   951.191380788]
   Cholesky Solution CPU time:                                    [     7.345171102][     7.337503779]
   Delta w modulus  =           0.000029776552902608; abs min = [    0.000000000000061096,   17197]; abs max = [    0.000024373688498584,   14811]
   Delta Effe       =          -0.000000000054569682
Termination criteria reached:
   Residual: mean = -0.000346078109, variance =  0.002862662399, standard deviation =  0.053503854054 ( 6.99) [ 6]
   Effe             =        2868.053933450980366615
   Residual modulus =          75.650469655274974912; abs min = [    0.000000019138678586, 1822177]; abs max = [    0.829050085958777272,  877586]
   Gradient modulus =           0.000000000136222420; abs min = [    0.000000000000000000,    6029]; abs max = [    0.000000000106075948,       0]
Binary output file written to ./rglmdata/A2350_01.dat, computed SHA3-256 digest, written to file ./rglmdata/A2350_01.dat.sha3-256.
The RGLM extraction command is: "./build/bin/rglm --verbose --input-file ./rglmdata/A2350_01.dat -A ./rglmdata/A2350_01.A.csv -B ./rglmdata/A2350_01.B.csv -P ./rglmdata/A2350_01.P.csv -w ./rglmdata/A2350_01.w.dat 2>&1 | tee ./rglmdata/A2350_01.ABPw.log"
Opening RGLM general data binary file: "./rglmdata/A2350_01.dat" - SHA3-256 file digest: e9cfc41959f7fa5ab91c2f363fecd274662c3cecc74660c559c076084ad99e3c
Input file started to be written on (UTC) Wed Jan 22 13:36:58 2025
The format of the binary data file is: GENERAL
Selected batch_id values: 3
Selected empty_count value: 23
Selected position_statuses values: CMS, CMR
Selected feature values: INTERCEPT, MOBILITY3
Selected pattern values: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Position Summary Table: number of tuples = 2; game position count = 1999103
Feature and Pattern Frequency Summary Table: number of tuples = 76632
  Feature id:  0 [ INTERCEPT][     1][F_000:F_000], total_cnt =  1999103
  Feature id:  3 [ MOBILITY3][     3][F_001:F_003], total_cnt =  5997309
  Pattern id:  1     [CORNER][  5133][I_000:I_003], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  2     [ XEDGE][ 23131][I_004:I_007], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9993
  Pattern id:  3     [    R2][  3321][I_008:I_011], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  4     [    R3][  3318][I_012:I_015], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  5     [    R4][  1485][I_016:I_019], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  6     [ DIAG4][    45][I_020:I_023], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  7     [ DIAG5][   135][I_024:I_027], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  8     [ DIAG6][   378][I_028:I_031], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  9     [ DIAG7][   756][I_032:I_035], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 10     [ DIAG8][  1432][I_036:I_037], total_cnt =  3998206, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 11     [2X5COR][ 37494][I_038:I_045], total_cnt = 15992824, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9999
The reverse map "(entity_class, entity_id, principal_index_value) --> glm_variable_id" has been computed.
All 1999103 solved and classified game positions has been read succesfully.
Position summary table dumped to CSV file: "./rglmdata/A2350_01.A.csv".
Feature and pattern frequencies summary table dumped to CSV file: "./rglmdata/A2350_01.B.csv".
Game positions dumped to CSV file: "./rglmdata/A2350_01.P.csv".
RGLM model weights binary file written to ./rglmdata/A2350_01.w.dat
The RGLMW weights extraction command is: "./build/bin/rglmw --verbose --weights-file ./rglmdata/A2350_01.w.dat --extract-weights ./rglmdata/A2350_01.w.W.csv 2>&1 | tee ./rglmdata/A2350_01.w.WPP_check.log"
Opening RGLM model weights binary file: "./rglmdata/A2350_01.w.dat" - SHA3-256 file digest: 66a7e6ca9a0dbbfdc2c1cf0c3806cf01e8a0e80bee1437ff3805d3a36d1ca926
Input file started to be written on (UTC) Wed Jan 22 13:38:05 2025
General data checksum (SHA3-256 file digest): e9cfc41959f7fa5ab91c2f363fecd274662c3cecc74660c559c076084ad99e3c
Game position sample size: 1999103
Empty count: 23
Feature count: 2
Features: INTERCEPT, MOBILITY3
Pattern count: 11
Patterns: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Weight array size: 167269
Read 167269 weight records.
File: "./rglmdata/A2350_01.w.dat" read and closed succesfully.
Reverse map computed succesfully.
RGLM model weights data structure loaded and ready.
RGLM model weights table exported to CSV file: "./rglmdata/A2350_01.w.W.csv".
The RGLMW positions extraction command is: "./build/bin/rglmw --verbose --weights-file ./rglmdata/A2350_01.w.dat --positions-file ./rglmdata/A2350_01.dat --extract-positions ./rglmdata/A2350_01.w.P.csv 2>&1 | tee -a ./rglmdata/A2350_01.w.WPP_check.log"
Opening RGLM model weights binary file: "./rglmdata/A2350_01.w.dat" - SHA3-256 file digest: 66a7e6ca9a0dbbfdc2c1cf0c3806cf01e8a0e80bee1437ff3805d3a36d1ca926
Input file started to be written on (UTC) Wed Jan 22 13:38:05 2025
General data checksum (SHA3-256 file digest): e9cfc41959f7fa5ab91c2f363fecd274662c3cecc74660c559c076084ad99e3c
Game position sample size: 1999103
Empty count: 23
Feature count: 2
Features: INTERCEPT, MOBILITY3
Pattern count: 11
Patterns: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Weight array size: 167269
Read 167269 weight records.
File: "./rglmdata/A2350_01.w.dat" read and closed succesfully.
Reverse map computed succesfully.
RGLM model weights data structure loaded and ready.
Opening RGLM general data binary file: "./rglmdata/A2350_01.dat" - SHA3-256 file digest: e9cfc41959f7fa5ab91c2f363fecd274662c3cecc74660c559c076084ad99e3c
Input file started to be written on (UTC) Wed Jan 22 13:36:58 2025
The format of the binary data file is: GENERAL
Selected batch_id values: 3
Selected empty_count value: 23
Selected position_statuses values: CMS, CMR
Selected feature values: INTERCEPT, MOBILITY3
Selected pattern values: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Position Summary Table: number of tuples = 2; game position count = 1999103
Feature and Pattern Frequency Summary Table: number of tuples = 76632
  Feature id:  0 [ INTERCEPT][     1][F_000:F_000], total_cnt =  1999103
  Feature id:  3 [ MOBILITY3][     3][F_001:F_003], total_cnt =  5997309
  Pattern id:  1     [CORNER][  5133][I_000:I_003], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  2     [ XEDGE][ 23131][I_004:I_007], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9993
  Pattern id:  3     [    R2][  3321][I_008:I_011], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  4     [    R3][  3318][I_012:I_015], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  5     [    R4][  1485][I_016:I_019], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  6     [ DIAG4][    45][I_020:I_023], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  7     [ DIAG5][   135][I_024:I_027], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  8     [ DIAG6][   378][I_028:I_031], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id:  9     [ DIAG7][   756][I_032:I_035], total_cnt =  7996412, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 10     [ DIAG8][  1432][I_036:I_037], total_cnt =  3998206, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 1.0000
  Pattern id: 11     [2X5COR][ 37494][I_038:I_045], total_cnt = 15992824, gp_cnt =  1999103, cumulated relative frequency = 1.0000, cumulated theoretical probability = 0.9999
The reverse map "(entity_class, entity_id, principal_index_value) --> glm_variable_id" has been computed.
All 1999103 solved and classified game positions has been read succesfully.
RGLM general data format transformed from GENERAL to POSITIONS.
empty_count_w = 23
empty_count_p = 23
eval_depth    = 0
f_flag        = 0
Game positions dumped to CSV file: "./rglmdata/A2350_01.w.P.csv".
The RGLMW residual check command is: "./build/bin/rglmw --verbose --weights-file ./rglmdata/A2350_01.w.dat --positions-file ./rglmdata/A2350_positions_check.dat --extract-positions ./rglmdata/A2350_01.w.P_check.csv 2>&1 | tee -a ./rglmdata/A2350_01.w.WPP_check.log"
Opening RGLM model weights binary file: "./rglmdata/A2350_01.w.dat" - SHA3-256 file digest: 66a7e6ca9a0dbbfdc2c1cf0c3806cf01e8a0e80bee1437ff3805d3a36d1ca926
Input file started to be written on (UTC) Wed Jan 22 13:38:05 2025
General data checksum (SHA3-256 file digest): e9cfc41959f7fa5ab91c2f363fecd274662c3cecc74660c559c076084ad99e3c
Game position sample size: 1999103
Empty count: 23
Feature count: 2
Features: INTERCEPT, MOBILITY3
Pattern count: 11
Patterns: CORNER, XEDGE, R2, R3, R4, DIAG4, DIAG5, DIAG6, DIAG7, DIAG8, 2X5COR
Weight array size: 167269
Read 167269 weight records.
File: "./rglmdata/A2350_01.w.dat" read and closed succesfully.
Reverse map computed succesfully.
RGLM model weights data structure loaded and ready.
Opening RGLM general data binary file: "./rglmdata/A2350_positions_check.dat" - SHA3-256 file digest: a3c5713c1eb2361ffbece25cfc69712dd2ab2d2305b160f099f58d387ac2f389
Input file started to be written on (UTC) Wed Jan 22 11:53:17 2025
The format of the binary data file is: POSITIONS
Selected batch_id values: 6
Selected empty_count value: 23
Selected position_statuses values: CMS, CMR
Selected feature values: --
Selected pattern values: --
Position Summary Table: number of tuples = 2; game position count = 199942
Feature and Pattern Frequency Summary Table: number of tuples = 0
The reverse map "(entity_class, entity_id, principal_index_value) --> glm_variable_id" has been computed.
All 199942 solved and classified game positions has been read succesfully.
empty_count_w = 23
empty_count_p = 23
eval_depth    = 0
f_flag        = 0
Game positions dumped to CSV file: "./rglmdata/A2350_01.w.P_check.csv".
Touching file: "./rglmdata/A2350.sentinel"

This list of files that has been created:

./rglmdata/A2350_00.dat
./rglmdata/A2350_00.dat.SHA3-256
./rglmdata/A2350_00.log
./rglmdata/A2350_01.ABPw.log
./rglmdata/A2350_01.A.csv
./rglmdata/A2350_01.B.csv
./rglmdata/A2350_01.dat
./rglmdata/A2350_01.dat.SHA3-256
./rglmdata/A2350_01.log
./rglmdata/A2350_01.P.csv
./rglmdata/A2350_01.w.dat
./rglmdata/A2350_01.w.dat.SHA3-256
./rglmdata/A2350_01.w.P_check.csv
./rglmdata/A2350_01.w.P.csv
./rglmdata/A2350_01.w.W.csv
./rglmdata/A2350_01.w.WPP_check.log
./rglmdata/A2350_positions_check.dat
./rglmdata/A2350_positions_check.dat.SHA3-256
./rglmdata/A2350_positions_check.log
./rglmdata/A2350.sentinel

$ ./script/rglm.sh 24 INTERCEPT,MOBILITY3 XEDGE,CORNER,R2,R3,R4,DIAG4,DIAG5,DIAG6,DIAG7,DIAG8,2X5COR A2450 3 6 production check_sentinel
...
...
...
$ ls -1 ./rglmdata/A2450*
./rglmdata/A2450_00.dat
./rglmdata/A2450_00.dat.SHA3-256
./rglmdata/A2450_00.log
./rglmdata/A2450_01.ABPw.log
./rglmdata/A2450_01.A.csv
./rglmdata/A2450_01.B.csv
./rglmdata/A2450_01.dat
./rglmdata/A2450_01.dat.SHA3-256
./rglmdata/A2450_01.log
./rglmdata/A2450_01.P.csv
./rglmdata/A2450_01.w.dat
./rglmdata/A2450_01.w.dat.SHA3-256
./rglmdata/A2450_01.w.P_check.csv
./rglmdata/A2450_01.w.P.csv
./rglmdata/A2450_01.w.W.csv
./rglmdata/A2450_01.w.WPP_check.log
./rglmdata/A2450_positions_check.dat
./rglmdata/A2450_positions_check.dat.SHA3-256
./rglmdata/A2450_positions_check.log
./rglmdata/A2450.sentinel
