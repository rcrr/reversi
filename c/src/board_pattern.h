/**
 * @file
 *
 * @todo [done] Complete the PATTERN basic programs in board_pattern and board_transformation modules.
 *              Patterns needed are:
 *               - EDGE
 *               - CORNER
 *               - XEDGE
 *               - R2, R3, R4
 *               - DIAG4, DIAG5, DIAG6, DIAG7, DIAG8
 *               - 2X5COR
 *               - DIAG3
 *              Change the REGAB_DB definition by adding a board_pattern_id column (unique) that matches with the enum defined in this class.
 *              Add to the database the missing definition.
 *
 * @todo [done] Complete the regab_prng_pattern_ranges for all patterns.
 *              The EDGE statistics have been computed by:
 *              $ time ./build/bin/endgame_solver -f db/gpdb-sample-games.txt -q initial -s rand -n 1000000000 -P EDGE -r 628
 *
 * @todo [done] Verify how the { pattern_id, instance_id, index } are mapped to-from a position configuration.
 *              Build a new table regab_prng_gp_pattern_class with the following colums:
 *               - gp_ig                             The table KEY, referencing the regab_prng_gp table
 *               - EDGE_0, EDGE_1, EDGE_2, EDGE_3    Pattern Index Value (50 colums, type INTEGER)
 *               - CORNER_0, ....
 *               - ...
 *               - 2X5COR_0, ... , 2X5COR_7
 *              The tale is then populated by a PGPLSQL procedure
 *              Remove the gp_classification_h and gp_classification table are TOO BIG !!! And the classification option in REGAB.
 *
 * @todo [done] Build a structure and the relative machinery for generetaing / accessing the "general index" PATTERN_CONF_IDX
 *              The structure considers unpossible configurations and symmetries.
 *
 * @todo [done] Build a function that given a board configuration pi, extracts the hij compressed vector.
 *              Compressed means a vector of the indexes of the non-zero (ones) values, one for each { pattern_id, instance_id } entry.
 *
 * @todo [done] Prepare a table/matrix having as row the positions extracted from the REGAB_DB and as column the value generated by the previous entry.
 *              Prepare a vector with the ri values (or the game_value) for each row of the table.
 *
 * @todo [done] Prepare the program for solving the Newton-Raphson system in C or by writing the appropriate matrix decomposition library (Cholewsky).
 *              Then prepare:
 *              - g(x) computation
 *              - vector h computation
 *              - sum w * h computation
 *              - value of e(w,p) computation
 *              - Formulas for (e^3 - (r+1)*e^2 + r*e), (-3e^4 ... + r*e), vector f(w) and matrix J(w) computation
 *              - Newton-Raphson iteration machinery
 *
 * @todo [done] A program in C or R that extract data from REGAB_DB, loads the DATA, run the solver, save the result to file or DB.
 *              Results are the W vector and the convergence criteria.
 *
 *
 *
 * @brief Defines pattern and indexes for reversi boards.
 *
 * @details To be completed.
 *
 *
 * The `EDGE` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  a b c d e f g h     . . . . . . . a     . . . . . . . .     h . . . . . . .
 * 2  . . . . . . . .     . . . . . . . b     . . . . . . . .     g . . . . . . .
 * 3  . . . . . . . .     . . . . . . . c     . . . . . . . .     f . . . . . . .
 * 4  . . . . . . . .     . . . . . . . d     . . . . . . . .     e . . . . . . .
 * 5  . . . . . . . .     . . . . . . . e     . . . . . . . .     d . . . . . . .
 * 6  . . . . . . . .     . . . . . . . f     . . . . . . . .     c . . . . . . .
 * 7  . . . . . . . .     . . . . . . . g     . . . . . . . .     b . . . . . . .
 * 8  . . . . . . . .     . . . . . . . h     h g f e d c b a     a . . . . . . .
 *
 * @endcode
 *
 *
 * The `CORNER` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  a b c . . . . .     . . . . . g d a     . . . . . . . .     . . . . . . . .
 * 2  d e f . . . . .     . . . . . h e b     . . . . . . . .     . . . . . . . .
 * 3  g h i . . . . .     . . . . . i f c     . . . . . . . .     . . . . . . . .
 * 4  . . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
 * 5  . . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
 * 6  . . . . . . . .     . . . . . . . .     . . . . . i h g     c f i . . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . . . f e d     b e h . . . . .
 * 8  . . . . . . . .     . . . . . . . .     . . . . . c b a     a d g . . . . .
 *
 * @endcode
 *
 *
 * The `XEDGE` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  a b c d e f g h     . . . . . . . a     . . . . . . . .     h . . . . . . .
 * 2  . i . . . . l .     . . . . . . i b     . . . . . . . .     g l . . . . . .
 * 3  . . . . . . . .     . . . . . . . c     . . . . . . . .     f . . . . . . .
 * 4  . . . . . . . .     . . . . . . . d     . . . . . . . .     e . . . . . . .
 * 5  . . . . . . . .     . . . . . . . e     . . . . . . . .     d . . . . . . .
 * 6  . . . . . . . .     . . . . . . . f     . . . . . . . .     c . . . . . . .
 * 7  . . . . . . . .     . . . . . . l g     . l . . . . i .     b i . . . . . .
 * 8  . . . . . . . .     . . . . . . . h     h g f e d c b a     a . . . . . . .
 *
 * @endcode
 *
 *
 * The `R2` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . . . .     . . . . . . a .     . . . . . . . .     . h . . . . . .
 * 2  a b c d e f g h     . . . . . . b .     . . . . . . . .     . g . . . . . .
 * 3  . . . . . . . .     . . . . . . c .     . . . . . . . .     . f . . . . . .
 * 4  . . . . . . . .     . . . . . . d .     . . . . . . . .     . e . . . . . .
 * 5  . . . . . . . .     . . . . . . e .     . . . . . . . .     . d . . . . . .
 * 6  . . . . . . . .     . . . . . . f .     . . . . . . . .     . c . . . . . .
 * 7  . . . . . . . .     . . . . . . g .     h g f e d c b a     . b . . . . . .
 * 8  . . . . . . . .     . . . . . . h .     . . . . . . . .     . a . . . . . .
 *
 * @endcode
 *
 *
 * The `R3` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . . . .     . . . . . a . .     . . . . . . . .     . . h . . . . .
 * 2  . . . . . . . .     . . . . . b . .     . . . . . . . .     . . g . . . . .
 * 3  a b c d e f g h     . . . . . c . .     . . . . . . . .     . . f . . . . .
 * 4  . . . . . . . .     . . . . . d . .     . . . . . . . .     . . e . . . . .
 * 5  . . . . . . . .     . . . . . e . .     . . . . . . . .     . . d . . . . .
 * 6  . . . . . . . .     . . . . . f . .     h g f e d c b a     . . c . . . . .
 * 7  . . . . . . . .     . . . . . g . .     . . . . . . . .     . . b . . . . .
 * 8  . . . . . . . .     . . . . . h . .     . . . . . . . .     . . a . . . . .
 *
 * @endcode
 *
 *
 * The `R4` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . . . .     . . . . a . . .     . . . . . . . .     . . . h . . . .
 * 2  . . . . . . . .     . . . . b . . .     . . . . . . . .     . . . g . . . .
 * 3  . . . . . . . .     . . . . c . . .     . . . . . . . .     . . . f . . . .
 * 4  a b c d e f g h     . . . . d . . .     . . . . . . . .     . . . e . . . .
 * 5  . . . . . . . .     . . . . e . . .     h g f e d c b a     . . . d . . . .
 * 6  . . . . . . . .     . . . . f . . .     . . . . . . . .     . . . c . . . .
 * 7  . . . . . . . .     . . . . g . . .     . . . . . . . .     . . . b . . . .
 * 8  . . . . . . . .     . . . . h . . .     . . . . . . . .     . . . a . . . .
 *
 * @endcode
 *
 *
 * The `DIAG4` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . d . . . .     . . . . a . . .     . . . . . . . .     . . . . . . . .
 * 2  . . c . . . . .     . . . . . b . .     . . . . . . . .     . . . . . . . .
 * 3  . b . . . . . .     . . . . . . c .     . . . . . . . .     . . . . . . . .
 * 4  a . . . . . . .     . . . . . . . d     . . . . . . . .     . . . . . . . .
 * 5  . . . . . . . .     . . . . . . . .     . . . . . . . a     d . . . . . . .
 * 6  . . . . . . . .     . . . . . . . .     . . . . . . b .     . c . . . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . . . c . .     . . b . . . . .
 * 8  . . . . . . . .     . . . . . . . .     . . . . d . . .     . . . a . . . .
 *
 * @endcode
 *
 *
 * The `DIAG5` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . e . . .     . . . a . . . .     . . . . . . . .     . . . . . . . .
 * 2  . . . d . . . .     . . . . b . . .     . . . . . . . .     . . . . . . . .
 * 3  . . c . . . . .     . . . . . c . .     . . . . . . . .     . . . . . . . .
 * 4  . b . . . . . .     . . . . . . d .     . . . . . . . a     e . . . . . . .
 * 5  a . . . . . . .     . . . . . . . e     . . . . . . b .     . d . . . . . .
 * 6  . . . . . . . .     . . . . . . . .     . . . . . c . .     . . c . . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . . d . . .     . . . b . . . .
 * 8  . . . . . . . .     . . . . . . . .     . . . e . . . .     . . . . a . . .
 *
 * @endcode
 *
 *
 * The `DIAG6` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . f . .     . . a . . . . .     . . . . . . . .     . . . . . . . .
 * 2  . . . . e . . .     . . . b . . . .     . . . . . . . .     . . . . . . . .
 * 3  . . . d . . . .     . . . . c . . .     . . . . . . . a     f . . . . . . .
 * 4  . . c . . . . .     . . . . . d . .     . . . . . . b .     . e . . . . . .
 * 5  . b . . . . . .     . . . . . . e .     . . . . . c . .     . . d . . . . .
 * 6  a . . . . . . .     . . . . . . . f     . . . . d . . .     . . . c . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . e . . . .     . . . . b . . .
 * 8  . . . . . . . .     . . . . . . . .     . . f . . . . .     . . . . . a . .
 *
 * @endcode
 *
 *
 * The `DIAG7` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . . g .     . a . . . . . .     . . . . . . . .     . . . . . . . .
 * 2  . . . . . f . .     . . b . . . . .     . . . . . . . a     g . . . . . . .
 * 3  . . . . e . . .     . . . c . . . .     . . . . . . b .     . f . . . . . .
 * 4  . . . d . . . .     . . . . d . . .     . . . . . c . .     . . e . . . . .
 * 5  . . c . . . . .     . . . . . e . .     . . . . d . . .     . . . d . . . .
 * 6  . b . . . . . .     . . . . . . f .     . . . e . . . .     . . . . c . . .
 * 7  a . . . . . . .     . . . . . . . g     . . f . . . . .     . . . . . b . .
 * 8  . . . . . . . .     . . . . . . . .     . g . . . . . .     . . . . . . a .
 *
 * @endcode
 *
 *
 * The `DIAG8` pattern has two instances ranging `[0, 1]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h
 *
 * 1  . . . . . . . h     a . . . . . . .
 * 2  . . . . . . g .     . b . . . . . .
 * 3  . . . . . f . .     . . c . . . . .
 * 4  . . . . e . . .     . . . d . . . .
 * 5  . . . d . . . .     . . . . e . . .
 * 6  . . c . . . . .     . . . . . f . .
 * 7  . b . . . . . .     . . . . . . g .
 * 8  a . . . . . . .     . . . . . . . h
 *
 * @endcode
 *
 *
 * The `2X5COR` pattern has eight instances ranging from `[0..7]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  a b c d e . . .     . . . . . . f a     . . . . . . . .     . . . . . . . .
 * 2  f g h i l . . .     . . . . . . g b     . . . . . . . .     . . . . . . . .
 * 3  . . . . . . . .     . . . . . . h c     . . . . . . . .     . . . . . . . .
 * 4  . . . . . . . .     . . . . . . i d     . . . . . . . .     e l . . . . . .
 * 5  . . . . . . . .     . . . . . . l e     . . . . . . . .     d i . . . . . .
 * 6  . . . . . . . .     . . . . . . . .     . . . . . . . .     c h . . . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . l i h g f     b g . . . . . .
 * 8  . . . . . . . .     . . . . . . . .     . . . e d c b a     a f . . . . . .
 *
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . . e d c b a     . . . . . . . .     . . . . . . . .     a f . . . . . .
 * 2  . . . l i h g f     . . . . . . . .     . . . . . . . .     b g . . . . . .
 * 3  . . . . . . . .     . . . . . . . .     . . . . . . . .     c h . . . . . .
 * 4  . . . . . . . .     . . . . . . l e     . . . . . . . .     d i . . . . . .
 * 5  . . . . . . . .     . . . . . . i d     . . . . . . . .     e l . . . . . .
 * 6  . . . . . . . .     . . . . . . h c     . . . . . . . .     . . . . . . . .
 * 7  . . . . . . . .     . . . . . . g b     f g h i l . . .     . . . . . . . .
 * 8  . . . . . . . .     . . . . . . f a     a b c d e . . .     . . . . . . . .
 *
 * @endcode
 *
 *
 * The `DIAG3` pattern has four instances ranging from `[0..3]`:
 *
 * @code
 *
 *    a b c d e f g h     a b c d e f g h     a b c d e f g h     a b c d e f g h
 *
 * 1  . . c . . . . .     . . . . . a . .     . . . . . . . .     . . . . . . . .
 * 2  . b . . . . . .     . . . . . . b .     . . . . . . . .     . . . . . . . .
 * 3  a . . . . . . .     . . . . . . . c     . . . . . . . .     . . . . . . . .
 * 4  . . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
 * 5  . . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
 * 6  . . . . . . . .     . . . . . . . .     . . . . . . . a     c . . . . . . .
 * 7  . . . . . . . .     . . . . . . . .     . . . . . . b .     . b . . . . . .
 * 8  . . . . . . . .     . . . . . . . .     . . . . . c . .     . . a . . . . .
 *
 * @endcode
 *
 *
 * @par board_pattern.h
 * <tt>
 * This file is part of the reversi program
 * http://github.com/rcrr/reversi
 * </tt>
 * @author Roberto Corradini mailto:rob_corradini@yahoo.it
 * @copyright 2018, 2020 Roberto Corradini. All rights reserved.
 *
 * @par License
 * <tt>
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 3, or (at your option) any
 * later version.
 * \n
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * \n
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 * or visit the site <http://www.gnu.org/licenses/>.
 * </tt>
 */

#ifndef BOARD_PATTERN_H
#define BOARD_PATTERN_H

#include "board_trans.h"


/*
 * board_t definitions.
 */

typedef struct board_s board_t;

struct board_s { SquareSet square_sets[2]; };

extern SquareSet
board_get_mover_square_set (const board_t *const b);

extern SquareSet
board_get_opponent_square_set (const board_t *const b);

extern void
board_set_mover_square_set (board_t *b,
                            SquareSet s);

extern void
board_set_opponent_square_set (board_t *b,
                               SquareSet s);

extern void
board_set_square_sets (board_t *b,
                       SquareSet m,
                       SquareSet o);

extern void
board_from_gpx (board_t *b,
                const GamePositionX *gpx);

/*
 * End of board_t definitions
 */

/**
 * @enum board_entity_class_t
 * @brief Used to uniquely identify features vs patterns.
 */
typedef enum {
  BOARD_ENTITY_CLASS_FEATURE,        /**< Feature ( e.g. Mobility ) */
  BOARD_ENTITY_CLASS_PATTERN,        /**< Pattern ( e.g. EDGE ) */
  BOARD_ENTITY_CLASS_INVALID         /**< Not a valid entity class. */
} board_entity_class_t;

#define BOARD_ENTITY_CLASS_COUNT BOARD_ENTITY_CLASS_INVALID

/**
 * @enum board_feature_id_t
 * @brief Features are a defined property of the board convertible to a real number.
 */
typedef enum {
  BOARD_FEATURE_INTERCEPT,           /**< Intercept */
  BOARD_FEATURE_MOBILITY,            /**< Mobility */
  BOARD_FEATURE_MOBILITY2,           /**< Mobility - Mobility^2 */
  BOARD_FEATURE_MOBILITY3,           /**< Mobility - Mobility^2 - Mobility^3 */
  BOARD_FEATURE_INVALID              /**< Not a valid feature. */
} board_feature_id_t;

#define BOARD_FEATURE_COUNT BOARD_FEATURE_INVALID

/*
 * The entry order in the board_pattern_id_t enum MUST match the
 * pattern_id given in the regab database.
 */

/**
 * @enum board_pattern_id_t
 * @brief Patterns are a defined set of squares of the board.
 */
typedef enum {
  BOARD_PATTERN_EDGE,                /**< A1 B1 C1 D1 E1 F1 G1 H1 */
  BOARD_PATTERN_CORNER,              /**< A1 B1 C1 A2 B2 C2 A3 B3 C3 */
  BOARD_PATTERN_XEDGE,               /**< A1 B1 C1 D1 E1 F1 G1 H1 B2 G2 */
  BOARD_PATTERN_R2,                  /**< A2 B2 C2 D2 E2 F2 G2 H2 */
  BOARD_PATTERN_R3,                  /**< A3 B3 C3 D3 E3 F3 G3 H3 */
  BOARD_PATTERN_R4,                  /**< A4 B4 C4 D4 E4 F4 G4 H4 */
  BOARD_PATTERN_DIAG4,               /**< A4 B3 C2 D1 */
  BOARD_PATTERN_DIAG5,               /**< A5 B4 C3 D2 E1 */
  BOARD_PATTERN_DIAG6,               /**< A6 B5 C4 D3 E2 F1 */
  BOARD_PATTERN_DIAG7,               /**< A7 B6 C5 D4 E3 F2 G1 */
  BOARD_PATTERN_DIAG8,               /**< A8 B7 C6 D5 E4 F3 G2 H1 */
  BOARD_PATTERN_2X5COR,              /**< A1 B1 C1 D1 E1 A2 B2 C2 D2 E2 */
  BOARD_PATTERN_DIAG3,               /**< A3 B2 C1 */
  BOARD_PATTERN_INVALID              /**< Not a valid pattern. */
} board_pattern_id_t;

#define BOARD_PATTERN_COUNT BOARD_PATTERN_INVALID
#define BOARD_PATTERN_INDEX_TABLE_SIZE 6561 + 19683 + 59049 + 6561 + 6561 + 6561 + 81 + 243 + 729 + 2187 + 6561 + 59049 + 27
#define BOARD_PATTERN_MAX_N_INSTANCES 8

typedef uint16_t board_pattern_index_t;

typedef struct board_feature_s board_feature_t;

typedef struct board_pattern_s board_pattern_t;

extern SquareSet
board_pattern_mask (SquareSet s,
                    board_pattern_index_t p,
                    unsigned int instance);

extern SquareSet
board_pattern_pack_edge (SquareSet s);

extern SquareSet
board_pattern_unpack_edge (SquareSet s);

extern SquareSet
board_pattern_pack_corner (SquareSet s);

extern SquareSet
board_pattern_unpack_corner (SquareSet s);

extern SquareSet
board_pattern_pack_xedge (SquareSet s);

extern SquareSet
board_pattern_unpack_xedge (SquareSet s);

extern SquareSet
board_pattern_pack_r2 (SquareSet s);

extern SquareSet
board_pattern_unpack_r2 (SquareSet s);

extern SquareSet
board_pattern_pack_r3 (SquareSet s);

extern SquareSet
board_pattern_unpack_r3 (SquareSet s);

extern SquareSet
board_pattern_pack_r4 (SquareSet s);

extern SquareSet
board_pattern_unpack_r4 (SquareSet s);

extern SquareSet
board_pattern_pack_diag4 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag4 (SquareSet s);

extern SquareSet
board_pattern_pack_diag5 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag5 (SquareSet s);

extern SquareSet
board_pattern_pack_diag6 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag6 (SquareSet s);

extern SquareSet
board_pattern_pack_diag7 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag7 (SquareSet s);

extern SquareSet
board_pattern_pack_diag8 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag8 (SquareSet s);

extern SquareSet
board_pattern_pack_2x5cor (SquareSet s);

extern SquareSet
board_pattern_unpack_2x5cor (SquareSet s);

extern SquareSet
board_pattern_pack_diag3 (SquareSet s);

extern SquareSet
board_pattern_unpack_diag3 (SquareSet s);

/**
 * @brief Returns `true` when `name` matches with valid pattern, otherwise `false`.
 *
 * @details When `true` is returned the value referenced by `idp` is updated
 *          with the proper pattern id, otherwise nothing happens.
 *          If `idp` is `NULL` no udate occurs.
 *
 * @param [out] idp  pattern id
 * @param [in]  name pattern name
 * @return           true if name matches with one registered pattern
 */
extern bool
board_pattern_get_id_by_name (board_pattern_id_t *idp,
                              char *name);

/**
 * @brief Returns `true` when `name` matches with valid feature, otherwise `false`.
 *
 * @details When `true` is returned the value referenced by `idp` is updated
 *          with the proper feature id, otherwise nothing happens.
 *          If `idp` is `NULL` no udate occurs.
 *
 * @param [out] idp  feature id
 * @param [in]  name feature name
 * @return           true if name matches with one registered feature
 */
extern bool
board_feature_get_id_by_name (board_feature_id_t *idp,
                              char *name);

typedef union board_pattern_rotated_u board_pattern_rotated_t;
typedef struct board_pattern_named_rotated_s board_pattern_named_rotated_t;

struct board_pattern_named_rotated_s {
  board_t identity;
  board_t rot_90a;
  board_t rot_180;
  board_t rot_90c;
  board_t flip_ve;
  board_t flip_dh;
  board_t flip_ho;
  board_t flip_da;
};

union board_pattern_rotated_u {
  board_t board_array[8];
  board_pattern_named_rotated_t named_boards;
};

extern void
board_feature_values_intercept (const board_t *board,
                                double *values);

extern void
board_feature_values_mobility (const board_t *board,
                               double *values);

extern void
board_feature_values_mobility2 (const board_t *board,
                                double *values);

extern void
board_feature_values_mobility3 (const board_t *board,
                                double *values);

struct board_feature_s {
  board_feature_id_t id;
  char name[11];
  unsigned int field_cnt;
  void (*feature_values_f) (const board_t *, double *);
};

static const board_feature_t board_features[] =
  {
    { BOARD_FEATURE_INTERCEPT,
      "INTERCEPT",
      1,
      board_feature_values_intercept },

    { BOARD_FEATURE_MOBILITY,
      "MOBILITY",
      1,
      board_feature_values_mobility },

    { BOARD_FEATURE_MOBILITY2,
      "MOBILITY2",
      2,
      board_feature_values_mobility2 },

    { BOARD_FEATURE_MOBILITY3,
      "MOBILITY3",
      3,
      board_feature_values_mobility3 },

    { BOARD_FEATURE_INVALID, "NULL", 0, NULL }
  };

#define BOARD_FEATURE_MAX_FIELD_CNT 3
#define BOARD_FEATURE_COMBINED_FIELD_CNT 7

struct board_pattern_s {
  board_pattern_id_t id;
  char name[7];
  unsigned int n_instances;
  unsigned int n_squares;
  unsigned long int n_configurations;
  SquareSet masks[8];
  board_trans_f trans_to_principal_f[8]; // array of transformation functions
  SquareSet (*pattern_pack_f) (SquareSet);
  SquareSet (*pattern_unpack_f) (SquareSet);
  SquareSet (*pattern_mirror_f) (SquareSet);
};

static const board_pattern_t board_patterns[] =
  {
    { BOARD_PATTERN_EDGE,
      "EDGE",
      4,
      8,
      6561,
      { 0x00000000000000ff,
        0x8080808080808080,
        0xff00000000000000,
        0x0101010101010101,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_edge,
      board_pattern_unpack_edge,
      board_trans_flip_vertical },

    { BOARD_PATTERN_CORNER,
      "CORNER",
      4,
      9,
      19683,
      { 0x0000000000070707,
        0x0000000000e0e0e0,
        0xe0e0e00000000000,
        0x0707070000000000,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_corner,
      board_pattern_unpack_corner,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_XEDGE,
      "XEDGE",
      4,
      10,
      59049,
      { 0x00000000000042ff,
        0x80c080808080c080,
        0xff42000000000000,
        0x0103010101010301,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_xedge,
      board_pattern_unpack_xedge,
      board_trans_flip_vertical },

    { BOARD_PATTERN_R2,
      "R2",
      4,
      8,
      6561,
      { 0x000000000000ff00,
        0x4040404040404040,
        0x00ff000000000000,
        0x0202020202020202,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_r2,
      board_pattern_unpack_r2,
      board_trans_flip_vertical },

    { BOARD_PATTERN_R3,
      "R3",
      4,
      8,
      6561,
      { 0x0000000000ff0000,
        0x2020202020202020,
        0x0000ff0000000000,
        0x0404040404040404,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_r3,
      board_pattern_unpack_r3,
      board_trans_flip_vertical },

    { BOARD_PATTERN_R4,
      "R4",
      4,
      8,
      6561,
      { 0x00000000ff000000,
        0x1010101010101010,
        0x000000ff00000000,
        0x0808080808080808,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_r4,
      board_pattern_unpack_r4,
      board_trans_flip_vertical },

    { BOARD_PATTERN_DIAG4,
      "DIAG4",
      4,
      4,
      81,
      { 0x0000000001020408,
        0x0000000080402010,
        0x1020408000000000,
        0x0804020100000000,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_diag4,
      board_pattern_unpack_diag4,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_DIAG5,
      "DIAG5",
      4,
      5,
      243,
      { 0x0000000102040810,
        0x0000008040201008,
        0x0810204080000000,
        0x1008040201000000,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_diag5,
      board_pattern_unpack_diag5,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_DIAG6,
      "DIAG6",
      4,
      6,
      729,
      { 0x0000010204081020,
        0x0000804020100804,
        0x0408102040800000,
        0x2010080402010000,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_diag6,
      board_pattern_unpack_diag6,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_DIAG7,
      "DIAG7",
      4,
      7,
      2187,
      { 0x0001020408102040,
        0x0080402010080402,
        0x0204081020408000,
        0x4020100804020100,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_diag7,
      board_pattern_unpack_diag7,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_DIAG8,
      "DIAG8",
      2,
      8,
      6561,
      { 0x0102040810204080,
        0x8040201008040201,
        0, 0, 0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        NULL, NULL, NULL, NULL, NULL, NULL },
      board_pattern_pack_diag8,
      board_pattern_unpack_diag8,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_2X5COR,
      "2X5COR",
      8,
      10,
      59049,
      { 0x0000000000001f1f,
        0x000000c0c0c0c0c0,
        0xf8f8000000000000,
        0x0303030303000000,
        0x000000000000f8f8,
        0xc0c0c0c0c0000000,
        0x1f1f000000000000,
        0x0000000303030303 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        board_trans_flip_vertical,
        board_trans_flip_diag_h1a8,
        board_trans_flip_horizontal,
        board_trans_flip_diag_a1h8 },
      board_pattern_pack_2x5cor,
      board_pattern_unpack_2x5cor,
      board_trans_identity },

    { BOARD_PATTERN_DIAG3,
      "DIAG3",
      4,
      3,
      27,
      { 0x0000000000010204,
        0x0000000000804020,
        0x2040800000000000,
        0x0402010000000000,
        0, 0, 0, 0 },
      { board_trans_identity,
        board_trans_rotate_90a,
        board_trans_rotate_180,
        board_trans_rotate_90c,
        NULL, NULL, NULL, NULL },
      board_pattern_pack_diag3,
      board_pattern_unpack_diag3,
      board_trans_flip_diag_a1h8 },

    { BOARD_PATTERN_INVALID, "NULL", 0, 0, 0, { 0,0,0,0,0,0,0,0 }, { NULL }, NULL, NULL, NULL }
  };

extern void
board_pattern_compute_indexes (board_pattern_index_t *indexes,
                               const board_pattern_t *const p,
                               const board_t *const b);

extern void
board_pattern_compute_principal_indexes (board_pattern_index_t *principals,
                                         const board_pattern_index_t *indexes,
                                         const board_pattern_t *const p,
                                         const bool one_value);

extern board_pattern_index_t
board_pattern_packed_to_index (board_t *packed,
                               unsigned int n_squares);

extern board_pattern_index_t
board_pattern_packed_to_index_vec (board_t *packed,
                                   unsigned int n_squares);

extern void
board_pattern_index_to_packed (board_t *packed,
                               board_pattern_index_t index);

extern void
board_pattern_compute_rotated (const board_t *board,
                               board_pattern_rotated_t *rotated);

#endif
