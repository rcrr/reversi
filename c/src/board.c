/**
 * @file
 *
 * @brief Board module implementation.
 * @details This module defines functions for the #Player, #SquareState,
 * #Square, #SquareSet, #GamePositionX entities.
 *
 * @par board.c
 * <tt>
 * This file is part of the reversi program
 * http://github.com/rcrr/reversi
 * </tt>
 * @author Roberto Corradini mailto:rob_corradini@yahoo.it
 * @copyright 2013, 2014, 2016, 2017, 2021 Roberto Corradini. All rights reserved.
 *
 * @par License
 * <tt>
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 3, or (at your option) any
 * later version.
 * \n
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * \n
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
 * or visit the site <http://www.gnu.org/licenses/>.
 * </tt>
 */

/*
 * Comment this line to enable assertion in the module.
 * The line must be inserted before the inclusion of <assert.h>
 */
#if !defined NDEBUG
#define NDEBUG
#endif

#define KOST 1

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "arch.h"
#include "board.h"

#include "kogge_stone.h"

#include <immintrin.h>

/**
 * @cond
 */

/*
 * Prototypes for internal functions.
 */

static void
board_initialize_zobrist_flip_bitstrings (void);

static SquareSet
kogge_stone_b (const SquareSet generator,
               const SquareSet propagator,
               const SquareSet blocker);

static SquareSet
kogge_stone_gpb (const SquareSet generator,
                 const SquareSet propagator,
                 const SquareSet blocker);



/*
 * Internal variables and constants.
 */

/* Array used for conversion between square/move and its string representation. */
static const char *const sq_to_s[] = {
  "A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1",
  "A2", "B2", "C2", "D2", "E2", "F2", "G2", "H2",
  "A3", "B3", "C3", "D3", "E3", "F3", "G3", "H3",
  "A4", "B4", "C4", "D4", "E4", "F4", "G4", "H4",
  "A5", "B5", "C5", "D5", "E5", "F5", "G5", "H5",
  "A6", "B6", "C6", "D6", "E6", "F6", "G6", "H6",
  "A7", "B7", "C7", "D7", "E7", "F7", "G7", "H7",
  "A8", "B8", "C8", "D8", "E8", "F8", "G8", "H8",
  "--", "NA", "UN"
};

/* A square set being all set. */
static const SquareSet all_squares = 0xFFFFFFFFFFFFFFFF;

/* A square set being all set with the exception of column A. */
static const SquareSet all_squares_except_column_a = 0xFEFEFEFEFEFEFEFE;

/* A square set being all set with the exception of column H. */
static const SquareSet all_squares_except_column_h = 0x7F7F7F7F7F7F7F7F;

/*
 * Zobrist bitstrings generated by the URANDOM Linux generator.
 * The array has 128 entries, 64 for black squares, and 64 for white ones.
 */
static const uint64_t zobrist_bitstrings[] = {
  0x4EC764D9D2FC995C, 0x4689879C5E2B6C8D, 0x7B8509672627BDE6, 0x5EC9EED7E83A1070,
  0x8C61E367C148A670, 0x12BF65D47CB500F3, 0x2D128CD312314B15, 0xEC8FFA579C3FF006,
  0x1B772E0C17A8637D, 0xFEA5D5093AE4F127, 0x3F6223B7D74731E8, 0x9BF6F10BF080F403,
  0xCE03618789AACB66, 0x29264F46A5C844E3, 0xD4BD485D4B88FC6E, 0xAAC3C81799DAE8F5,
  0x46B256D2079DA270, 0x5765CB86D7BE25B4, 0x7754057541AAAF9E, 0xB9E9E765C5214D6D,
  0x957833AE886E5003, 0x59BEDBE41933BEB6, 0xD5D328EC1AE90B22, 0x26FA194CD5A4CC9A,
  0x34790BFC50B7571E, 0xE91BC0D61C9FA3C5, 0x8FB89136550EFB06, 0x36701B34D43E30CD,
  0xAAFD6ACF34BB27C1, 0x401DD1B2B7A72AB4, 0x6F5903B64BBD50D7, 0x9067F2A3CB7EBB34,
  0x2C7807F6E28CD962, 0x42B2DB1AED17AFD5, 0xF42857186A09F927, 0x258AB4C5E9986E0C,
  0x8F8BA0BC0571B0F6, 0xCB7AC29208905214, 0x89914660AA38896A, 0x380CAC8536886A07,
  0x7B7F399C6EC9563D, 0xB9CBFBEEE95F05B1, 0x46AAAFC2159C8F19, 0xDCE680A0882BCCEF,
  0x347DDA36E42E2D99, 0x48EAF8CB224BCBB6, 0x1EACE389084B2674, 0x261BC842C735974D,
  0xF334875975FD986B, 0xF6B436CC3615018C, 0x6658B92BCD930893, 0x4B6BF5B88078852E,
  0x30461B28416207E1, 0xA2EE71D448670786, 0x0C8CD31138E8A683, 0x5FF41A78E0014DD0,
  0xA57DE5B0A848A8E0, 0x71D68A3A9600F975, 0xEBB35D1E75B69FFB, 0xFCC1D327A771464B,
  0xB6C1F45DB043CF56, 0x92EF77063313F3CE, 0x5F48E97C72B167E2, 0x5806342E75C7BB6B,
  0x056C0070CF70F8DD, 0x81AD4662EE05E75A, 0x1C10E0B05C7B3C49, 0xC684C383E396972A,
  0x35747D859FC1A7E1, 0xFDDCF0169427CEE5, 0x3952CBE313B377E2, 0xDA1B5C1E5BCCB131,
  0x10B747061AF1559C, 0x8388EDE0F8EDCBFC, 0x4873A84B8ABF0FA8, 0xB30E990FE793A807,
  0x6B8C5C09C78D0A9F, 0x7A488BC144D344AA, 0xC04C26EC10A73AE9, 0x9278CDFF5EBA539E,
  0xFF3A1C4370FB8703, 0x70D16AE16E34B5B5, 0x2732FCB913E2E5C3, 0xC59EE008F48EB1FA,
  0x38C7DB9E584C3680, 0x16F9194953701E88, 0x2E4C5FAC8051C8FD, 0x27DD41B7B5D864FA,
  0xECA6A65750A55AEA, 0x5EBECF093FF380E7, 0xAA4B94B2F0585B82, 0xC88047DA71E83C4D,
  0xB55C0550FE29B255, 0x2A1F8CB7ECEB6200, 0x7B841E8CB0945F2D, 0x6E5D5D9ED39B4961,
  0x67222624CF379C81, 0x0CC24C31A8BA7F90, 0x4B54A89AF4A4DF4C, 0x91A6E548CAC3E417,
  0x83DEB6121EA84F96, 0x9F951DD98DBB9DF5, 0x25584291FF15CB27, 0x3371E38504F0CB1F,
  0x0EB9B65B5DE9637D, 0x2D292615860C0AE9, 0x8DAFEA0E2F5DD418, 0x5E30A0DFD3A6BA54,
  0x5C442D0B47BF7364, 0x7C2EEBB8C8734B16, 0x440AF7B361B686A6, 0xBC6C2CB56CE41EDD,
  0x2DF7B73E01F1DB6C, 0xD76592C6235F3FFE, 0x2139DC845CE8D2B0, 0x42168DFAFC8BF871,
  0xB0E6598E3C707763, 0xD7C55A777BF74808, 0x04C0175493D0C6EC, 0x78B2B49BF53DD1A5,
  0xC6020A48A9F0B2CD, 0x08CA89D2EA10FEB4, 0x07DE9D1304C3B2BD, 0x769EF9C4E120BC5F,
  0xEEBD5772D344846F, 0x1E972C3F168BBF7F, 0x0C72560FAD1EC422, 0xD85B15F5DBCD19B9
};

/*
 * Computed by the function board_initialize_zobrist_flip_bitstrings().
 */
static uint64_t zobrist_flip_bitstrings[64];

static const uint64_t zobrist_masks[] =
  {
   0x0000000000000001, 0x0000000000000002, 0x0000000000000004, 0x0000000000000008,
   0x0000000000000010, 0x0000000000000020, 0x0000000000000040, 0x0000000000000080,
   0x0000000000000100, 0x0000000000000200, 0x0000000000000400, 0x0000000000000800,
   0x0000000000001000, 0x0000000000002000, 0x0000000000004000, 0x0000000000008000,
   0x0000000000010000, 0x0000000000020000, 0x0000000000040000, 0x0000000000080000,
   0x0000000000100000, 0x0000000000200000, 0x0000000000400000, 0x0000000000800000,
   0x0000000001000000, 0x0000000002000000, 0x0000000004000000, 0x0000000008000000,
   0x0000000010000000, 0x0000000020000000, 0x0000000040000000, 0x0000000080000000,
   0x0000000100000000, 0x0000000200000000, 0x0000000400000000, 0x0000000800000000,
   0x0000001000000000, 0x0000002000000000, 0x0000004000000000, 0x0000008000000000,
   0x0000010000000000, 0x0000020000000000, 0x0000040000000000, 0x0000080000000000,
   0x0000100000000000, 0x0000200000000000, 0x0000400000000000, 0x0000800000000000,
   0x0001000000000000, 0x0002000000000000, 0x0004000000000000, 0x0008000000000000,
   0x0010000000000000, 0x0020000000000000, 0x0040000000000000, 0x0080000000000000,
   0x0100000000000000, 0x0200000000000000, 0x0400000000000000, 0x0800000000000000,
   0x1000000000000000, 0x2000000000000000, 0x4000000000000000, 0x8000000000000000
  };

/**
 * @endcond
 */


/************************************/
/* Module initialization functions. */
/************************************/

/**
 * @brief Initializes required data structures used by other module's functions.
 *
 * @details This function must be called once before any use of other functions
 * contained in this module.
 *
 * @callergraph
 */
void
board_module_init (void)
{
  /* This should be moved in the main function. Be careful, that valgrind doesn't detect properly AVX2. */
  if (false & !arch_runtime_is_supported()) {
    printf("The underline architecture, meaning HW and OS, is not supporting the requested features.\n");
    abort();
  }
  board_initialize_zobrist_flip_bitstrings();
}



/***************************************************/
/* Function implementations for the Square entity. */
/***************************************************/

/**
 * @brief Returns a string representation for the sqare.
 *
 * @details The returned string cannot be changed and must not be deallocated.
 * When the `sq` parameter is not part of the set defined by the enum `Square`
 * the returned value is `"NA"`.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_to_string usage
 *
 * @param [in] sq the square to be converted
 * @return        a string of two chars representing the square
 */
const char *
square_to_string (const Square sq)
{
  if (square_belongs_to_enum_set(sq)) {
    return sq_to_s[sq];
  } else {
    return sq_to_s[65]; // sq_to_s[65] is "NA"
  }
}

/**
 * @brief Returns a string representation for the move.
 *
 * @details The returned string cannot be changed and must not be deallocated.
 * When the `move` parameter  is equal to #pass_move the returned value is `"--"`,
 * otherwise the returned value is consistent with the function #square_to_string.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_as_move_to_string usage
 *
 * @param [in] move the move to be converted
 * @return          a string of two chars representing the move
 */
const char *
square_as_move_to_string (const Square move)
{
  if (move == unknown_move) {
    return sq_to_s[66]; // sq_to_s[66] is "UN"
  } else if (move == invalid_move) {
    return sq_to_s[65]; // sq_to_s[64] is "NA"
  } else if (move == pass_move) {
    return sq_to_s[64]; // sq_to_s[64] is "--"
  } else {
    return square_to_string(move);
  }
}

/**
 * @brief Prepares a string that represents the square array.
 *
 * @details The `to_string` buffer needs to have enough space to
 * accomodate the generated string. At a minimum termination is
 * needed for the empy string (one byte) when the array is empty.
 * Otherwise three bytes for each element in the array are needed.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_array_to_string usage
 * A sample call is here exemplified:
 *
 * @param [out] to_string a string representation for the square array
 * @param [in]  sqa       the square array to convert
 * @param [in]  length    the count of elements in the array
 * @return                the length of the string
 */
size_t
square_array_to_string (char *const to_string,
                        const Square sqa[],
                        const int length)
{
  char *c = to_string;
  *c = 0;
  for (int i = 0; i < length; i++) {
    c += sprintf(c, "%s", square_to_string(sqa[i]));
    if (length - i > 1) c += sprintf(c, " ");
  }
  return c - to_string;
}

/**
 * @brief Prepares a string that represents the move array.
 *
 * @details The `to_string` buffer needs to have enough space to
 * accomodate the generated string. At a minimum termination is
 * needed for the empy string (one byte) when the array is empty.
 * Otherwise three bytes for each element in the array are needed.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_as_move_array_to_string usage
 *
 * @param [out] to_string a string representation for the move array
 * @param [in]  mova      the move array to convert
 * @param [in]  length    the count of elements in the array
 * @return                the length of the string
 */
size_t
square_as_move_array_to_string (char *const to_string,
                                const Square mova[],
                                const int length)
{
  char *c = to_string;
  *c = 0;
  for (int i = 0; i < length; i++) {
    c += sprintf(c, "%s", square_as_move_to_string(mova[i]));
    if (length - i > 1) c += sprintf(c, " ");
  }
  return c - to_string;
}

/**
 * @brief Returns TRUE if the `sq` parameter is in the valid range.
 *
 * @details The valid range is `[0,63]`, as defined by the `Square` enum.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_belongs_to_enum_set usage
 *
 * @param [in] sq the given square
 * @return        true if the square is in the valid range
 */
bool
square_belongs_to_enum_set (const Square sq)
{
  return sq >= A1 && sq <= H8;
}


/**
 * @brief Returns TRUE if the `move` parameter is in the valid range.
 *
 * @details The valid range is `[-1,63]`, where `-1` means move_pass,
 * and values from `0` to `63` are defined by the `Square` enum.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_is_valid_move usage
 *
 * @param [in] move the given move
 * @return          true if the move is in the valid range
 */
bool
square_is_valid_move (const Square move)
{
  return square_belongs_to_enum_set(move) || move == pass_move;
}



/******************************************************/
/* Function implementations for the SquareSet entity. */
/******************************************************/

/**
 * @brief Prepares a string representation for the square set.
 *
 * @details The character buffer pointed by `to_string` must have the
 * apppropriate space. The needed space is three char for each square
 * in the set, when the set is full the buffer must have 292 + 1 (for
 * termination) bytes of space. The minimum is one byte, when the set
 * is empty.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_set_to_string usage
 *
 * @param [out] to_string a string having the given squares sorted as the `Square` enum
 * @param [in]  squares   the square set to be converted into a string
 * @return                the number of characters in the returned string
 */
size_t
square_set_to_string (char *const to_string,
                      const SquareSet squares)
{
  char *c = to_string;
  *c = 0;
  Square m = A1;
  bool is_not_first = false;
  for (SquareSet cursor = 1; cursor != 0; cursor <<= 1, m++) {
    if ((cursor & squares) != empty_square_set) {
      const char row = '1' + (m / 8);
      const char col = 'A' + (m % 8);
      if (is_not_first) {
        c += sprintf(c, " ");
      }
      c += sprintf(c, "%c%c", col, row);
      is_not_first = true;
    }
  }
  return c - to_string;
}

/**
 * @brief Prepares a formatted string showing a 2d graphical represention of the square set.
 *
 * @details The `to_string` buffer needs to have enough space to
 * accomodate the generated string. The size of the buffer must be larger
 * than 212 bytes.
 *
 * @invariant Parameter `to_string` must be not `NULL`.
 * The invariant is guarded by an assertion.
 *
 * @param [out] to_string a string being a 2d representation of the square set
 * @param [in]  s         the square set
 * @return                the length of the string
 */
size_t
square_set_print (char *const to_string,
                  const SquareSet s)
{
  assert(to_string);

  char *c = to_string;
  *c = 0;
  c += sprintf(c, "    a b c d e f g h ");
  for (int row = 0; row < 8; row++) {
    c += sprintf(c, "\n %1d  ", row + 1);
    for (int col = 0; col < 8; col++) {
      bool is_filled = ((1ULL << (8 * row + col)) & s) != 0ULL;
      c += sprintf(c, "%c ", is_filled ? '1' : '.');
    }
  }
  c += sprintf(c, "\n");
  return c - to_string;
}


/**
 * @brief Returns a random square among the given set.
 *
 * @invariant Parameter `prng` must not be null.
 * The invariant is guarded by an assertion.
 *
 * @invariant Parameter `squares` must not be empty.
 * The invariant is guarded by an assertion.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_set_random_selection usage
 *
 * @param [in,out] prng the random number generator instance
 * @param [in]          squares a square set
 * @return              one square selected among the set
 */
Square
square_set_random_selection (prng_mt19937_t *const prng,
                             const SquareSet squares)
{
  assert(prng);
  assert(squares != empty_square_set);
  SquareSet s = squares;
  const uint8_t square_count = bitw_bit_count_64(squares);
  const uint8_t square_index = prng_mt19937_random_choice_from_finite_set(prng, square_count);
  for (uint8_t i = 0; i < square_count; i++) {
    if (i == square_index) break;
    s ^= bitw_lowest_set_bit_64(s);
  }
  return (Square) bitw_bit_scan_forward_64(s);
}

/**
 * @brief Transforms the square set into an array.
 *
 * @details The array size, equal to the number of squares held in the set, is
 * returned into the value pointed by the `sq_count` parameter.
 * The array is dynamically allocated by the function, squares are returned
 * manteining the `Square` enum natural order.
 * The `sq_array` parameter is a pointer to the allocated array.
 *
 * The returned array has to be freed by the caller.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_set_to_array usage
 *
 * @param [out] sq_count the size of the returned array
 * @param [out] sq_array a pointer to the allocated new array
 * @param [in]  squares  a square set
 */
void
square_set_to_array (int *sq_count,
                     Square **sq_array,
                     const SquareSet squares)
{
  static const size_t size_of_square = sizeof(Square);
  const uint8_t square_count = bitw_bit_count_64(squares);
  Square *array = (Square *) malloc(square_count * size_of_square);
  assert(array);
  SquareSet s = squares;
  for (int i = 0; i < square_count; i++) {
    const Square sq = bitw_bit_scan_forward_64(s);
    *(array + i) = sq;
    s ^= (SquareSet) 1 << sq;
  }
  *sq_count = square_count;
  *sq_array = array;
}

/**
 * @brief Transform the array of squares into a square set.
 *
 * @invariant Parameter `sq_array` must be composed of elements belonging to the `Squae` enum.
 * The invariant is guarded by an assertion.
 *
 * @invariant Parameter `sq_count` must be not negative.
 * The invariant is guarded by an assertion.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c square_set_from_array usage
 *
 * @param sq_array the array to be converted
 * @param sq_count the number of squares in the array
 * @return         the resulting square set
 */
SquareSet
square_set_from_array (const Square sq_array[],
                       const int sq_count)
{
  assert(sq_count >= 0);
  SquareSet squares = 0;
  for (int i = 0; i < sq_count; i++) {
    const Square sq = sq_array[i];
    assert(square_belongs_to_enum_set(sq));
    squares |= (SquareSet) 1 << sq;
  }
  return squares;
}

/***************************************************/
/* Function implementations for the Player entity. */
/***************************************************/

/**
 * @brief Returns the square state value representing the player's color.
 *
 * @invariant Parameter `p` must have a value belonging to the `Player` enum.
 * The invariant is guarded by an assertion.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c player_color usage
 *
 * @param [in] p the player
 * @return       the square state of the player
 */
SquareState
player_color (const Player p)
{
  assert(p == BLACK_PLAYER || p == WHITE_PLAYER);
  return (p == BLACK_PLAYER) ? BLACK_SQUARE : WHITE_SQUARE;
}

/**
 * @brief Returns the player's description.
 *
 * @invariant Parameter `p` must have a value belonging to the `Player` enum.
 * The invariant is guarded by an assertion.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c player_description usage
 *
 * @param [in] p the player
 * @return       the player's description
 */
char *
player_description (const Player p)
{
  assert(p == BLACK_PLAYER || p == WHITE_PLAYER);
  return (p == BLACK_PLAYER) ? "The Black player" : "The White player";
}

/**
 * @brief Returns the player's opponent.
 *
 * @invariant Parameter `p` must have a value belonging to the `Player` enum.
 * The invariant is guarded by an assertion.
 *
 * A sample usage scenario taken from unit tests is here exemplified:
 *
 * @snippet ut_board.c player_opponent usage
 *
 * @param [in] p the player
 * @return       the player's opponent
 */
Player
player_opponent (const Player p)
{
  assert(p == BLACK_PLAYER || p == WHITE_PLAYER);
  return 1 - p;
}



/********************************************************/
/* Function implementations for the SquareState entity. */
/********************************************************/

/**
 * @brief Returns the #SquareState printable representation.
 *
 * @invariant Parameter `color` must belong to the #SquareState enum.
 * The invariant is guarded by an assertion.
 *
 * @param [in] color the given color
 * @return           the color's `symbol`
 */
char
square_state_symbol (const SquareState color)
{
  assert(color >= EMPTY_SQUARE && color <= WHITE_SQUARE);

  switch (color) {
  case EMPTY_SQUARE: return '.';
  case BLACK_SQUARE: return '@';
  case WHITE_SQUARE: return 'O';
  default: abort();
  }
}



/**********************************************************/
/* Function implementations for the GamePositionX entity. */
/**********************************************************/

/**
 * @brief Game position x structure constructor.
 *
 * An assertion checks that the received pointer to the allocated
 * game position x structure is not `NULL`.
 *
 * @invariant Parameters `b` and `w` cannot have common square set.
 * The invariant is guarded by an assertion.
 * It means that a square cannot have a white and a black disc set together.
 *
 * @param [in] b the set of black squares
 * @param [in] w the set of white squares
 * @param [in] p the player having to move
 * @return       a pointer to a new game position x structure
 */
GamePositionX *
game_position_x_new (const SquareSet b,
                     const SquareSet w,
                     const Player p)
{
  assert((w & b) == empty_square_set);

  GamePositionX *gpx;
  static const size_t size_of_game_position_x = sizeof(GamePositionX);

  gpx = (GamePositionX *) malloc(size_of_game_position_x);
  assert(gpx);

  gpx->blacks = b;
  gpx->whites = w;
  gpx->player = p;

  return gpx;
}

/**
 * @brief Deallocates the memory previously allocated by a call to #game_position_x_new.
 *
 * @details If a null pointer is passed as argument, no action occurs.
 *
 * @param [in,out] gpx the pointer to be deallocated
 */
void
game_position_x_free (GamePositionX *gpx)
{
  free(gpx);
}

/**
 * @brief Clones a `GamePositionX` structure.
 *
 * @invariant Parameter `gpx` cannot be null.
 * The invariant is guarded by an assertion.
 *
 * @param [in] gpx the game position x to clone
 * @return         a pointer to a new game position structure
 */
GamePositionX *
game_position_x_clone (const GamePositionX *const gpx)
{
  assert(gpx);

  return game_position_x_new(gpx->blacks,
                             gpx->whites,
                             gpx->player);
}

/**
 * @brief Copies a `GamePositionX` structure.
 *
 * @param [in]  from the game position x to copy from
 * @param [out] to   the game position x to copy to
 */
void
game_position_x_copy (const GamePositionX *const from,
                      GamePositionX *const to)
{
  to->blacks = from->blacks;
  to->whites = from->whites;
  to->player = from->player;
}

/**
 * @brief Updates game position x `next` by passing the move from `current`.
 *
 * The function doesn't check that the current player has to pass.
 *
 * @param [in]  current the current game position x
 * @param [out] next    the updated game position x after passing
 */
extern void
game_position_x_pass (const GamePositionX *const current,
                      GamePositionX *const next);

/**
 * @brief Returns the hash value for the game position x.
 *
 * The hash is computed by mean of a zobrist technique.
 *
 * @param [in] gpx the current game position
 * @return         the hash value for the game position
 */
uint64_t
game_position_x_hash (const GamePositionX *const gpx)
{
#ifdef __AVX2__
  return game_position_x_hash_vec(gpx);
#else
  return game_position_x_hash_plain(gpx);
#endif
}

uint64_t
game_position_x_hash_plain (const GamePositionX *const gpx)
{
  const SquareSet whites = gpx->whites;
  const SquareSet blacks = gpx->blacks;
  const Player p = gpx->player;

  uint64_t hash = 0;

  for (int i = 0; i < 64; i++) {
    const uint64_t mask = (uint64_t) 1 << i;
    if (blacks & mask) hash ^= zobrist_bitstrings[i];
    if (whites & mask) hash ^= zobrist_bitstrings[i + 64];
  }
  if (p) hash = ~hash; /* In this way passing doesn't require a full new hash. */

  return hash;
}

uint64_t
game_position_x_hash_vec (const GamePositionX *const gpx)
{
  __m256i m, zow, zob, x, x1;

  const SquareSet blacks = gpx->blacks;
  const SquareSet whites = gpx->whites;
  const Player p = gpx->player;

  __m256i const *zobi = (__m256i const *) zobrist_bitstrings;
  __m256i const *zoma = (__m256i const *) zobrist_masks;

  const __m256i b = _mm256_set1_epi64x(blacks);
  const __m256i w = _mm256_set1_epi64x(whites);
  const __m256i z = _mm256_set1_epi64x(0);
  const __m256i s = _mm256_set1_epi64x(0x7FFFFFFFFFFFFFFF);

  __m256i h = _mm256_set1_epi64x(0);

  for (int i = 0; i < 16; i++) {
    m    = _mm256_loadu_si256(zoma);
    zob  = _mm256_loadu_si256(zobi);
    zow  = _mm256_loadu_si256(zobi + 16);

    x  = _mm256_and_si256(b, m);
    x1 = _mm256_srli_epi64 (x, 1);
    x  = _mm256_and_si256(x, s);
    x  = _mm256_or_si256(x, x1);
    x  = _mm256_cmpgt_epi64(x, z);
    x  = _mm256_and_si256(x, zob);
    h  = _mm256_xor_si256(h, x);

    x  = _mm256_and_si256(w, m);
    x1 = _mm256_srli_epi64 (x, 1);
    x  = _mm256_and_si256(x, s);
    x  = _mm256_or_si256(x, x1);
    x  = _mm256_cmpgt_epi64(x, z);
    x  = _mm256_and_si256(x, zow);
    h  = _mm256_xor_si256(h, x);

    zoma++;
    zobi++;
  }

  const uint64_t h0 = _mm256_extract_epi64(h, 0);
  const uint64_t h1 = _mm256_extract_epi64(h, 1);
  const uint64_t h2 = _mm256_extract_epi64(h, 2);
  const uint64_t h3 = _mm256_extract_epi64(h, 3);

  uint64_t hash = h0 ^ h1 ^ h2 ^ h3;
  if (p) hash = ~hash; /* In this way passing doesn't require a full new hash. */

  return hash;
}

/**
 * @brief computes the delta hash, and returns the new one.
 *
 * The first entry in flips must be the move.
 *
 * @param [in] old_hash   the hash of the parent game position
 * @param [in] flips      the move and the disks flipped
 * @param [in] flip_count number of disk flipped including the move
 * @param [in] new_p      the player of the new (child) game position
 * @return                the hash value for the child game position
 */
uint64_t
game_position_x_delta_hash (const uint64_t old_hash,
                            const Square *const flips,
                            const int flip_count,
                            const Player new_p)
{
  const Square move = *flips;
  if (move == pass_move) return ~old_hash;

  const int index = move + 64 * (1 - new_p);

  SquareSet new_hash = old_hash ^ zobrist_bitstrings[index];

  for (int i = 1; i < flip_count; i++) {
    new_hash ^= zobrist_flip_bitstrings[flips[i]];
  }

  return ~new_hash;
}

void
game_position_x_deltas (const GamePositionX *const parent,
                        const GamePositionX *const child,
                        Square *flips,
                        int *flip_count)
{
  GamePositionX updated;

  if (parent->blacks == child->blacks) {
    flips[0] = pass_move;
    *flip_count = 1;
  } else {
    const SquareSet move_set = (child->blacks | child->whites) & (~(parent->blacks | parent->whites));
    const SquareSet black_flip_set = child->blacks & (~(parent->blacks | move_set));
    const SquareSet white_flip_set = child->whites & (~(parent->whites | move_set));
    if (parent->player == BLACK_PLAYER) assert(white_flip_set == 0 && black_flip_set != 0);
    if (parent->player == WHITE_PLAYER) assert(black_flip_set == 0 && white_flip_set != 0);
    SquareSet flip_set = black_flip_set | white_flip_set;
    int fc = bitw_bit_count_64(flip_set);
    const Square move = bitw_bit_scan_forward_64(move_set);
    game_position_x_make_move (parent, move, &updated);
    flips[0] = move;
    *flip_count = 1 + fc;
    for (int i = 0; i < fc; i++) {
      const Square flip = bitw_bit_scan_forward_64(flip_set);
      flips[1 + i] = flip;
      flip_set = bitw_reset_lowest_set_bit_64(flip_set);
    }
  }
  return;
}

/**
 * @brief Returns the set of empty squares in the game position.
 *
 * @param [in] gpx a pointer to the game position structure
 * @return         the set of empty squares
 */
SquareSet
game_position_x_empties (const GamePositionX *const gpx)
{
  return ~(gpx->blacks | gpx->whites);
}

/**
 * @brief Returns the moving player.
 *
 * @param [in] gpx a pointer to the game position structure
 * @return         the given player
 */
extern Player
game_position_x_get_player (const GamePositionX *const gpx);

/**
 * @brief Returns the square set belonging to the moving player.
 *
 * @param [in] gpx a pointer to the game position structure
 * @return         the set of squares in the board belonging to the given player
 */
extern SquareSet
game_position_x_get_mover (const GamePositionX *const gpx);

/**
 * @brief Returns the square set belonging to the opponent player.
 *
 * @param [in] gpx a pointer to the game position structure
 * @return         the set of squares in the board belonging to the opponent
 */
extern SquareSet
game_position_x_get_opponent (const GamePositionX *const gpx);

/**
 * @brief Returns the SquareState value for the given game position's square.
 *
 * @invariant Parameter `gpx` must be not `NULL`.
 * Parameter `sq` must belongs to the `Square` enum.
 * Invariants are both guarded by assetions.
 *
 * @param [in] gpx a pointer to the board structure
 * @param [in] sq  the square to query for
 * @return         the color of the given square
 */
SquareState
game_position_x_get_square (const GamePositionX *const gpx,
                            const Square sq)
{
  assert(gpx);
  assert(square_belongs_to_enum_set(sq));

  const SquareSet bitsquare = (SquareSet) 1 << sq;
  if (bitsquare & gpx->blacks)
    return BLACK_SQUARE;
  else if (bitsquare & gpx->whites)
    return WHITE_SQUARE;
  else
    return EMPTY_SQUARE;
}

/**
 * @brief Returns a set of squares that represents the legal moves for the game position.
 *
 * @param [in] gpx the given game position
 * @return         a square set holding the legal moves
 */
SquareSet
game_position_x_legal_moves (const GamePositionX *const gpx)
{
  const SquareSet e_set = game_position_x_empties(gpx);
  if (!e_set) return empty_square_set;
  const SquareSet m_set = game_position_x_get_mover(gpx);
  const SquareSet o_set = game_position_x_get_opponent(gpx);

  SquareSet result;

#ifdef KOST
    result = kost_lms(m_set, o_set, e_set);
#else
    result = kogge_stone_b(m_set, o_set, e_set);
#endif

  return result;
}

/**
 * @brief Returns the disk difference between the player and her opponent.
 *
 * @param [in] gpx the given game position
 * @return         the disc count difference
 */
int
game_position_x_count_difference (const GamePositionX *const gpx)
{
  const int square_difference = bitw_bit_count_64(gpx->blacks) - bitw_bit_count_64(gpx->whites);
  return (gpx->player == BLACK_PLAYER) ? square_difference : - square_difference;
}

/**
 * @brief Computes the string representation of the game position.
 *
 * @details The function overwrites sixty six chars starting from the position
 * identified by the `out` pointer.
 *
 * A sample call is here exemplified:
 *
 * @code
 * GamePositionX *gpx;
 * char gpx_to_string[66];
 *
 * gpx = game_position_x_new(0x00000000000000FF,
 *                           0xFF0000000000FF00,
 *                           WHITE_PLAYER);
 *
 * game_position_x_to_string(gpx, gpx_to_string);
 *
 * assert(g_strcmp0("bbbbbbbbwwwwwwww........................................wwwwwwwww", gpx_to_string) == 0);
 * @endcode
 *
 * @invariant Parameters `gpx` and `out` must be not `NULL`.
 * The invariants are guarded by assertions.
 * Moreover it is responsibility of the caller to garantee that the `out`
 * pointer refers to a `char` vector that has `66` positions or more.
 *
 * @param [in]  gpx the given game position
 * @param [out] out the string written by the function
 */
void
game_position_x_to_string (const GamePositionX *gpx,
                           char *out)
{
  assert(gpx);
  assert(out);

  for (int pos = 0; pos < 64; pos++) {
    const SquareSet sq = (SquareSet) 1 << pos;
    char color = '.';
    if (sq & gpx->blacks) {
      color = 'b';
    } else if (sq & gpx->whites) {
      color = 'w';
    }
    *out++ = color;
  }
  *out++ = (gpx->player == BLACK_PLAYER) ? 'b' : 'w';
  *out = '\0';
}

/**
 * @brief Compares game positions `a` and `b`.
 *
 * When the two game position are equal it returns `0`, when `a` is greather then `b` it
 * returns `+1`, otherwise `-1`.
 *
 * Game positions are equals when have the same board and player.
 *
 * @invariant Parameters `a` and `b` must be not `NULL`.
 * Invariants are guarded by assertions.
 *
 * @param [in] a a pointer to a game position x structure
 * @param [in] b a pointer to a second structure
 * @return       `-1` when `a < b`, `+1` when `a > b`, or `0` when the two game position are equal
 */
int
game_position_x_compare (const GamePositionX *const a,
                         const GamePositionX *const b)
{
  assert(a);
  assert(b);

  if (a == b) return 0;

  if (a->blacks < b->blacks) {
    return -1;
  } else if (a->blacks > b->blacks) {
    return +1;
  } else {          /* Blacks are equal. */
    if (a->whites < b->whites) {
      return -1;
    } else if (a->whites > b->whites) {
      return +1;
    } else {        /* Also whites are equal. */
      if (a->player < b->player) {
        return -1;
      } else if (a->player > b->player) {
        return +1;
      } else {
        return 0;   /* Players are equal, and so are a and b. */
      }
    }
  }
}

/**
 * @brief Used for the score at the end of the game.
 *
 * @details Returns the disk difference between the player and her opponent,
 * assigning the empty squares to the player having most discs.
 *
 * From the web site of the World Othello Federation,
 * World Othello Chanpionship Rules, scoring:<br>
 * <em>"At the end of the game, if both players have completed their moves in
 * the allowed time, the winner is the player with the greater number of
 * discs of his colour on the board at the end. The official score of the
 * game will be determined by counting up the discs of each colour on the
 * board, counting empty squares for the winner. In the event of a draw,
 * the score will always be 32-32"</em>.
 *
 * @param [in] gpx a pointer to the game position x structure
 * @return         the game score according to the WOF rules
 */
extern int
game_position_x_final_value (const GamePositionX *const gpx);

/**
 * @brief Prepares a formatted string showing a 2d graphical represention of the game position x.
 *
 * @details The `to_string` buffer needs to have enough space to
 * accomodate the generated string. The size of the buffer must be larger
 * than 212 bytes.
 *
 * @invariant Parameter `to_string` must be not `NULL`.
 * The invariant is guarded by an assertion.
 *
 * @invariant Parameter `gpx` must be not `NULL`.
 * The invariant is guarded by an assertion.
 *
 * @param [out] to_string a string being a 2d representation of the game position
 * @param [in]  gpx       a pointer to the game position x structure
 * @return                the length of the string
 */
size_t
game_position_x_print (char *const to_string,
                       const GamePositionX *const gpx)
{
  assert(to_string);
  assert(gpx);

  char *c = to_string;
  *c = 0;
  c += sprintf(c, "    a b c d e f g h ");
  for (int row = 0; row < 8; row++) {
    c += sprintf(c, "\n %1d  ", row + 1);
    for (int col = 0; col < 8; col++) {
      c += sprintf(c, "%c ", square_state_symbol(game_position_x_get_square(gpx, (8 * row) + col)));
    }
  }
  c += sprintf(c, "\nPlayer to move: %s\n", (gpx->player == BLACK_PLAYER) ? "BLACK" : "WHITE");
  return c - to_string;
}

/**
 * @brief Returns if the game state admit one or more legal moves.
 *
 * @invariant Parameter `gpx` must be not `NULL`.
 * Invariants are guarded by assertions.
 *
 * @param [in] gpx the given game position x
 * @return         true if the game state admit a legal move
 */
bool
game_position_x_has_any_legal_move (const GamePositionX *const gpx)
{
  assert(gpx);

  return (empty_square_set == game_position_x_legal_moves(gpx)) ? false : true;
}

/**
 * @brief Returns `TRUE` if the game position x is not final.
 *
 * @invariant Parameter `gpx` must be not `NULL`.
 * All invariants are guarded by assertions.
 *
 * @param [in] gpx the given game position x
 * @return         true if one of the player has one or more legal moves
 */
bool
game_position_x_has_any_player_any_legal_move (const GamePositionX *const gpx)
{
  assert(gpx);

  GamePositionX pass;

  if (game_position_x_legal_moves(gpx)) return true;
  game_position_x_pass(gpx, &pass);
  if (game_position_x_legal_moves(&pass)) return true;
  return false;
}

/**
 * @brief Returns true if the `move` is legal for the game position x.
 *
 * @invariant Parameter `gpx` must be not `NULL`.
 * Parameter `move` must be a value in the range defined by
 * the #square_is_valid_move function.
 * Invariants are guarded by assertions.
 *
 * @param [in] gpx  the given game position x
 * @param [in] move the square where to put the new disk
 * @return          true if the move is legal
 */
bool
game_position_x_is_move_legal (const GamePositionX *const gpx,
                               const Square move)
{
  assert(gpx);
  assert(square_is_valid_move(move));

  bool result = false;

  if (move == pass_move) {
    if (game_position_x_empties(gpx) == empty_square_set) {
      return true;
    } else if (game_position_x_legal_moves(gpx) == empty_square_set) {
      return true;
    } else {
      return false;
    }
  } else {
    const SquareSet bit_move = (SquareSet) 1 << move;
    const SquareSet legal_moves = game_position_x_legal_moves(gpx);
    result = legal_moves & bit_move;
  }

  return result;
}

/**
 * @brief Executes a game move.
 *
 * @details The moving player places a disc in the square identified by the `move` parameter.
 *          The `current` position is unchanged, the new position is assigned to the structure
 *          pointed by the `updated` parameter.
 *
 * @invariant Parameter `current` must be not `NULL`.
 * Parameter `updated` must be not `NULL`.
 * Parameter `move` must be a value in the range defined by
 * the #square_is_valid_move function.
 * Parameter `move` must be legal.
 * Invariants are guarded by assertions.
 *
 * @param [in]  current the given game position x
 * @param [in]  move    the square where to put the new disk
 * @param [out] updated the updated game position x as a result of the move
 */
void
game_position_x_make_move (const GamePositionX *const current,
                           const Square move,
                           GamePositionX *const updated)
{
  assert(current);
  assert(updated);
  assert(square_is_valid_move(move));
  assert(game_position_x_is_move_legal(current, move));

  if (move == pass_move) {
    game_position_x_pass(current, updated);
    return;
  }

  const Player p = current->player;
  const Player o = player_opponent(p);

  const SquareSet m_set = 1ULL << move;
  const SquareSet p_set = game_position_x_get_mover(current);
  const SquareSet o_set = game_position_x_get_opponent(current);

  const SquareSet f_set = kogge_stone_gpb(m_set, o_set, p_set);

  const SquareSet p_set_n = p_set |  f_set;
  const SquareSet o_set_n = o_set & ~f_set;

  if (o) {
    updated->blacks = p_set_n;
    updated->whites = o_set_n;
  } else {
    updated->blacks = o_set_n;
    updated->whites = p_set_n;
  }
  updated->player = o;

  return;
}

void
game_position_x_make_move_delta_hash (const GamePositionX *const current,
                                      const Square move,
                                      GamePositionX *const updated,
                                      uint64_t hash,
                                      uint64_t *updated_hash)
{
  assert(current);
  assert(updated);
  assert(square_is_valid_move(move));
  assert(game_position_x_is_move_legal(current, move));

  if (move == pass_move) {
    game_position_x_pass(current, updated);
    *updated_hash = ~hash;
    return;
  }

  const Player p = current->player;
  const Player o = player_opponent(p);

  const SquareSet m_set = 1ULL << move;
  const SquareSet p_set = game_position_x_get_mover(current);
  const SquareSet o_set = game_position_x_get_opponent(current);

  const SquareSet f_set = kogge_stone_gpb(m_set, o_set, p_set);

  const SquareSet p_set_n = p_set |  f_set;
  const SquareSet o_set_n = o_set & ~f_set;

  if (o) {
    updated->blacks = p_set_n;
    updated->whites = o_set_n;
  } else {
    updated->blacks = o_set_n;
    updated->whites = p_set_n;
  }
  updated->player = o;

  register uint64_t uhash = hash;

  const int index = move + 64 * (1 - o);
  uhash ^= zobrist_bitstrings[index];

  SquareSet h_set = f_set & ~(m_set | p_set);
  while (h_set) {
    const uint8_t flip = bitw_tzcnt_64(h_set);
    h_set = bitw_reset_lowest_set_bit_64(h_set);
    uhash ^= zobrist_flip_bitstrings[flip];
  }
  uhash = ~uhash;

  *updated_hash = uhash;

  return;
}

void
game_position_x_set_initial_position (GamePositionX *const gpx)
{
  assert(gpx);

  gpx->blacks = 0x0000000810000000;
  gpx->whites = 0x0000001008000000;
  gpx->player = BLACK_PLAYER;
}

int
game_position_x_empty_count (const GamePositionX *const gpx)
{
  assert(gpx);
  const SquareSet empties = game_position_x_empties(gpx);
  const uint8_t square_count = bitw_bit_count_64(empties);
  return square_count;
}



/**
 * @cond
 */

/*
 * Internal functions.
 */

/*
 *
 */
static void
board_initialize_zobrist_flip_bitstrings (void)
{
  for (int i = 0; i < 64; i++) {
    zobrist_flip_bitstrings[i] = zobrist_bitstrings[i] ^ zobrist_bitstrings[i + 64];
  }
}

/*
 * See Wikipedia page https://en.wikipedia.org/wiki/Kogge-Stone_adder
 *
 * This variant of the Kogge-Stone algorithm takes three bitboard as imput:
 *
 *  - generator
 *  - propagator
 *  - blocker
 *
 * and returns the bitboard obtained by the blocker subset that is formed by
 * the blockers hit by the rays, in the eight directions, obtained from the generators
 * traveling along the propagators.
 *
 * Passing as generator the player square set, as propagator the opponent square set,
 * and as blocker the empty square set, the returned value is a square set of the
 * legal moves.
 *
 */
__attribute__ ((unused))
static SquareSet
kogge_stone_b (const SquareSet generator,
               const SquareSet propagator,
               const SquareSet blocker)
{
  SquareSet g, p, result;

  const SquareSet mask[] = { all_squares_except_column_a,
                             all_squares_except_column_h,
                             all_squares,
                             all_squares_except_column_a,
                             all_squares_except_column_h,
                             all_squares_except_column_a,
                             all_squares,
                             all_squares_except_column_h };

  const SquareSet slide_up_1[] = { 1,  7,  8,  9,  0,  0,  0,  0 };
  const SquareSet slide_dw_1[] = { 0,  0,  0,  0,  1,  7,  8,  9 };
  const SquareSet slide_up_2[] = { 2, 14, 16, 18,  0,  0,  0,  0 };
  const SquareSet slide_dw_2[] = { 0,  0,  0,  0,  2, 14, 16, 18 };
  const SquareSet slide_up_4[] = { 4, 28, 32, 36,  0,  0,  0,  0 };
  const SquareSet slide_dw_4[] = { 0,  0,  0,  0,  4, 28, 32, 36 };

  result = 0ULL;

  for (int i = 0; i < 8; i++) {
    g = generator;
    p = propagator & mask[i];

    g |= p & ((g << slide_up_1[i]) >> slide_dw_1[i]);
    p &=     ((p << slide_up_1[i]) >> slide_dw_1[i]);

    g |= p & ((g << slide_up_2[i]) >> slide_dw_2[i]);
    p &=     ((p << slide_up_2[i]) >> slide_dw_2[i]);

    g |= p & ((g << slide_up_4[i]) >> slide_dw_4[i]);

    g = ~generator & g;
    g = blocker & mask[i] & ((g << slide_up_1[i]) >> slide_dw_1[i]);

    result |= g;
  }

  return result;
}

/*
 * See Wikipedia page https://en.wikipedia.org/wiki/Kogge-Stone_adder
 *
 * This variant of the Kogge-Stone algorithm takes three bitboard as imput:
 *
 *  - generator
 *  - propagator
 *  - blocker
 *
 * and returns the bitboard obtained by summing up:
 *
 *  - the generators;
 *  - the rays, in the eight directions, obtained from the generators
 *    traveling along the propagators, hitting a blocker;
 *  - the hit blockers.
 *
 * Passing as generator the bitboard having a single square, the move,
 * as propagator the opponent square set, and as blocker the player square
 * set, the returned value is a square set that:
 *
 *  - added to the player square set
 *  - subtracted from the opponent square set
 *
 * enables the computation of the new game position obtained by moving.
 *
 */
static SquareSet
kogge_stone_gpb (const SquareSet generator,
                 const SquareSet propagator,
                 const SquareSet blocker)
{
  SquareSet const_b0[4], const_b1[4];
  SquareSet pro_base0[4], pro_base1[4];
  SquareSet g0, g1, p0, p1, accumulator;

  const SquareSet const_a0[] = { all_squares_except_column_a,
                                 all_squares_except_column_h,
                                 all_squares,
                                 all_squares_except_column_a };
  const SquareSet const_a1[] = { all_squares_except_column_h,
                                 all_squares_except_column_a,
                                 all_squares,
                                 all_squares_except_column_h };

  const SquareSet const_sh_a[] = { 1,  7,  8,  9 };
  const SquareSet const_sh_b[] = { 2, 14, 16, 18 };
  const SquareSet const_sh_c[] = { 4, 28, 32, 36 };

  accumulator = 0ULL;

  for (int i = 0; i < 4; i++) {
    const_b0[i] = blocker & const_a0[i];
    const_b1[i] = blocker & const_a1[i];

    pro_base0[i] = propagator & const_a0[i];
    pro_base1[i] = propagator & const_a1[i];

    g0 = generator;
    g1 = generator;
    p0 = pro_base0[i];
    p1 = pro_base1[i];

    g0 |= p0 & (g0 << const_sh_a[i]);
    g1 |= p1 & (g1 >> const_sh_a[i]);
    p0 &=      (p0 << const_sh_a[i]);
    p1 &=      (p1 >> const_sh_a[i]);

    g0 |= p0 & (g0 << const_sh_b[i]);
    g1 |= p1 & (g1 >> const_sh_b[i]);
    p0 &=      (p0 << const_sh_b[i]);
    p1 &=      (p1 >> const_sh_b[i]);

    g0 |= p0 & (g0 << const_sh_c[i]);
    g1 |= p1 & (g1 >> const_sh_c[i]);

    g0 = ~generator & g0;
    g1 = ~generator & g1;

    g0 = const_b0[i] & (g0 << const_sh_a[i]);
    g1 = const_b1[i] & (g1 >> const_sh_a[i]);

    p0 = pro_base0[i];
    p1 = pro_base1[i];

    g0 |= p0 & (g0 >> const_sh_a[i]);
    g1 |= p1 & (g1 << const_sh_a[i]);
    p0 &=      (p0 >> const_sh_a[i]);
    p1 &=      (p1 << const_sh_a[i]);

    g0 |= p0 & (g0 >> const_sh_b[i]);
    g1 |= p1 & (g1 << const_sh_b[i]);
    p0 &=      (p0 >> const_sh_b[i]);
    p1 &=      (p1 << const_sh_b[i]);

    g0 |= p0 & (g0 >> const_sh_c[i]);
    g1 |= p1 & (g1 << const_sh_c[i]);

    accumulator |= (g0 | g1);
  }

  return accumulator | generator;
}



/**
 * @endcond
 */
