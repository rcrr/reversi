#
# rglmw.R
#
# Copyright (c) 2021 Roberto Corradini. All rights reserved.
#
# This file is part of the reversi program
# http://github.com/rcrr/reversi
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
# or visit the site <http://www.gnu.org/licenses/>.
#
#
#
# This script implements 3 functions:
#
# load_dt_model_weights  : Returns a data.table with the data loaded from a POSITION model-weights CSV file.
# load_dtv_model_weights : The same as the previous one, but load the VALIDATION data.
#                          The two functions expect the data directory as data_dir parameter, where the RGLMDATA
#                          is stored, and the RUNCODE string (e.g. A2050) that identifies the RGLM regression.
# load_model_weights     : It is a wrapper to return the key info and the DATA PLOTS of the regression.
#
# The data processed by the functions is generated by rglm_batch.sh script.
#
# Usage:
#
# r <- load_model_weights("../rglmdata", "A2054")
# r$plot_distrib
#
# dtv <- load_dtv_model_weights("../rglmdata", "A2054")
# dtv_ordered <- dtv[order(abs(RESIDUAL),decreasing=TRUE),]
# dtvo <- dtv_ordered <- dtv[order(abs(RESIDUAL),decreasing=TRUE),]
#

library(ggplot2)
library(bit64)
library(data.table)
library(moments)

load_dt_model_weights <- function(data_dir, runcode) {
  data_file <- paste(data_dir, "/",runcode, "_01.w.P.csv", sep = "", collapse = NULL)
  dt  <- fread(data_file)
  return(dt)
}

load_dtv_model_weights <- function(data_dir, runcode) {
  validation_file <- paste(data_dir, "/",runcode, "_01.w.P_check.csv", sep = "", collapse = NULL)
  dtv <- fread(validation_file)
  return(dtv)
}

# Game Value (gv) to Transformed Game Value (tgv)
gv2tgv <- function(gv) {
  b = 0.5
  a = 0.00765625
  tgv <- a * gv + b
  return(tgv)
}

# Transformed Game Value (tgv) to Game Value (gv)
tgv2gv <- function(tgv) {
  b = 0.5
  a = 0.00765625
  gv <- (tgv - b) / a
  return(gv)
}

round_gv <- function(gv) {
  rgv = round(gv / 2) * 2
  return(rgv)
}

game_value_by_ev_histogram <- function(mw, evaluation_game_value) {
  e <- evaluation_game_value
  if (nrow(mw$dtst[EGV==e])==0) {return(NULL)}
  alpha <- mw$dtst[EGV==e]$ALPHA
  beta <- mw$dtst[EGV==e]$BETA
  m <- mw$dtst[EGV==e]$MEAN
  v <- mw$dtst[EGV==e]$VAR
  s <- mw$dtst[EGV==e]$SD
  min <- mw$dtst[EGV==e]$MIN
  max <- mw$dtst[EGV==e]$MAX
  c <- mw$dtst[EGV==e]$COUNT
  t <- gv2tgv(e)
  p <- ggplot(mw$dtv[EGV==e], aes(x=GAME_VALUE_TRANSFORMED)) + geom_histogram(aes(y=stat(density)), binwidth = 1./64,
                                                                              color='darkturquoise', fill='aquamarine') +
    stat_function(fun = dbeta, args = list(shape1=alpha, shape2=beta), n=501, colour='blue') +
    coord_cartesian(xlim = c(0., 1.)) +
    xlab('Game value transformed') + ylab('Probability density') +
    labs(title = mw$runcode, subtitle = paste('Evaluation Game Value: ', e, '(', t, ')', ' position count = ', c, '\n',
                                              'mean = ', format(m, digits = 3), ', var = ', format(v, digits = 3),
                                              ', sd = ', format(s, digits = 3),
                                              ', min = ', format(min, digits = 3), ', max = ', format(max, digits = 3), '\n',
                                              'alpha = ', format(alpha, digits = 3), ', beta = ', format(beta, digits = 3))) +
    scale_x_continuous(n.breaks = 10)
  return(p)
}

game_value_by_ev_barplot <- function(mw, evaluation_game_value) {
  e <- evaluation_game_value
  if (nrow(mw$dtst[EGV==e])==0) {return(NULL)}
  m <- mw$dts[EGV==e]$MEAN
  v <- mw$dts[EGV==e]$VAR
  s <- mw$dts[EGV==e]$SD
  min <- mw$dts[EGV==e]$MIN
  max <- mw$dts[EGV==e]$MAX
  c <- mw$dts[EGV==e]$COUNT

  dt <- mw$dtv[EGV==e, .(N=.N, F=.N/c), by=GAME_VALUE][order(GAME_VALUE)]
  
  p <- ggplot(data=dt, aes(x=GAME_VALUE, y=F)) +
    geom_bar(stat="identity") +
    coord_cartesian(xlim = c(-64, +64)) +
    scale_x_continuous(n.breaks = 10) +
    xlab('Game value') + ylab('Frequency') +
    labs(title = mw$runcode, subtitle = paste('Evaluation Game Value: ', e, ' - position count = ', c, '\n',
                                              'mean = ', format(m, digits = 3), ', var = ', format(v, digits = 3),
                                              ', sd = ', format(s, digits = 3),
                                              ', min = ', format(min, digits = 3), ', max = ', format(max, digits = 3)))
  return(p)
}

game_value_by_ev_boxplot <- function(mw) {
  p <- ggplot(mw$dtv, aes(x=factor(EGV), y=GAME_VALUE)) + geom_boxplot() +
    xlab('Evaluated game value') + ylab('Game value')  +
    labs(title = mw$runcode) +
    coord_cartesian(ylim = c(-64, +64)) +
    scale_y_continuous(n.breaks = 10)
  return(p)
}

beta_distrib_method_of_moments <- function(m, v) {
  x <- m * (1 - m)
  y <- (x / v) - 1
  a <- y * m
  b <- y * (1 - m)
  return(list(a=a, b=b))
}

load_model_weights <- function(data_dir, runcode) {
  dt <- load_dt_model_weights(data_dir, runcode)
  dtv <- load_dtv_model_weights(data_dir, runcode)
  
  dtv[, EGV := round_gv(tgv2gv(EVALUATION_FUNCTION))]
  dts <- dtv[, .(COUNT=.N,
                 MEAN=mean(GAME_VALUE),
                 MEDIAN=median(GAME_VALUE),
                 VAR=var(GAME_VALUE),
                 SD=sd(GAME_VALUE),
                 MIN=min(GAME_VALUE),
                 MAX=max(GAME_VALUE)),
      by=EGV][order(EGV)]
  
  dtst <- dtv[, .(COUNT=.N,
                  MEAN=mean(GAME_VALUE_TRANSFORMED),
                  MEDIAN=median(GAME_VALUE_TRANSFORMED),
                  VAR=var(GAME_VALUE_TRANSFORMED),
                  SD=sd(GAME_VALUE_TRANSFORMED),
                  MIN=min(GAME_VALUE_TRANSFORMED),
                  MAX=max(GAME_VALUE_TRANSFORMED)),
              by=EGV][order(EGV)]
  
  dtst[, ALPHA:=beta_distrib_method_of_moments(MEAN,VAR)$a]
  dtst[, BETA:=beta_distrib_method_of_moments(MEAN,VAR)$b]
  
  game_value_transformed_mean <- mean(dt$GAME_VALUE_TRANSFORMED)
  dt[, REFERENCE := GAME_VALUE_TRANSFORMED - game_value_transformed_mean]
  
  reference_den  <- density(dt$REFERENCE)
  residual_den   <- density(dt$RESIDUAL)
  validation_den <- density(dtv$RESIDUAL)
  
  reference_sd  <- sd(dt$REFERENCE)
  residual_sd   <- sd(dt$RESIDUAL)
  validation_sd <- sd(dtv$RESIDUAL)
  
  validation_mean <- mean(dtv$RESIDUAL)
  validation_min <- min(dtv$RESIDUAL)
  validation_max <- max(dtv$RESIDUAL)
  
  validation_skewness <- skewness(dtv$RESIDUAL)
  validation_kurtosis <- kurtosis(dtv$RESIDUAL)
  
  max_y <- max(max(reference_den$y), max(residual_den$y), max(validation_den$y))
  
  reference_color <- "slategray"
  residual_color  <- "firebrick"
  validation_color <- "black"
  
  reference_p0 <- geom_density(aes_string(x = dt$REFERENCE), color = reference_color)
  residual_p0 <- geom_density(aes_string(x = dt$RESIDUAL),  color = residual_color)
  validation_p0 <- geom_density(aes_string(x = dtv$RESIDUAL), color = validation_color)
  
  label_reference <- sprintf("Reference:\nsd = %6.4f", reference_sd)
  label_residual  <- sprintf("Residual:\nsd = %6.4f", residual_sd)
  label_validation <- sprintf("Validation:\nsd = %6.4f\nmean = %6.4f\nmin = %6.4f\nmax = %6.4f",
                              validation_sd, validation_mean,
                              validation_min, validation_max)
  
  p0 <- ggplot() + reference_p0 + residual_p0 + validation_p0 +
    labs(title = 'RGLM Residuals Distribution', subtitle = runcode) +
    xlab('Game value residual') + ylab('Probability density') +
    geom_vline(aes(xintercept = mean(dt$RESIDUAL)),
               color = validation_color, linetype="dashed", size=0.3) +
    geom_label(aes(x =  0.25, y = max_y * 0.60, label = label_reference),  color = reference_color , size = 3, hjust = 0) +
    geom_label(aes(x =  0.15, y = max_y * 0.90, label = label_residual),   color = residual_color  , size = 3, hjust = 0) +
    geom_label(aes(x = -0.45, y = max_y * 0.75, label = label_validation), color = validation_color, size = 3, hjust = 0) +
    theme_light() +
    theme(legend.position = "None")
  
  p1 <- ggplot() + geom_point(aes(x=jitter(dtv$EVALUATION_FUNCTION, amount=0.005), y=jitter(dtv$RESIDUAL, amount=0.005), alpha=I(0.04))) +
    labs(title = 'RGLM Residuals vs Fitted Values (evaluation function)', subtitle = runcode) +
    xlab('Game evaluation function') + ylab('Game value residual')
  
  p2 <- ggplot() + geom_point(aes(x=jitter(dtv$GAME_VALUE, amount=0.7), y=jitter(dtv$RESIDUAL, amount=0.005), alpha=I(0.02))) +
    labs(title = 'RGLM Residuals vs Game Values', subtitle = runcode) +
    xlab('Game value') + ylab('Game value residual')
  
  ret_val <- list(runcode=runcode,
                  reference_sd=reference_sd,
                  residual_sd=residual_sd,
                  validation_sd=validation_sd,
                  validation_mean=validation_mean,
                  validation_skewness=validation_skewness,
                  validation_kurtosis=validation_kurtosis,
                  plot_distrib=p0,
                  plot_res_vs_fitted=p1,
                  plot_res_vs_gv=p2,
                  dt=dt,
                  dtv=dtv,
                  dts=dts,
                  dtst=dtst)
  return(ret_val)
}
