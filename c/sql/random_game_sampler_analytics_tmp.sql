
--
-- Very rough functions that collect statistics on logs generated by the RANDOM GAME SAMPLER. 
--


-- Creates the complete list of ROW_1 configurations, then JOIN with the frequency found by the pattern_freq() function. 
CREATE OR REPLACE FUNCTION r1()
RETURNS TABLE (blacks    BIGINT,
               whites    BIGINT,
               config    CHAR(8),
               freq      BIGINT)
AS $$
BEGIN
RETURN QUERY WITH aaa AS (
  SELECT
    gro.blacks AS bs,
    gro.whites AS ws,
    row_one_to_string(gro.blacks, gro.whites) AS config
  FROM
    gen_row_one() AS gro
), bbb AS (
  SELECT
    paf.blacks AS bs,
    paf.whites AS ws,
    paf.frequency AS freq
  FROM
    pattern_freq('T010', (x'00000000000000FF')::BIGINT, 8, 12) AS paf
)
SELECT
  aaa.bs AS blacks,
  aaa.ws AS whites,
  aaa.config AS config,
  bbb.freq AS freq
FROM
  aaa LEFT JOIN bbb
  ON aaa.bs = bbb.bs
  AND aaa.ws = bbb.ws;

END
$$ LANGUAGE plpgsql IMMUTABLE;

-- Generates all possible combinations of values (blacks,whites) in ROW_1.
-- The remaining squares [ROW_2..ROW_8] are zero.
CREATE OR REPLACE FUNCTION gen_row_one()
RETURNS TABLE (blacks BIGINT,
               whites BIGINT)
AS $$
DECLARE
  empty_square_set CONSTANT BIGINT := 0;
BEGIN
RETURN QUERY WITH RECURSIVE color AS (
  SELECT
    0::BIGINT AS val
  UNION ALL SELECT val + 1::square_set AS val
  FROM
    color
  WHERE
    color.val < 255
), cross_product AS (
  SELECT
    bt.val AS b,
    wt.val AS w
    FROM
      color AS bt,
      color AS wt
)
SELECT
  cp.b AS blacks,
  cp.w AS whites
FROM
  cross_product AS cp
WHERE
  (cp.b & cp.w) = empty_square_set;
END
$$ LANGUAGE plpgsql IMMUTABLE;

-- Returns an eight char string representing row_one.
CREATE OR REPLACE FUNCTION row_one_to_string(blacks square_set,
                                             whites square_set)
RETURNS CHAR(8) AS $$
DECLARE
  ret CHAR(8);
BEGIN
  ret := '';
  FOR i in 0..7 LOOP
    IF (1::square_set << i) & blacks <> 0 THEN
      ret := ret || '@';
    ELSEIF (1::square_set << i) & whites <> 0 THEN
      ret := ret || 'O';
    ELSE
      ret := ret || '.';
    END IF;
  END LOOP;
  RETURN ret;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Returns the distinct configurations of the pattern found in game_tree_log, with the frequency.
CREATE OR REPLACE FUNCTION pattern_freq(run_label_in       CHAR(4),
                                        pattern_in         BIGINT,
                                        empty_count_min_in INTEGER,
                                        empty_count_max_in INTEGER)
RETURNS TABLE (blacks     BIGINT,
               whites     BIGINT,
               frequency  BIGINT)
AS $$
DECLARE
  gt_exists BOOLEAN;
  run_id_in INTEGER;
BEGIN
  SELECT EXISTS (SELECT 1 FROM game_tree_log_header WHERE run_label = run_label_in) INTO STRICT gt_exists;
  IF gt_exists IS FALSE THEN
    RETURN;
  ELSE
    SELECT gtlh.run_id INTO STRICT run_id_in FROM game_tree_log_header AS gtlh WHERE gtlh.run_label = run_label_in;
  END IF;
  PERFORM p_assert('C_RANDOM_SAMPLER' = (SELECT engine_id FROM game_tree_log_header WHERE run_label = run_label_in), 'Wrong game tree type.');

RETURN QUERY WITH positions AS (
  SELECT
     gtl.blacks & pattern_in AS b,
     gtl.whites & pattern_in AS w
  FROM
     game_tree_log AS gtl
  WHERE
     gtl.run_id = run_id_in AND
     gtl.empty_count >= empty_count_min_in AND
     gtl.empty_count <= empty_count_max_in
)
SELECT
  pos.b    AS blacks,
  pos.w    AS whites,
  count(*) AS frequency
FROM
  positions AS pos
GROUP BY
  blacks, whites
ORDER BY
  blacks, whites;

END
$$ LANGUAGE plpgsql;

--
-- Function that computes statistics on mobility on a game tree generated by the RANDOM GAME SAMPLER.
--
CREATE OR REPLACE FUNCTION xyz(run_label_in CHAR(4))
RETURNS TABLE (black_score SMALLINT,
               empty_count SMALLINT,
               node_count  BIGINT)
AS $$
DECLARE
  gt_exists BOOLEAN;
  run_id_in INTEGER;
BEGIN
  SELECT EXISTS (SELECT 1 FROM game_tree_log_header WHERE run_label = run_label_in) INTO STRICT gt_exists;
  IF gt_exists IS FALSE THEN
    RETURN;
  ELSE
    SELECT gtlh.run_id INTO STRICT run_id_in FROM game_tree_log_header AS gtlh WHERE gtlh.run_label = run_label_in;
  END IF;
  PERFORM p_assert('C_RANDOM_SAMPLER' = (SELECT engine_id FROM game_tree_log_header WHERE run_label = run_label_in), 'Wrong game tree type.');

RETURN QUERY WITH leafs AS (
  SELECT
    game_position_final_value((facts.blacks, facts.whites, facts.player)) AS final_value,
    facts.empty_count AS empty_count,
    facts.player AS player
  FROM
    game_tree_log AS facts
  WHERE
    facts.run_id = run_id_in AND
    facts.is_leaf = TRUE
), final_score_freqs AS (
  SELECT
    CASE WHEN l.player = 0 THEN l.final_value ELSE - l.final_value END AS score,
    l.empty_count AS empty_cnt,
    count(*) AS cnt
  FROM
    leafs AS l
  GROUP BY
    score, empty_cnt
  ORDER BY
    score, empty_cnt ASC
)
SELECT
  fsf.score AS black_score,
  fsf.empty_cnt AS empty_count,
  fsf.cnt AS node_count
FROM
  final_score_freqs AS fsf;

END
$$ LANGUAGE plpgsql;

--
-- Function that computes statistics on mobility on a game tree generated by the RANDOM GAME SAMPLER.
--
CREATE OR REPLACE FUNCTION abc(run_label_in CHAR(4))
RETURNS TABLE (empty_square_count SMALLINT,
               average_mobility   NUMERIC,
               mobility_variance  NUMERIC,
               mobility_sd        NUMERIC)
AS $$
DECLARE
  gt_exists BOOLEAN;
  run_id_in INTEGER;
BEGIN
  SELECT EXISTS (SELECT 1 FROM game_tree_log_header WHERE run_label = run_label_in) INTO STRICT gt_exists;
  IF gt_exists IS FALSE THEN
    RETURN;
  ELSE
    SELECT gtlh.run_id INTO STRICT run_id_in FROM game_tree_log_header AS gtlh WHERE gtlh.run_label = run_label_in;
  END IF;
  PERFORM p_assert('C_RANDOM_SAMPLER' = (SELECT engine_id FROM game_tree_log_header WHERE run_label = run_label_in), 'Wrong game tree type.');

RETURN QUERY WITH empty_mobility_node_count AS (
  SELECT
    facts.empty_count      AS empty_count,
    facts.legal_move_count AS mobility,
    count(*)               AS node_count
  FROM
    game_tree_log AS facts
  WHERE
    run_id = run_id_in AND
    NOT (facts.legal_move_count = 0 AND facts.legal_move_count_adjusted = 1)
  GROUP BY
    empty_count, mobility
  ORDER BY
    empty_count DESC, mobility ASC
), empty_sum AS (
  SELECT
    a.empty_count     AS empty_count,
    sum(a.node_count) AS sum
  FROM
    empty_mobility_node_count AS a
  GROUP BY
    empty_count
), empty_mobility_frequency AS (
  SELECT
    b.empty_count         AS empty_count,
    b.mobility            AS mobility,
    b.node_count          AS node_count,
    b.node_count / c.sum  AS frequency
  FROM
    empty_mobility_node_count   AS b
  INNER JOIN
    empty_sum                   AS c
  ON (b.empty_count = c.empty_count)
), empty_average_mobility AS (
  SELECT
    d.empty_count                 AS empty_count,
    sum(d.frequency * d.mobility) AS average_mobility
  FROM
    empty_mobility_frequency AS d
  GROUP BY
    empty_count
), empty_mobility_variance AS (
  SELECT
    e.empty_count       AS empty_count,
    e.mobility          AS mobility,
    e.frequency         AS frequency,
    f.average_mobility  AS average_mobility
  FROM
    empty_mobility_frequency AS e
  INNER JOIN
    empty_average_mobility AS f
  ON (e.empty_count = f.empty_count)
)
SELECT
  t.empty_count                                                          AS empty_square_count,
  round(max(t.average_mobility), 3)                                      AS average_mobility,
  round(sum((t.average_mobility - t.mobility)^2 * t.frequency), 4)       AS mobility_variance,
  round(sqrt(sum((t.average_mobility - t.mobility)^2 * t.frequency)), 4) AS mobility_sd
FROM
  empty_mobility_variance AS t
GROUP BY
  empty_count
ORDER BY
  empty_count DESC;

END
$$ LANGUAGE plpgsql;
