// (c) Michael Buro 1992-2002, licensed under the GNU Public License, version 2

/* board stuff (10 disc patterns) */

#include "main.h"
#include "board.h"
#include "move.h"
#include "hash.h"
#include "sboard.h"
#include "crt.h"
#include "patt.h"
#include "setarrays.h"
#include "f.h"

 
#define USE_CONST_INDEX true
#define TEST		false
#define PATT_ADJ	true

#ifdef GCC
#define ASSIGN_REGS 0 // was 1
#else
#define ASSIGN_REGS 0
#endif

void fb(void), fw(void), fnil(void);

#if TEST
static int Err(char *s) { Error(s); return 0; }
#define CS(x)	((x) < STRAHL_ANZ ? x : Err("CS"))
#else 
#define CS(x)   x
#endif 

int movenum=0, moveok=0;

int dnum=0, dsum=0, setok=0;


Square FeldTab[100] = {

  0,     0,    0,    0,    0,    0,    0,    0,    0,   0,
  0,  FE_E, FE_C, FE_B, FE_A, FE_A, FE_B, FE_C, FE_E,   0,
  0,  FE_C, FE_X, FE_F, FE_D, FE_D, FE_F, FE_X, FE_C,   0,
  0,  FE_B, FE_F, FE_I, FE_H, FE_H, FE_I, FE_F, FE_B,   0,
  0,  FE_A, FE_D, FE_H, FE_J, FE_J, FE_H, FE_D, FE_A,   0,
  0,  FE_A, FE_D, FE_H, FE_J, FE_J, FE_H, FE_D, FE_A,   0,
  0,  FE_B, FE_F, FE_I, FE_H, FE_H, FE_I, FE_F, FE_B,   0,
  0,  FE_C, FE_X, FE_F, FE_D, FE_D, FE_F, FE_X, FE_C,   0,
  0,  FE_E, FE_C, FE_B, FE_A, FE_A, FE_B, FE_C, FE_E,   0,
  0,     0,    0,    0,    0,    0,    0,    0,    0,   0

};


PATTD_INFO DeltaInfo[100][DELTA_MAX] = {

#if !NEW_INDICES

/* without 3-diagonals !!! */

#if DELTA_MAX != 5
#error DELTA_MAX != 5
#endif

{   /* `0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* c0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* e0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* f0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* h0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `1 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a1 */
  {  1, 7, 1, 8, 1 },
  {  4, 0, 1, 8, -10 },
  { 18, 7, 1, 8, 11 },
  { 35, 7, 0, 8, 0 },
  { 41, 7, 0, 8, 0 }
},
{   /* b1 */
  {  1, 6, 1, 8, 1 },
  {  8, 0, 1, 8, -10 },
  { 20, 6, 1, 7, 11 },
  { 35, 6, 0, 8, 0 },
  { 41, 3, 0, 8, 0 }
},
{   /* c1 */
  {  1, 5, 1, 8, 1 },
  { 12, 0, 1, 8, -10 },
  { 24, 5, 1, 6, 11 },
  { 35, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d1 */
  {  1, 4, 1, 8, 1 },
  { 16, 0, 1, 8, -10 },
  { 28, 4, 1, 5, 11 },
  { 31, 0, 1, 4, -9 },
  { 35, 4, 0, 8, 0 }
},
{   /* e1 */
  {  1, 3, 1, 8, 1 },
  { 14, 7, 1, 8, 10 },
  { 27, 0, 1, 5, -9 },
  { 32, 3, 1, 4, 11 },
  { 39, 4, 0, 8, 0 }
},
{   /* f1 */
  {  1, 2, 1, 8, 1 },
  { 10, 7, 1, 8, 10 },
  { 23, 0, 1, 6, -9 },
  { 39, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g1 */
  {  1, 1, 1, 8, 1 },
  {  6, 7, 1, 8, 10 },
  { 19, 0, 1, 7, -9 },
  { 36, 3, 0, 8, 0 },
  { 39, 6, 0, 8, 0 }
},
{   /* h1 */
  {  1, 0, 1, 8, 1 },
  {  2, 7, 1, 8, 10 },
  { 17, 0, 1, 8, -9 },
  { 36, 7, 0, 8, 0 },
  { 39, 7, 0, 8, 0 }
},
{   /* i1 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `2 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a2 */
  {  4, 1, 1, 8, -10 },
  {  5, 7, 1, 8, 1 },
  { 22, 0, 1, 7, -11 },
  { 35, 3, 0, 8, 0 },
  { 41, 6, 0, 8, 0 }
},
{   /* b2 */
  {  5, 6, 1, 8, 1 },
  {  8, 1, 1, 8, -10 },
  { 18, 6, 1, 8, 11 },
  { 35, 2, 0, 8, 0 },
  { 41, 2, 0, 8, 0 }
},
{   /* c2 */
  {  5, 5, 1, 8, 1 },
  { 12, 1, 1, 8, -10 },
  { 20, 5, 1, 7, 11 },
  { 31, 1, 1, 4, -9 },
  { 35, 1, 0, 8, 0 }
},
{   /* d2 */
  {  5, 4, 1, 8, 1 },
  { 16, 1, 1, 8, -10 },
  { 24, 4, 1, 6, 11 },
  { 27, 1, 1, 5, -9 },
  { 35, 0, 0, 8, 0 }
},
{   /* e2 */
  {  5, 3, 1, 8, 1 },
  { 14, 6, 1, 8, 10 },
  { 23, 1, 1, 6, -9 },
  { 28, 3, 1, 5, 11 },
  { 39, 0, 0, 8, 0 }
},
{   /* f2 */
  {  5, 2, 1, 8, 1 },
  { 10, 6, 1, 8, 10 },
  { 19, 1, 1, 7, -9 },
  { 32, 2, 1, 4, 11 },
  { 39, 1, 0, 8, 0 }
},
{   /* g2 */
  {  5, 1, 1, 8, 1 },
  {  6, 6, 1, 8, 10 },
  { 17, 1, 1, 8, -9 },
  { 36, 2, 0, 8, 0 },
  { 39, 2, 0, 8, 0 }
},
{   /* h2 */
  {  2, 6, 1, 8, 10 },
  {  5, 0, 1, 8, 1 },
  { 21, 6, 1, 7, 9 },
  { 36, 6, 0, 8, 0 },
  { 39, 3, 0, 8, 0 }
},
{   /* i2 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `3 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a3 */
  {  4, 2, 1, 8, -10 },
  {  9, 7, 1, 8, 1 },
  { 26, 0, 1, 6, -11 },
  { 41, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b3 */
  {  8, 2, 1, 8, -10 },
  {  9, 6, 1, 8, 1 },
  { 22, 1, 1, 7, -11 },
  { 31, 2, 1, 4, -9 },
  { 41, 1, 0, 8, 0 }
},
{   /* c3 */
  {  9, 5, 1, 8, 1 },
  { 12, 2, 1, 8, -10 },
  { 18, 5, 1, 8, 11 },
  { 27, 2, 1, 5, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* d3 */
  {  9, 4, 1, 8, 1 },
  { 16, 2, 1, 8, -10 },
  { 20, 4, 1, 7, 11 },
  { 23, 2, 1, 6, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* e3 */
  {  9, 3, 1, 8, 1 },
  { 14, 5, 1, 8, 10 },
  { 19, 2, 1, 7, -9 },
  { 24, 3, 1, 6, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* f3 */
  {  9, 2, 1, 8, 1 },
  { 10, 5, 1, 8, 10 },
  { 17, 2, 1, 8, -9 },
  { 28, 2, 1, 5, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* g3 */
  {  6, 5, 1, 8, 10 },
  {  9, 1, 1, 8, 1 },
  { 21, 5, 1, 7, 9 },
  { 32, 1, 1, 4, 11 },
  { 36, 1, 0, 8, 0 }
},
{   /* h3 */
  {  2, 5, 1, 8, 10 },
  {  9, 0, 1, 8, 1 },
  { 25, 5, 1, 6, 9 },
  { 36, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i3 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `4 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a4 */
  {  4, 3, 1, 8, -10 },
  { 13, 7, 1, 8, 1 },
  { 30, 0, 1, 5, -11 },
  { 31, 3, 1, 4, -9 },
  { 41, 4, 0, 8, 0 }
},
{   /* b4 */
  {  8, 3, 1, 8, -10 },
  { 13, 6, 1, 8, 1 },
  { 26, 1, 1, 6, -11 },
  { 27, 3, 1, 5, -9 },
  { 41, 0, 0, 8, 0 }
},
{   /* c4 */
  { 12, 3, 1, 8, -10 },
  { 13, 5, 1, 8, 1 },
  { 22, 2, 1, 7, -11 },
  { 23, 3, 1, 6, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* d4 */
  { 13, 4, 1, 8, 1 },
  { 16, 3, 1, 8, -10 },
  { 18, 4, 1, 8, 11 },
  { 19, 3, 1, 7, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* e4 */
  { 13, 3, 1, 8, 1 },
  { 14, 4, 1, 8, 10 },
  { 17, 3, 1, 8, -9 },
  { 20, 3, 1, 7, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* f4 */
  { 10, 4, 1, 8, 10 },
  { 13, 2, 1, 8, 1 },
  { 21, 4, 1, 7, 9 },
  { 24, 2, 1, 6, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* g4 */
  {  6, 4, 1, 8, 10 },
  { 13, 1, 1, 8, 1 },
  { 25, 4, 1, 6, 9 },
  { 28, 1, 1, 5, 11 },
  { 36, 0, 0, 8, 0 }
},
{   /* h4 */
  {  2, 4, 1, 8, 10 },
  { 13, 0, 1, 8, 1 },
  { 29, 4, 1, 5, 9 },
  { 32, 0, 1, 4, 11 },
  { 36, 4, 0, 8, 0 }
},
{   /* i4 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `5 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a5 */
  {  4, 4, 1, 8, -10 },
  { 15, 0, 1, 8, -1 },
  { 27, 4, 1, 5, -9 },
  { 34, 0, 1, 4, -11 },
  { 38, 4, 0, 8, 0 }
},
{   /* b5 */
  {  8, 4, 1, 8, -10 },
  { 15, 1, 1, 8, -1 },
  { 23, 4, 1, 6, -9 },
  { 30, 1, 1, 5, -11 },
  { 38, 0, 0, 8, 0 }
},
{   /* c5 */
  { 12, 4, 1, 8, -10 },
  { 15, 2, 1, 8, -1 },
  { 19, 4, 1, 7, -9 },
  { 26, 2, 1, 6, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* d5 */
  { 15, 3, 1, 8, -1 },
  { 16, 4, 1, 8, -10 },
  { 17, 4, 1, 8, -9 },
  { 22, 3, 1, 7, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* e5 */
  { 14, 3, 1, 8, 10 },
  { 15, 4, 1, 8, -1 },
  { 18, 3, 1, 8, 11 },
  { 21, 3, 1, 7, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* f5 */
  { 10, 3, 1, 8, 10 },
  { 15, 5, 1, 8, -1 },
  { 20, 2, 1, 7, 11 },
  { 25, 3, 1, 6, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* g5 */
  {  6, 3, 1, 8, 10 },
  { 15, 6, 1, 8, -1 },
  { 24, 1, 1, 6, 11 },
  { 29, 3, 1, 5, 9 },
  { 42, 0, 0, 8, 0 }
},
{   /* h5 */
  {  2, 3, 1, 8, 10 },
  { 15, 7, 1, 8, -1 },
  { 28, 0, 1, 5, 11 },
  { 33, 3, 1, 4, 9 },
  { 42, 4, 0, 8, 0 }
},
{   /* i5 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `6 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a6 */
  {  4, 5, 1, 8, -10 },
  { 11, 0, 1, 8, -1 },
  { 23, 5, 1, 6, -9 },
  { 38, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b6 */
  {  8, 5, 1, 8, -10 },
  { 11, 1, 1, 8, -1 },
  { 19, 5, 1, 7, -9 },
  { 34, 1, 1, 4, -11 },
  { 38, 1, 0, 8, 0 }
},
{   /* c6 */
  { 11, 2, 1, 8, -1 },
  { 12, 5, 1, 8, -10 },
  { 17, 5, 1, 8, -9 },
  { 30, 2, 1, 5, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* d6 */
  { 11, 3, 1, 8, -1 },
  { 16, 5, 1, 8, -10 },
  { 21, 2, 1, 7, 9 },
  { 26, 3, 1, 6, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* e6 */
  { 11, 4, 1, 8, -1 },
  { 14, 2, 1, 8, 10 },
  { 22, 4, 1, 7, -11 },
  { 25, 2, 1, 6, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* f6 */
  { 10, 2, 1, 8, 10 },
  { 11, 5, 1, 8, -1 },
  { 18, 2, 1, 8, 11 },
  { 29, 2, 1, 5, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* g6 */
  {  6, 2, 1, 8, 10 },
  { 11, 6, 1, 8, -1 },
  { 20, 1, 1, 7, 11 },
  { 33, 2, 1, 4, 9 },
  { 42, 1, 0, 8, 0 }
},
{   /* h6 */
  {  2, 2, 1, 8, 10 },
  { 11, 7, 1, 8, -1 },
  { 24, 0, 1, 6, 11 },
  { 42, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i6 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `7 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a7 */
  {  4, 6, 1, 8, -10 },
  {  7, 0, 1, 8, -1 },
  { 19, 6, 1, 7, -9 },
  { 38, 6, 0, 8, 0 },
  { 40, 3, 0, 8, 0 }
},
{   /* b7 */
  {  7, 1, 1, 8, -1 },
  {  8, 6, 1, 8, -10 },
  { 17, 6, 1, 8, -9 },
  { 38, 2, 0, 8, 0 },
  { 40, 2, 0, 8, 0 }
},
{   /* c7 */
  {  7, 2, 1, 8, -1 },
  { 12, 6, 1, 8, -10 },
  { 21, 1, 1, 7, 9 },
  { 34, 2, 1, 4, -11 },
  { 40, 1, 0, 8, 0 }
},
{   /* d7 */
  {  7, 3, 1, 8, -1 },
  { 16, 6, 1, 8, -10 },
  { 25, 1, 1, 6, 9 },
  { 30, 3, 1, 5, -11 },
  { 40, 0, 0, 8, 0 }
},
{   /* e7 */
  {  7, 4, 1, 8, -1 },
  { 14, 1, 1, 8, 10 },
  { 26, 4, 1, 6, -11 },
  { 29, 1, 1, 5, 9 },
  { 37, 0, 0, 8, 0 }
},
{   /* f7 */
  {  7, 5, 1, 8, -1 },
  { 10, 1, 1, 8, 10 },
  { 22, 5, 1, 7, -11 },
  { 33, 1, 1, 4, 9 },
  { 37, 1, 0, 8, 0 }
},
{   /* g7 */
  {  6, 1, 1, 8, 10 },
  {  7, 6, 1, 8, -1 },
  { 18, 1, 1, 8, 11 },
  { 37, 2, 0, 8, 0 },
  { 42, 2, 0, 8, 0 }
},
{   /* h7 */
  {  2, 1, 1, 8, 10 },
  {  7, 7, 1, 8, -1 },
  { 20, 0, 1, 7, 11 },
  { 37, 3, 0, 8, 0 },
  { 42, 6, 0, 8, 0 }
},
{   /* i7 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `8 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a8 */
  {  3, 0, 1, 8, -1 },
  {  4, 7, 1, 8, -10 },
  { 17, 7, 1, 8, -9 },
  { 38, 7, 0, 8, 0 },
  { 40, 7, 0, 8, 0 }
},
{   /* b8 */
  {  3, 1, 1, 8, -1 },
  {  8, 7, 1, 8, -10 },
  { 21, 0, 1, 7, 9 },
  { 38, 3, 0, 8, 0 },
  { 40, 6, 0, 8, 0 }
},
{   /* c8 */
  {  3, 2, 1, 8, -1 },
  { 12, 7, 1, 8, -10 },
  { 25, 0, 1, 6, 9 },
  { 40, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d8 */
  {  3, 3, 1, 8, -1 },
  { 16, 7, 1, 8, -10 },
  { 29, 0, 1, 5, 9 },
  { 34, 3, 1, 4, -11 },
  { 40, 4, 0, 8, 0 }
},
{   /* e8 */
  {  3, 4, 1, 8, -1 },
  { 14, 0, 1, 8, 10 },
  { 30, 4, 1, 5, -11 },
  { 33, 0, 1, 4, 9 },
  { 37, 4, 0, 8, 0 }
},
{   /* f8 */
  {  3, 5, 1, 8, -1 },
  { 10, 0, 1, 8, 10 },
  { 26, 5, 1, 6, -11 },
  { 37, 5, 0, 8, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g8 */
  {  3, 6, 1, 8, -1 },
  {  6, 0, 1, 8, 10 },
  { 22, 6, 1, 7, -11 },
  { 37, 6, 0, 8, 0 },
  { 42, 3, 0, 8, 0 }
},
{   /* h8 */
  {  2, 0, 1, 8, 10 },
  {  3, 7, 1, 8, -1 },
  { 18, 0, 1, 8, 11 },
  { 37, 7, 0, 8, 0 },
  { 42, 7, 0, 8, 0 }
},
{   /* i8 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* c9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* e9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* f9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* h9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
}


#else

#if DELTA_MAX != 4
#error DELTA_MAX != 4
#endif

{   /* `0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* c0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* e0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* f0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* h0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i0 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `1 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a1 */
  {  1, 7, 1, 8, 1 },
  {  3, 7, 1, 8, 10 },
  { 18, 0, 1, 8, -11 },
  { 31, 7, 0, 8, 0 }
},
{   /* b1 */
  {  1, 6, 1, 8, 1 },
  {  7, 7, 1, 8, 10 },
  { 20, 0, 1, 7, -11 },
  { 31, 6, 0, 8, 0 }
},
{   /* c1 */
  {  1, 5, 1, 8, 1 },
  { 11, 7, 1, 8, 10 },
  { 24, 0, 1, 6, -11 },
  { 31, 5, 0, 8, 0 }
},
{   /* d1 */
  {  1, 4, 1, 8, 1 },
  { 15, 7, 1, 8, 10 },
  { 28, 0, 1, 5, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* e1 */
  {  1, 3, 1, 8, 1 },
  { 16, 7, 1, 8, 10 },
  { 27, 0, 1, 5, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* f1 */
  {  1, 2, 1, 8, 1 },
  { 12, 7, 1, 8, 10 },
  { 23, 0, 1, 6, -9 },
  { 32, 5, 0, 8, 0 }
},
{   /* g1 */
  {  1, 1, 1, 8, 1 },
  {  8, 7, 1, 8, 10 },
  { 19, 0, 1, 7, -9 },
  { 32, 6, 0, 8, 0 }
},
{   /* h1 */
  {  1, 0, 1, 8, 1 },
  {  4, 7, 1, 8, 10 },
  { 17, 0, 1, 8, -9 },
  { 32, 7, 0, 8, 0 }
},
{   /* i1 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `2 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a2 */
  {  3, 6, 1, 8, 10 },
  {  5, 7, 1, 8, 1 },
  { 21, 6, 1, 7, 11 },
  { 31, 4, 0, 8, 0 }
},
{   /* b2 */
  {  5, 6, 1, 8, 1 },
  {  7, 6, 1, 8, 10 },
  { 18, 1, 1, 8, -11 },
  { 31, 3, 0, 8, 0 }
},
{   /* c2 */
  {  5, 5, 1, 8, 1 },
  { 11, 6, 1, 8, 10 },
  { 20, 1, 1, 7, -11 },
  { 31, 2, 0, 8, 0 }
},
{   /* d2 */
  {  5, 4, 1, 8, 1 },
  { 15, 6, 1, 8, 10 },
  { 24, 1, 1, 6, -11 },
  { 27, 1, 1, 5, -9 }
},
{   /* e2 */
  {  5, 3, 1, 8, 1 },
  { 16, 6, 1, 8, 10 },
  { 23, 1, 1, 6, -9 },
  { 28, 1, 1, 5, -11 }
},
{   /* f2 */
  {  5, 2, 1, 8, 1 },
  { 12, 6, 1, 8, 10 },
  { 19, 1, 1, 7, -9 },
  { 32, 2, 0, 8, 0 }
},
{   /* g2 */
  {  5, 1, 1, 8, 1 },
  {  8, 6, 1, 8, 10 },
  { 17, 1, 1, 8, -9 },
  { 32, 3, 0, 8, 0 }
},
{   /* h2 */
  {  4, 6, 1, 8, 10 },
  {  5, 0, 1, 8, 1 },
  { 22, 6, 1, 7, 9 },
  { 32, 4, 0, 8, 0 }
},
{   /* i2 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `3 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a3 */
  {  3, 5, 1, 8, 10 },
  {  9, 7, 1, 8, 1 },
  { 25, 5, 1, 6, 11 },
  { 31, 1, 0, 8, 0 }
},
{   /* b3 */
  {  7, 5, 1, 8, 10 },
  {  9, 6, 1, 8, 1 },
  { 21, 5, 1, 7, 11 },
  { 31, 0, 0, 8, 0 }
},
{   /* c3 */
  {  9, 5, 1, 8, 1 },
  { 11, 5, 1, 8, 10 },
  { 18, 2, 1, 8, -11 },
  { 27, 2, 1, 5, -9 }
},
{   /* d3 */
  {  9, 4, 1, 8, 1 },
  { 15, 5, 1, 8, 10 },
  { 20, 2, 1, 7, -11 },
  { 23, 2, 1, 6, -9 }
},
{   /* e3 */
  {  9, 3, 1, 8, 1 },
  { 16, 5, 1, 8, 10 },
  { 19, 2, 1, 7, -9 },
  { 24, 2, 1, 6, -11 }
},
{   /* f3 */
  {  9, 2, 1, 8, 1 },
  { 12, 5, 1, 8, 10 },
  { 17, 2, 1, 8, -9 },
  { 28, 2, 1, 5, -11 }
},
{   /* g3 */
  {  8, 5, 1, 8, 10 },
  {  9, 1, 1, 8, 1 },
  { 22, 5, 1, 7, 9 },
  { 32, 0, 0, 8, 0 }
},
{   /* h3 */
  {  4, 5, 1, 8, 10 },
  {  9, 0, 1, 8, 1 },
  { 26, 5, 1, 6, 9 },
  { 32, 1, 0, 8, 0 }
},
{   /* i3 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `4 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a4 */
  {  3, 4, 1, 8, 10 },
  { 13, 7, 1, 8, 1 },
  { 29, 4, 1, 5, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* b4 */
  {  7, 4, 1, 8, 10 },
  { 13, 6, 1, 8, 1 },
  { 25, 4, 1, 6, 11 },
  { 27, 3, 1, 5, -9 }
},
{   /* c4 */
  { 11, 4, 1, 8, 10 },
  { 13, 5, 1, 8, 1 },
  { 21, 4, 1, 7, 11 },
  { 23, 3, 1, 6, -9 }
},
{   /* d4 */
  { 13, 4, 1, 8, 1 },
  { 15, 4, 1, 8, 10 },
  { 18, 3, 1, 8, -11 },
  { 19, 3, 1, 7, -9 }
},
{   /* e4 */
  { 13, 3, 1, 8, 1 },
  { 16, 4, 1, 8, 10 },
  { 17, 3, 1, 8, -9 },
  { 20, 3, 1, 7, -11 }
},
{   /* f4 */
  { 12, 4, 1, 8, 10 },
  { 13, 2, 1, 8, 1 },
  { 22, 4, 1, 7, 9 },
  { 24, 3, 1, 6, -11 }
},
{   /* g4 */
  {  8, 4, 1, 8, 10 },
  { 13, 1, 1, 8, 1 },
  { 26, 4, 1, 6, 9 },
  { 28, 3, 1, 5, -11 }
},
{   /* h4 */
  {  4, 4, 1, 8, 10 },
  { 13, 0, 1, 8, 1 },
  { 30, 4, 1, 5, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* i4 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `5 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a5 */
  {  3, 3, 1, 8, 10 },
  { 14, 7, 1, 8, 1 },
  { 27, 4, 1, 5, -9 },
  {  0, 0, 0, 0, 0 }
},
{   /* b5 */
  {  7, 3, 1, 8, 10 },
  { 14, 6, 1, 8, 1 },
  { 23, 4, 1, 6, -9 },
  { 29, 3, 1, 5, 11 }
},
{   /* c5 */
  { 11, 3, 1, 8, 10 },
  { 14, 5, 1, 8, 1 },
  { 19, 4, 1, 7, -9 },
  { 25, 3, 1, 6, 11 }
},
{   /* d5 */
  { 14, 4, 1, 8, 1 },
  { 15, 3, 1, 8, 10 },
  { 17, 4, 1, 8, -9 },
  { 21, 3, 1, 7, 11 }
},
{   /* e5 */
  { 14, 3, 1, 8, 1 },
  { 16, 3, 1, 8, 10 },
  { 18, 4, 1, 8, -11 },
  { 22, 3, 1, 7, 9 }
},
{   /* f5 */
  { 12, 3, 1, 8, 10 },
  { 14, 2, 1, 8, 1 },
  { 20, 4, 1, 7, -11 },
  { 26, 3, 1, 6, 9 }
},
{   /* g5 */
  {  8, 3, 1, 8, 10 },
  { 14, 1, 1, 8, 1 },
  { 24, 4, 1, 6, -11 },
  { 30, 3, 1, 5, 9 }
},
{   /* h5 */
  {  4, 3, 1, 8, 10 },
  { 14, 0, 1, 8, 1 },
  { 28, 4, 1, 5, -11 },
  {  0, 0, 0, 0, 0 }
},
{   /* i5 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `6 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a6 */
  {  3, 2, 1, 8, 10 },
  { 10, 7, 1, 8, 1 },
  { 23, 5, 1, 6, -9 },
  { 33, 1, 0, 8, 0 }
},
{   /* b6 */
  {  7, 2, 1, 8, 10 },
  { 10, 6, 1, 8, 1 },
  { 19, 5, 1, 7, -9 },
  { 33, 0, 0, 8, 0 }
},
{   /* c6 */
  { 10, 5, 1, 8, 1 },
  { 11, 2, 1, 8, 10 },
  { 17, 5, 1, 8, -9 },
  { 29, 2, 1, 5, 11 }
},
{   /* d6 */
  { 10, 4, 1, 8, 1 },
  { 15, 2, 1, 8, 10 },
  { 22, 2, 1, 7, 9 },
  { 25, 2, 1, 6, 11 }
},
{   /* e6 */
  { 10, 3, 1, 8, 1 },
  { 16, 2, 1, 8, 10 },
  { 21, 2, 1, 7, 11 },
  { 26, 2, 1, 6, 9 }
},
{   /* f6 */
  { 10, 2, 1, 8, 1 },
  { 12, 2, 1, 8, 10 },
  { 18, 5, 1, 8, -11 },
  { 30, 2, 1, 5, 9 }
},
{   /* g6 */
  {  8, 2, 1, 8, 10 },
  { 10, 1, 1, 8, 1 },
  { 20, 5, 1, 7, -11 },
  { 34, 0, 0, 8, 0 }
},
{   /* h6 */
  {  4, 2, 1, 8, 10 },
  { 10, 0, 1, 8, 1 },
  { 24, 5, 1, 6, -11 },
  { 34, 1, 0, 8, 0 }
},
{   /* i6 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `7 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a7 */
  {  3, 1, 1, 8, 10 },
  {  6, 7, 1, 8, 1 },
  { 19, 6, 1, 7, -9 },
  { 33, 4, 0, 8, 0 }
},
{   /* b7 */
  {  6, 6, 1, 8, 1 },
  {  7, 1, 1, 8, 10 },
  { 17, 6, 1, 8, -9 },
  { 33, 3, 0, 8, 0 }
},
{   /* c7 */
  {  6, 5, 1, 8, 1 },
  { 11, 1, 1, 8, 10 },
  { 22, 1, 1, 7, 9 },
  { 33, 2, 0, 8, 0 }
},
{   /* d7 */
  {  6, 4, 1, 8, 1 },
  { 15, 1, 1, 8, 10 },
  { 26, 1, 1, 6, 9 },
  { 29, 1, 1, 5, 11 }
},
{   /* e7 */
  {  6, 3, 1, 8, 1 },
  { 16, 1, 1, 8, 10 },
  { 25, 1, 1, 6, 11 },
  { 30, 1, 1, 5, 9 }
},
{   /* f7 */
  {  6, 2, 1, 8, 1 },
  { 12, 1, 1, 8, 10 },
  { 21, 1, 1, 7, 11 },
  { 34, 2, 0, 8, 0 }
},
{   /* g7 */
  {  6, 1, 1, 8, 1 },
  {  8, 1, 1, 8, 10 },
  { 18, 6, 1, 8, -11 },
  { 34, 3, 0, 8, 0 }
},
{   /* h7 */
  {  4, 1, 1, 8, 10 },
  {  6, 0, 1, 8, 1 },
  { 20, 6, 1, 7, -11 },
  { 34, 4, 0, 8, 0 }
},
{   /* i7 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `8 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a8 */
  {  2, 7, 1, 8, 1 },
  {  3, 0, 1, 8, 10 },
  { 17, 7, 1, 8, -9 },
  { 33, 7, 0, 8, 0 }
},
{   /* b8 */
  {  2, 6, 1, 8, 1 },
  {  7, 0, 1, 8, 10 },
  { 22, 0, 1, 7, 9 },
  { 33, 6, 0, 8, 0 }
},
{   /* c8 */
  {  2, 5, 1, 8, 1 },
  { 11, 0, 1, 8, 10 },
  { 26, 0, 1, 6, 9 },
  { 33, 5, 0, 8, 0 }
},
{   /* d8 */
  {  2, 4, 1, 8, 1 },
  { 15, 0, 1, 8, 10 },
  { 30, 0, 1, 5, 9 },
  {  0, 0, 0, 0, 0 }
},
{   /* e8 */
  {  2, 3, 1, 8, 1 },
  { 16, 0, 1, 8, 10 },
  { 29, 0, 1, 5, 11 },
  {  0, 0, 0, 0, 0 }
},
{   /* f8 */
  {  2, 2, 1, 8, 1 },
  { 12, 0, 1, 8, 10 },
  { 25, 0, 1, 6, 11 },
  { 34, 5, 0, 8, 0 }
},
{   /* g8 */
  {  2, 1, 1, 8, 1 },
  {  8, 0, 1, 8, 10 },
  { 21, 0, 1, 7, 11 },
  { 34, 6, 0, 8, 0 }
},
{   /* h8 */
  {  2, 0, 1, 8, 1 },
  {  4, 0, 1, 8, 10 },
  { 18, 7, 1, 8, -11 },
  { 34, 7, 0, 8, 0 }
},
{   /* i8 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* `9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* a9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* b9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* c9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* d9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* e9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* f9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* g9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* h9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
},
{   /* i9 */
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 },
  {  0, 0, 0, 0, 0 }
}

#endif

};





/* Y(Nr+Drehen),X(Nr+Drehen),XMY(Nr+Drehen),XPY(Nr+Drehen) */

int StrNrDr[800];	

static bool InitSetzenGerufen=false;

void InitSetzen(void) 
{
  int x, y, Pos;
  int Pot3[8] = { 2*1, 2*3, 2*9, 2*27, 2*81, 2*243, 2*729, 2*2187 };
				/* 2 wg. Drehen von Stein */	

  FOR_SFPOS10(Pos) {

    x = X100(Pos); y = Y100(Pos);

    StrNrDr[Pos]     = y;           
    StrNrDr[Pos+100] = Pot3[7-x];                   	/* -1 */

    StrNrDr[Pos+200] = x+8;                         	/* | */
    StrNrDr[Pos+300] = Pot3[7-y]; 			/* 1 */

    StrNrDr[Pos+400] = x - y + 23;
    if (x-y >= 0) StrNrDr[Pos+500] = Pot3[7-x]; 	/*  \   */
    else	  StrNrDr[Pos+500] = Pot3[7-y];		/*   1  */

    StrNrDr[Pos+600] = x + y + 31; 
    if (x+y <= 7) StrNrDr[Pos+700] = Pot3[y];    	/*   1  */
    else	  StrNrDr[Pos+700] = Pot3[7-x];  	/*  /   */

  }

  InitSetzenGerufen = true;
}


#if !LAZY_UPDATE 

bool Setzen(
  BRETT  *pnb,		/* Zeiger auf Brett, auf dem gesetzt wird	*/
  PARTEI eigen,		/* Partei am Zug				*/
  SFPOS	 Pos0,		/* Position des zu setzenden Steins		*/
  DELTA  *pd		/* Änderungen an *pnb				*/
)
{
  register POSDATEN *pda;
  int	 d, diff, Index, gegn, Pos1, j, LastIndex, Pos=Pos0;
  sint1	 *p;
  sint1	 *pgedreht;	/* Zeiger auf Liste der umgedrehten Steine in *pd */  
  sint1  *pneu;		/* Zeiger auf Liste neuer Umgebungspos.		  */
  UMGEB  *umgl;
  sint1  *umg;
  uint4  DHash1, DHash2;


#if TEST
BRETT Brett0, Brett1;

Brett0=*pnb;
#endif

#if TEST
  if (!ZUG(Pos)) Error("Pos kein Zug");

if (1)
{ SPFELD sf;

  BrettSf(pnb, &sf);
  SfBrett(&sf, &Brett1);

  BrettVergl01(pnb, &Brett1, "xxx");
}

#endif

  Index = pnb->umg[Pos] - UMG;

  if (Index < 0) return false;		/* kein Umgebungsfeld */



#if TEST
  if (Index < 0 || Index > pnb->LastIndex) { 
    printf("%d %d ", Index, pnb->LastIndex); 
    Error("Index");
  }

  if (pnb->p[Pos] != LEER) Error("pos besetzt 0 !");

#endif

  p	   = pnb->p; 
  pgedreht = pd->Umgedreht;
  gegn     = GEGNER(eigen);

  DHash1 = DHash2 = 0;


#if 0 && TEST && PATT_ADJ
{ PATT Patt;
  SPFELD sf;

  ComputePatt(pnb->p, BLACK, &Patt);


  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);

  printf("%d %d\n", pnb->Patt.st[0], Patt.s1 - 3280);
  printf("%d %d\n", pnb->Patt.st[1], Patt.s2 - 3280);
  printf("%d %d\n", pnb->Patt.st[2], Patt.s3 - 3280);
  printf("%d %d\n", pnb->Patt.st[3], Patt.s4 - 3280);
  printf("%d %d\n", pnb->Patt.st[4], Patt.s5 - 3280);
  printf("%d %d\n", pnb->Patt.st[5], Patt.s6 - 3280);
  printf("%d %d\n", pnb->Patt.st[6], Patt.s7 - 3280);
  printf("%d %d\n", pnb->Patt.st[7], Patt.s8 - 3280);

  printf("%d %d\n", pnb->Patt.st[8] , Patt.sA - 3280);
  printf("%d %d\n", pnb->Patt.st[9] , Patt.sB - 3280);
  printf("%d %d\n", pnb->Patt.st[10], Patt.sC - 3280);
  printf("%d %d\n", pnb->Patt.st[11], Patt.sD - 3280);
  printf("%d %d\n", pnb->Patt.st[12], Patt.sE - 3280);
  printf("%d %d\n", pnb->Patt.st[13], Patt.sF - 3280);
  printf("%d %d\n", pnb->Patt.st[14], Patt.sG - 3280);
  printf("%d %d\n", pnb->Patt.st[15], Patt.sH - 3280);

  printf("%d %d\n", pnb->Patt.st[18], Patt.dm3 - 13);
  printf("%d %d\n", pnb->Patt.st[19], Patt.dm4 - 40);
  printf("%d %d\n", pnb->Patt.st[20], Patt.dm5 - 121);
  printf("%d %d\n", pnb->Patt.st[21], Patt.dm6 - 364);
  printf("%d %d\n", pnb->Patt.st[22], Patt.dm7 - 1093);
  printf("%d %d\n", pnb->Patt.st[23], Patt.dm8 - 3280);
  printf("%d %d\n", pnb->Patt.st[24], Patt.dm9 - 1093);
  printf("%d %d\n", pnb->Patt.st[25], Patt.dm10 - 364);
  printf("%d %d\n", pnb->Patt.st[26], Patt.dm11 - 121);
  printf("%d %d\n", pnb->Patt.st[27], Patt.dm12 - 40);
  printf("%d %d\n", pnb->Patt.st[28], Patt.dm13 - 13);

  printf("%d %d\n", pnb->Patt.st[33], Patt.dp3 - 13);
  printf("%d %d\n", pnb->Patt.st[34], Patt.dp4 - 40);
  printf("%d %d\n", pnb->Patt.st[35], Patt.dp5 - 121);
  printf("%d %d\n", pnb->Patt.st[36], Patt.dp6 - 364);
  printf("%d %d\n", pnb->Patt.st[37], Patt.dp7 - 1093);
  printf("%d %d\n", pnb->Patt.st[38], Patt.dp8 - 3280);
  printf("%d %d\n", pnb->Patt.st[39], Patt.dp9 - 1093);
  printf("%d %d\n", pnb->Patt.st[40], Patt.dp10 - 364);
  printf("%d %d\n", pnb->Patt.st[41], Patt.dp11 - 121);
  printf("%d %d\n", pnb->Patt.st[42], Patt.dp12 - 40);
  printf("%d %d\n", pnb->Patt.st[43], Patt.dp13 - 13);
}
#endif

#if 0
{ PATT Patt;
  SPFELD sf;

  ComputePatt(pnb->p, BLACK, &Patt);


  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);

  printf("%d %d\n", pnb->NewPatt.st[PHV1A], Patt.s1 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2A], Patt.s2 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3A], Patt.s3 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4A], Patt.s4 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4B], Patt.s5 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3B], Patt.s6 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2B], Patt.s7 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV1B], Patt.s8 - 3280);

#if 0
  printf("%d %d\n", pnb->Patt.st[8] , Patt.sA - 3280);
  printf("%d %d\n", pnb->Patt.st[9] , Patt.sB - 3280);
  printf("%d %d\n", pnb->Patt.st[10], Patt.sC - 3280);
  printf("%d %d\n", pnb->Patt.st[11], Patt.sD - 3280);
  printf("%d %d\n", pnb->Patt.st[12], Patt.sE - 3280);
  printf("%d %d\n", pnb->Patt.st[13], Patt.sF - 3280);
  printf("%d %d\n", pnb->Patt.st[14], Patt.sG - 3280);
  printf("%d %d\n", pnb->Patt.st[15], Patt.sH - 3280);

  printf("%d %d\n", pnb->Patt.st[18], Patt.dm3 - 13);
  printf("%d %d\n", pnb->Patt.st[19], Patt.dm4 - 40);
  printf("%d %d\n", pnb->Patt.st[20], Patt.dm5 - 121);
  printf("%d %d\n", pnb->Patt.st[21], Patt.dm6 - 364);
  printf("%d %d\n", pnb->Patt.st[22], Patt.dm7 - 1093);
  printf("%d %d\n", pnb->Patt.st[23], Patt.dm8 - 3280);
  printf("%d %d\n", pnb->Patt.st[24], Patt.dm9 - 1093);
  printf("%d %d\n", pnb->Patt.st[25], Patt.dm10 - 364);
  printf("%d %d\n", pnb->Patt.st[26], Patt.dm11 - 121);
  printf("%d %d\n", pnb->Patt.st[27], Patt.dm12 - 40);
  printf("%d %d\n", pnb->Patt.st[28], Patt.dm13 - 13);

  printf("%d %d\n", pnb->Patt.st[33], Patt.dp3 - 13);
  printf("%d %d\n", pnb->Patt.st[34], Patt.dp4 - 40);
  printf("%d %d\n", pnb->Patt.st[35], Patt.dp5 - 121);
  printf("%d %d\n", pnb->Patt.st[36], Patt.dp6 - 364);
  printf("%d %d\n", pnb->Patt.st[37], Patt.dp7 - 1093);
  printf("%d %d\n", pnb->Patt.st[38], Patt.dp8 - 3280);
  printf("%d %d\n", pnb->Patt.st[39], Patt.dp9 - 1093);
  printf("%d %d\n", pnb->Patt.st[40], Patt.dp10 - 364);
  printf("%d %d\n", pnb->Patt.st[41], Patt.dp11 - 121);
  printf("%d %d\n", pnb->Patt.st[42], Patt.dp12 - 40);
  printf("%d %d\n", pnb->Patt.st[43], Patt.dp13 - 13);
#endif
}
#endif


#if 0
/* old */
#define SETZCHECK(dp,vorz)						\
    if (p[Pos1=Pos+dp] == gegn) {		 /* gegnerischer Stein */\
      d = dp;							        \
      do { Pos1 += d; } while (p[Pos1] == gegn); /* Strahl absuchen */	\
      if (p[Pos1] == eigen) {			 /* Zug möglich */	\
        Pos1 -= d;							\
	pda = &pnb->daten[Pos1];					\
        while (Pos1 != Pos) {						\
	  *pgedreht++ =  Pos1;						\
	  p[Pos1]     =  eigen;						\
	  DHash1 ^= pda->ZufBW1;					\
	  DHash2 ^= pda->ZufBW2;					\
	  SANP(vorz);							\
	  pda  -= d;							\
	  Pos1 -= d;							\
	}								\
      }									\
    }
#endif

#if 0
/* without d */
#define SETZCHECK(dp,vorz)						\
    if (p[Pos1=Pos+dp] == gegn) {	        /* gegnerischer Stein */\
      do { Pos1 += dp; } while (p[Pos1] == gegn); /* Strahl absuchen */	\
      if (p[Pos1] == eigen) {			 /* Zug möglich */	\
        Pos1 -= dp;							\
	pda = &pnb->daten[Pos1];					\
        while (Pos1 != Pos) {						\
	  *pgedreht++ =  Pos1;						\
	  p[Pos1]     =  eigen;						\
	  DHash1 ^= pda->ZufBW1;					\
	  DHash2 ^= pda->ZufBW2;					\
	  SANP(vorz);							\
	  pda  -= dp;							\
	  Pos1 -= dp;							\
	}								\
      }									\
    }
#endif


#if 1
/* unrolled (!) */
#define SETZCHECK(dp,vorz)						\
                                                                        \
    if (p[Pos1=Pos+dp] == gegn) {	     /* opponent's disc adj.? */\
      FOREVER {					                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
      }                                                                 \
      if (p[Pos1] == eigen) {			 /* move possible */	\
        Pos1 -= dp;							\
	pda = &pnb->daten[Pos1];					\
        do {						                \
	  *pgedreht++ =  Pos1;						\
	  p[Pos1]     =  eigen;						\
	  DHash1 ^= pda->ZufBW1;					\
	  DHash2 ^= pda->ZufBW2;					\
	  SANP(vorz);		  			                \
	  pda  -= dp;							\
	  Pos1 -= dp;							\
        } while (Pos1 != Pos);						\
      }									\
    }
#endif




  if (eigen == BLACK) {
    SETZCHECK(1,+); SETZCHECK(-9,+); SETZCHECK(-10,+); SETZCHECK(-11,+);
    SETZCHECK(-1,+); SETZCHECK(9,+); SETZCHECK(10,+); SETZCHECK(11,+);
  } else {
    SETZCHECK(1,-); SETZCHECK(-9,-); SETZCHECK(-10,-); SETZCHECK(-11,-);
    SETZCHECK(-1,-); SETZCHECK(9,-); SETZCHECK(10,-); SETZCHECK(11,-);
  }




#if 0 && TEST && PATT_ADJ
{ PATT Patt;
  SPFELD sf;

  ComputePatt(pnb->p, BLACK, &Patt);


  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);

  printf("%d %d\n", pnb->Patt.st[0], Patt.s1 - 3280);
  printf("%d %d\n", pnb->Patt.st[1], Patt.s2 - 3280);
  printf("%d %d\n", pnb->Patt.st[2], Patt.s3 - 3280);
  printf("%d %d\n", pnb->Patt.st[3], Patt.s4 - 3280);
  printf("%d %d\n", pnb->Patt.st[4], Patt.s5 - 3280);
  printf("%d %d\n", pnb->Patt.st[5], Patt.s6 - 3280);
  printf("%d %d\n", pnb->Patt.st[6], Patt.s7 - 3280);
  printf("%d %d\n", pnb->Patt.st[7], Patt.s8 - 3280);

  printf("%d %d\n", pnb->Patt.st[8] , Patt.sA - 3280);
  printf("%d %d\n", pnb->Patt.st[9] , Patt.sB - 3280);
  printf("%d %d\n", pnb->Patt.st[10], Patt.sC - 3280);
  printf("%d %d\n", pnb->Patt.st[11], Patt.sD - 3280);
  printf("%d %d\n", pnb->Patt.st[12], Patt.sE - 3280);
  printf("%d %d\n", pnb->Patt.st[13], Patt.sF - 3280);
  printf("%d %d\n", pnb->Patt.st[14], Patt.sG - 3280);
  printf("%d %d\n", pnb->Patt.st[15], Patt.sH - 3280);

  printf("%d %d\n", pnb->Patt.st[18], Patt.dm3 - 13);
  printf("%d %d\n", pnb->Patt.st[19], Patt.dm4 - 40);
  printf("%d %d\n", pnb->Patt.st[20], Patt.dm5 - 121);
  printf("%d %d\n", pnb->Patt.st[21], Patt.dm6 - 364);
  printf("%d %d\n", pnb->Patt.st[22], Patt.dm7 - 1093);
  printf("%d %d\n", pnb->Patt.st[23], Patt.dm8 - 3280);
  printf("%d %d\n", pnb->Patt.st[24], Patt.dm9 - 1093);
  printf("%d %d\n", pnb->Patt.st[25], Patt.dm10 - 364);
  printf("%d %d\n", pnb->Patt.st[26], Patt.dm11 - 121);
  printf("%d %d\n", pnb->Patt.st[27], Patt.dm12 - 40);
  printf("%d %d\n", pnb->Patt.st[28], Patt.dm13 - 13);

  printf("%d %d\n", pnb->Patt.st[33], Patt.dp3 - 13);
  printf("%d %d\n", pnb->Patt.st[34], Patt.dp4 - 40);
  printf("%d %d\n", pnb->Patt.st[35], Patt.dp5 - 121);
  printf("%d %d\n", pnb->Patt.st[36], Patt.dp6 - 364);
  printf("%d %d\n", pnb->Patt.st[37], Patt.dp7 - 1093);
  printf("%d %d\n", pnb->Patt.st[38], Patt.dp8 - 3280);
  printf("%d %d\n", pnb->Patt.st[39], Patt.dp9 - 1093);
  printf("%d %d\n", pnb->Patt.st[40], Patt.dp10 - 364);
  printf("%d %d\n", pnb->Patt.st[41], Patt.dp11 - 121);
  printf("%d %d\n", pnb->Patt.st[42], Patt.dp12 - 40);
  printf("%d %d\n", pnb->Patt.st[43], Patt.dp13 - 13);
}
#endif


  if ((diff=pgedreht-pd->Umgedreht)) {	/* Setzen geht -> Umgebung anpassen */


/*KoorAus(Pos); printf(" S\n");*/

    *pgedreht = -1;			/* Endmarkierung */

    umgl = pnb->umgl;
    umg  = pnb->umg;

    pd->SetzIndex    = Index;
    pd->AltLastIndex = pnb->LastIndex;
    pd->uweg         = umgl[Index];
    pd->AltStDiffBW  = pnb->StDiffBW;
    pd->AltHash1     = pnb->Hash1;
    pd->AltHash2     = pnb->Hash2;
    pd->Partei       = eigen;
    pd->Pos	     = Pos;

    pnb->SteinAnz++;
    pnb->SteinSumme += Pos;


/* Hashwert- und Strahlenveränderung für gesetzten Stein */

    if (eigen == BLACK) {

      pnb->Hash1 ^= DHash1 ^ pda->ZufBLACK1; 
      pnb->Hash2 ^= DHash2 ^ pda->ZufBLACK2;
      pnb->StDiffBW += diff+diff+1;

      SANP2_PLUS(pda);

    } else {

      pnb->Hash1 ^= DHash1 ^ pda->ZufWHITE1;
      pnb->Hash2 ^= DHash2 ^ pda->ZufWHITE2;
      pnb->StDiffBW -= diff+diff+1;

      SANP2_MINUS(pda);

    }


/* letzen Umgebungseintrag nach	vorne und Index hierfür anpassen */

    LastIndex = pnb->LastIndex;

    j = umgl[Index] = umgl[LastIndex];
 
    umg[j] = UMG + Index;  

    LastIndex--;	/* zunächst eine Umgebungsposition weniger */


/* Umgebung der Setzposition abklappern */

    pneu  = pd->uneu;


#define UCHECK(dp) \
    j = Pos+dp;\
    if (p[j] == LEER && umg[j] < UMG) {\
/* neue Umgebungsposition */\
      *pneu++ = j;\
      umgl[++LastIndex] = j;\
      umg[j] = UMG + LastIndex;\
    }

    UCHECK(+1); UCHECK(-9); UCHECK(-10); UCHECK(-11);
    UCHECK(-1); UCHECK(+9); UCHECK(+10); UCHECK(+11);

    *pneu = -1;

    pnb->LastIndex = LastIndex;


/* Stein auf Pos, muß zum Schluß geschehen;		      */
/* sonst Probleme, wenn letzte Umgebungsposition besetzt wird */

    p[Pos] = eigen; 
    umg[Pos] = 0;

#if TEST
if (BrettAnz(pnb, BLACK) - BrettAnz(pnb, WHITE) != pnb->StDiffBW) {
  printf(" %d %d\n", BrettAnz(pnb, BLACK) - BrettAnz(pnb, WHITE), pnb->StDiffBW);
BrettAus(pnb);
  Error("diff ungl 1");
}

if (BrettAnzBW(pnb) != pnb->SteinAnz) { 
  printf("%d %d\n", BrettAnzBW(pnb), pnb->SteinAnz);
  Error("anz ungl");
}
#endif

#if 0
{ BRETT Brett;
  SPFELD sf;

  BrettSf(pnb, &sf); SfBrett(&sf, &Brett);
  FOR (i, STRAHL_ANZ) 
    if (Brett.Patt.st[i] != pnb->Patt.st[i]) { 

BrettAus(&Brett); BrettAus(pnb);
FOR (i, STRAHL_ANZ) printf("(%d %d) ", Brett.Patt.st[i], pnb->Patt.st[i]);
Error("Patt");
    }
}
#endif

#if TEST
  Brett1 = *pnb;
  Zurueck(pnb, pd);

BrettVergl0(&Brett0, pnb);

*pnb = Brett1;

if (1)
{ SPFELD sf;

  BrettSf(pnb, &sf);
  SfBrett(&sf, &Brett1);

  BrettVergl01(pnb, &Brett1, "yyy");
}

#endif

#if TEST && PATT_ADJ
{ PATT Patt;

  ComputePatt(pnb->p, BLACK, &Patt);

  if (pnb->Patt.st[0] != Patt.s1 - 3280 ||

 pnb->Patt.st[0] != Patt.s1 - 3280 ||
 pnb->Patt.st[1] != Patt.s2 - 3280 ||
 pnb->Patt.st[2] != Patt.s3 - 3280 ||
 pnb->Patt.st[3] != Patt.s4 - 3280 ||
 pnb->Patt.st[4] != Patt.s5 - 3280 ||
 pnb->Patt.st[5] != Patt.s6 - 3280 ||
 pnb->Patt.st[6] != Patt.s7 - 3280 ||
 pnb->Patt.st[7] != Patt.s8 - 3280 ||

 pnb->Patt.st[8]  != Patt.sA - 3280 ||
 pnb->Patt.st[9]  != Patt.sB - 3280 ||
 pnb->Patt.st[10] != Patt.sC - 3280 ||
 pnb->Patt.st[11] != Patt.sD - 3280 ||
 pnb->Patt.st[12] != Patt.sE - 3280 ||
 pnb->Patt.st[13] != Patt.sF - 3280 ||
 pnb->Patt.st[14] != Patt.sG - 3280 ||
 pnb->Patt.st[15] != Patt.sH - 3280 ||

 pnb->Patt.st[18] != Patt.dm3 - 13 ||
 pnb->Patt.st[19] != Patt.dm4 - 40 ||
 pnb->Patt.st[20] != Patt.dm5 - 121 ||
 pnb->Patt.st[21] != Patt.dm6 - 364 ||
 pnb->Patt.st[22] != Patt.dm7 - 1093 || 
 pnb->Patt.st[23] != Patt.dm8 - 3280 ||
 pnb->Patt.st[24] != Patt.dm9 - 1093 ||
 pnb->Patt.st[25] != Patt.dm10 - 364 ||
 pnb->Patt.st[26] != Patt.dm11 - 121 ||
 pnb->Patt.st[27] != Patt.dm12 - 40 ||
 pnb->Patt.st[28] != Patt.dm13 - 13 ||

 pnb->Patt.st[33] != Patt.dp3 - 13 ||
 pnb->Patt.st[34] != Patt.dp4 - 40 ||
 pnb->Patt.st[35] != Patt.dp5 - 121 ||
 pnb->Patt.st[36] != Patt.dp6 - 364 ||
 pnb->Patt.st[37] != Patt.dp7 - 1093 ||
 pnb->Patt.st[38] != Patt.dp8 - 3280 ||
 pnb->Patt.st[39] != Patt.dp9 - 1093 ||
 pnb->Patt.st[40] != Patt.dp10 - 364 ||
 pnb->Patt.st[41] != Patt.dp11 - 121 ||
 pnb->Patt.st[42] != Patt.dp12 - 40 ||
 pnb->Patt.st[43] != Patt.dp13 - 13) {

  SPFELD sf;

  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);

  printf("%d %d\n", pnb->Patt.st[0], Patt.s1 - 3280);
  printf("%d %d\n", pnb->Patt.st[1], Patt.s2 - 3280);
  printf("%d %d\n", pnb->Patt.st[2], Patt.s3 - 3280);
  printf("%d %d\n", pnb->Patt.st[3], Patt.s4 - 3280);
  printf("%d %d\n", pnb->Patt.st[4], Patt.s5 - 3280);
  printf("%d %d\n", pnb->Patt.st[5], Patt.s6 - 3280);
  printf("%d %d\n", pnb->Patt.st[6], Patt.s7 - 3280);
  printf("%d %d\n", pnb->Patt.st[7], Patt.s8 - 3280);

  printf("%d %d\n", pnb->Patt.st[8] , Patt.sA - 3280);
  printf("%d %d\n", pnb->Patt.st[9] , Patt.sB - 3280);
  printf("%d %d\n", pnb->Patt.st[10], Patt.sC - 3280);
  printf("%d %d\n", pnb->Patt.st[11], Patt.sD - 3280);
  printf("%d %d\n", pnb->Patt.st[12], Patt.sE - 3280);
  printf("%d %d\n", pnb->Patt.st[13], Patt.sF - 3280);
  printf("%d %d\n", pnb->Patt.st[14], Patt.sG - 3280);
  printf("%d %d\n", pnb->Patt.st[15], Patt.sH - 3280);

  printf("%d %d\n", pnb->Patt.st[18], Patt.dm3 - 13);
  printf("%d %d\n", pnb->Patt.st[19], Patt.dm4 - 40);
  printf("%d %d\n", pnb->Patt.st[20], Patt.dm5 - 121);
  printf("%d %d\n", pnb->Patt.st[21], Patt.dm6 - 364);
  printf("%d %d\n", pnb->Patt.st[22], Patt.dm7 - 1093);
  printf("%d %d\n", pnb->Patt.st[23], Patt.dm8 - 3280);
  printf("%d %d\n", pnb->Patt.st[24], Patt.dm9 - 1093);
  printf("%d %d\n", pnb->Patt.st[25], Patt.dm10 - 364);
  printf("%d %d\n", pnb->Patt.st[26], Patt.dm11 - 121);
  printf("%d %d\n", pnb->Patt.st[27], Patt.dm12 - 40);
  printf("%d %d\n", pnb->Patt.st[28], Patt.dm13 - 13);

  printf("%d %d\n", pnb->Patt.st[33], Patt.dp3 - 13);
  printf("%d %d\n", pnb->Patt.st[34], Patt.dp4 - 40);
  printf("%d %d\n", pnb->Patt.st[35], Patt.dp5 - 121);
  printf("%d %d\n", pnb->Patt.st[36], Patt.dp6 - 364);
  printf("%d %d\n", pnb->Patt.st[37], Patt.dp7 - 1093);
  printf("%d %d\n", pnb->Patt.st[38], Patt.dp8 - 3280);
  printf("%d %d\n", pnb->Patt.st[39], Patt.dp9 - 1093);
  printf("%d %d\n", pnb->Patt.st[40], Patt.dp10 - 364);
  printf("%d %d\n", pnb->Patt.st[41], Patt.dp11 - 121);
  printf("%d %d\n", pnb->Patt.st[42], Patt.dp12 - 40);
  printf("%d %d\n", pnb->Patt.st[43], Patt.dp13 - 13);
exit(1);
}
}
#endif


#if TEST
{  SPFELD sf;

  BrettSf(&Brett0, &sf);
 
  if (!SfSetzen(&sf, eigen, Pos)) Error("Setzen geht nicht");

if (pnb->Hash1 != Hash1(pnb, BLACK) || pnb->Hash2 != Hash2(pnb, BLACK)) Error("Hash?");
}

#endif

 
    return true;
  }


#if TEST
{  SPFELD sf;

  BrettSf(&Brett0, &sf);
 
  if (SfSetzen(&sf, eigen, Pos)) Error("Setzen geht doch");
}
#endif


  return false;
}



/* Zug zurücknehmen */

void Zurueck(BRETT *pnb, DELTA *pd)
{
  int   Index, LastIndex, posi, posl, Pos;
  SFPOS *p, gegn;
  sint1 *pgedreht, *umg;
  UMGEB *umgl;
  POSDATEN *pda, *daten=pnb->daten;

/* KoorAus(pd->Pos); printf(" Z\n"); */

  pnb->SteinAnz--;
  pnb->SteinSumme -= pd->Pos;
  pnb->StDiffBW = pd->AltStDiffBW;
  pnb->Hash1    = pd->AltHash1;
  pnb->Hash2    = pd->AltHash2;

  umg  = pnb->umg;
  umgl = pnb->umgl;
  p    = pnb->p;

  LastIndex = pnb->LastIndex = pd->AltLastIndex;
  Index	    = pd->SetzIndex;

  posl = umgl[LastIndex] = umgl[Index];
  posi = umgl[Index]     = pd->Pos;

  umg[posi] = UMG + Index;
  p[posi]   = LEER;

  if (LastIndex != Index) umg[posl] = UMG + LastIndex;

  gegn = GEGNER(pd->Partei);

#if TEST
if (gegn != BLACK && gegn != WHITE) { printf("%d ", gegn); Error("gegn kein Stein"); }
#endif

  pgedreht = pd->Umgedreht;

  if (gegn == WHITE) {

    while ((Pos=*pgedreht++) >= 0) { 

      p[Pos] = gegn;

#if PATT_ADJ
      pda = &daten[Pos];
      SANP(-);
#endif

    }

#if PATT_ADJ
    pda = &daten[pd->Pos];
    SANP2_MINUS(pda);
#endif

  } else {

    while ((Pos=*pgedreht++) >= 0) { 

      p[Pos] = gegn;

#if PATT_ADJ
      pda = &daten[Pos];
      SANP_PLUS(pda);
#endif

    }

#if PATT_ADJ
    pda = &daten[pd->Pos];
    SANP2_PLUS(pda);
#endif

  }

  pgedreht = pd->uneu;
  while ((Pos=*pgedreht++) >= 0) { p[Pos] = LEER; umg[Pos] = 0; }


#if TEST

if (1)
{ SPFELD sf;
  BRETT Brett1;

  BrettSf(pnb, &sf);
  SfBrett(&sf, &Brett1);

  BrettVergl01(pnb, &Brett1, "zzz");
}
#endif


}


#endif


#define LAZYTEST false

#if USE_CONST_INDEX 

inline void SANP_PLUS(POSDATEN *pda) 
{
  *(pda->s[0]) += pda->d[0];
  *(pda->s[1]) += pda->d[1];
  *(pda->s[2]) += pda->d[2];
  *(pda->s[3]) += pda->d[3];
#if DELTA_MAX == 5
  *(pda->s[4]) += pda->d[4];
#endif

}

inline void SANP_MINUS(POSDATEN *pda) 
{
  *(pda->s[0]) -= pda->d[0];
  *(pda->s[1]) -= pda->d[1];
  *(pda->s[2]) -= pda->d[2];
  *(pda->s[3]) -= pda->d[3];
#if DELTA_MAX == 5
  *(pda->s[4]) -= pda->d[4];
#endif
}

inline void SANP2_PLUS(POSDATEN *pda) 
{
  *(pda->s[0]) += pda->dh[0];
  *(pda->s[1]) += pda->dh[1];
  *(pda->s[2]) += pda->dh[2];
  *(pda->s[3]) += pda->dh[3];
#if DELTA_MAX == 5
  *(pda->s[4]) += pda->dh[4];
#endif
}

inline void SANP2_MINUS(POSDATEN *pda) 
{
  *(pda->s[0]) -= pda->dh[0];
  *(pda->s[1]) -= pda->dh[1];
  *(pda->s[2]) -= pda->dh[2];
  *(pda->s[3]) -= pda->dh[3];
#if DELTA_MAX == 5
  *(pda->s[4]) -= pda->dh[4];
#endif
}


#else

// new

inline void SANP_PLUS(POSDATEN *pda) 
{
  register STRAHLTYP **s = pda->s;
  register int *d = pda->d;

  *(*s++) += *d++;
  *(*s++) += *d++;
  *(*s++) += *d++;
  *(*s++) += *d++;

#if DELTA_MAX == 5
  *(*s) += *d++;
#endif

}

inline void SANP_MINUS(POSDATEN *pda) 
{
  register STRAHLTYP **s = pda->s;
  register int *d = pda->d;

  *(*s++) -= *d++;
  *(*s++) -= *d++;
  *(*s++) -= *d++;
  *(*s++) -= *d++;

#if DELTA_MAX == 5
  *(*s) -= *d++;
#endif
}

inline void SANP2_PLUS(POSDATEN *pda) 
{
  register STRAHLTYP **s = pda->s;
  register int *d = pda->dh;

  *(*s++) += *d++;
  *(*s++) += *d++;
  *(*s++) += *d++;
  *(*s++) += *d++;

#if DELTA_MAX == 5
  *(*s) += *d++;
#endif
}

inline void SANP2_MINUS(POSDATEN *pda) 
{
  register STRAHLTYP **s = pda->s;
  register int *d = pda->dh;

  *(*s++) -= *d++;
  *(*s++) -= *d++;
  *(*s++) -= *d++;
  *(*s++) -= *d++;

#if DELTA_MAX == 5
  *(*s) -= *d++;
#endif
}


#endif



// make move, update only bit board of surrounding squares

bool LazyMove(
  BRETT  *pnb,		/* Zeiger auf Brett, auf dem gesetzt wird	*/
  PARTEI col,		/* Partei am Zug				*/
  SFPOS	 Pos0,		/* Position des zu setzenden Steins		*/
  DELTA  *pd		/* Änderungen an *pnb				*/
)
{
  register POSDATEN *pda;
  int	  pos=Pos0;
  Square  *p;
  Square  *pneu;		/* Zeiger auf Liste neuer Umgebungspos.		  */
  Square  *umg;
  register uint4 DHash1 

#ifdef NDEBUG
#if ASSIGN_REGS && __i386__
asm("%edi")
#endif
#endif
  ,

  DHash2 

#ifdef NDEBUG
#if ASSIGN_REGS && __i386__
asm("%esi")
#endif
#endif
  ;
  POSDATEN *pda0, **pch;

#if LAZYTEST 
DELTA delta;
SPFELD sf, sf0;
BRETT board, board0;
int b;

  {
    board0 = *pnb;

    FOR (i, 100) sf0.p[i] = pnb->p[i];

    sf = sf0;
    b = SfSetzen(&sf, col, pos);

    if (b) {

      SfBrett(&sf, &board);

    }

  }
#endif


  if (pnb->umg[pos] < UMG) return false; /* no surrounding disc */

  p	   = pnb->p; 
  pch      = pd->pchanged;

  DHash1 = DHash2 = 0;
  pda0   = &pnb->daten[pos];
  pda = 0;

#define LSETZCHECK(dp,vorz,col,update)					\
                                                                        \
    if (p[pos+dp] == -(col)) {	     /* opponent's disc adj.? */\
      register Square *r_p=&p[pos+2*dp];\
      FOREVER {					                        \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        break; \
      }                                                                 \
      if (*r_p == col) {			 /* move possible */	\
	pda = &pnb->daten[r_p - p - dp];				\
        do {						                \
	  *pch++    =  pda;						\
	  *(pda->p) =  col;					        \
	  DHash1   ^= pda->ZufBW1;					\
	  DHash2   ^= pda->ZufBW2;					\
	  update(pda);		  			                \
	  pda      -= dp;						\
        } while (pda != pda0);						\
      }									\
    }

  if (col == BLACK) {

    LSETZCHECK(  1,+,1, SANP_PLUS); LSETZCHECK( -9,+,1, SANP_PLUS); 
    LSETZCHECK(-10,+,1, SANP_PLUS); LSETZCHECK(-11,+,1, SANP_PLUS);
    LSETZCHECK( -1,+,1, SANP_PLUS); LSETZCHECK(  9,+,1, SANP_PLUS); 
    LSETZCHECK( 10,+,1, SANP_PLUS); LSETZCHECK( 11,+,1, SANP_PLUS);

  } else {

    LSETZCHECK(  1,-,-1, SANP_MINUS); LSETZCHECK( -9,-,-1, SANP_MINUS); 
    LSETZCHECK(-10,-,-1, SANP_MINUS); LSETZCHECK(-11,-,-1, SANP_MINUS);
    LSETZCHECK( -1,-,-1, SANP_MINUS); LSETZCHECK(  9,-,-1, SANP_MINUS); 
    LSETZCHECK( 10,-,-1, SANP_MINUS); LSETZCHECK( 11,-,-1, SANP_MINUS);
  }



  if (pch != pd->pchanged) {	/* move possible */

/*KoorAus(Pos); printf(" S\n");*/

    int diff = pch - pd->pchanged;

    *pch = NULL;			/* end marker */

    umg  = pnb->umg;

    pd->AltStDiffBW  = pnb->StDiffBW;
    pd->AltHash1     = pnb->Hash1;
    pd->AltHash2     = pnb->Hash2;
    pd->Partei       = col;
    pd->Pos	     = pos;

    pnb->SteinAnz++;
    pnb->SteinSumme += pos;

    p[pos] = col; 
    umg[pos] = 0;


/* hash & pattern updates for move position */

    if (col == BLACK) {

      pnb->Hash1 ^= DHash1 ^ pda->ZufBLACK1; 
      pnb->Hash2 ^= DHash2 ^ pda->ZufBLACK2;
      pnb->StDiffBW += diff+diff+1;

      SANP2_PLUS(pda);

    } else {

      pnb->Hash1 ^= DHash1 ^ pda->ZufWHITE1;
      pnb->Hash2 ^= DHash2 ^ pda->ZufWHITE2;
      pnb->StDiffBW -= diff+diff+1;

      SANP2_MINUS(pda);

    }



/* examine squares that surround move position */

    pneu  = pd->uneu;


    { register Square *umg=&pnb->umg[pos], *p = &pnb->p[pos];


#define UCHECK(dp) \
\
  if (p[dp] == LEER && umg[dp] < UMG) { /* new position */\
    *pneu++ = dp;\
    umg[dp] = UMG;\
  }


      UCHECK(-1); UCHECK(-9); UCHECK(-10); UCHECK(-11);
      UCHECK(+1); UCHECK(+9); UCHECK(+10); UCHECK(+11);

    }

    *pneu = 0;


#if LAZYTEST
    if (!b) Error("setzen geht nicht?");
    BrettVergl2(&board, pnb);
#endif

    return true;
  }


#if LAZYTEST
  if (b) Error("setzen geht?");
#endif

  return false;
}


/* undo move (lazy) */

void LazyUndo(BRETT *pnb, DELTA *pd)
{
  int      pos;
  Square   *pgedreht, *umg;
  POSDATEN *pda;
  POSDATEN **pch;

  pnb->SteinAnz--;
  pnb->SteinSumme -= (pos=pd->Pos);
  pnb->StDiffBW = pd->AltStDiffBW;
  pnb->Hash1    = pd->AltHash1;
  pnb->Hash2    = pd->AltHash2;

  umg = &pnb->umg[pos];
  *umg = UMG;

  pch = pd->pchanged;

  pda = &pnb->daten[pos];

  *(pda->p) = LEER;

  if (pd->Partei == BLACK) {

    SANP2_MINUS(pda);

    while ((pda=*pch++)) { 

      *(pda->p) = WHITE;
      SANP_MINUS(pda);

    }

  } else {

    SANP2_PLUS(pda);

    while ((pda=*pch++)) { 

      *(pda->p) = BLACK;
      SANP_PLUS(pda);

    }
  }

  pgedreht = pd->uneu;
  while ((pos=*pgedreht++)) umg[pos] = 0;
}


// make move, without hash and surrounding (last ply)

bool LastPlyLazyMove(
  BRETT  *pnb,		/* Zeiger auf Brett, auf dem gesetzt wird	*/
  PARTEI col,		/* Partei am Zug				*/
  SFPOS	 Pos0,		/* Position des zu setzenden Steins		*/
  DELTA  *pd		/* Änderungen an *pnb				*/
)
{
  register POSDATEN *pda;
  int	 diff, pos=Pos0;
  Square *p;
  POSDATEN *pda0, **pch;

  p = pnb->p; 
  if (pnb->p[pos] != LEER) return false; // square occupied

  pch = pd->pchanged;
  pda0 = &pnb->daten[pos];
  pda = 0;

#define LPCHECK(dp,vorz,col, update)					\
                                                                        \
    if (p[pos+dp] == -(col)) {	     /* opponent's disc adj.? */\
      register Square *r_p=&p[pos+2*dp];\
      FOREVER {					                        \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        if (*r_p != -(col)) break;		                        \
        r_p += dp; \
        break; \
      }                                                                 \
      if (*r_p == col) {			 /* move possible */	\
	pda = &pnb->daten[r_p - p - dp];				\
        do {						                \
	  *pch++    =  pda;						\
	  *(pda->p) =  col;					        \
	  update(pda);		  			                \
	  pda      -= dp;						\
        } while (pda != pda0);						\
      }									\
    }

  if (col == BLACK) {

    LPCHECK(  1,+,1,SANP_PLUS); LPCHECK( -9,+,1,SANP_PLUS); 
    LPCHECK(-10,+,1,SANP_PLUS); LPCHECK(-11,+,1,SANP_PLUS);
    LPCHECK( -1,+,1,SANP_PLUS); LPCHECK(  9,+,1,SANP_PLUS); 
    LPCHECK( 10,+,1,SANP_PLUS); LPCHECK( 11,+,1,SANP_PLUS);

  } else {

    LPCHECK(  1,-,-1,SANP_MINUS); LPCHECK( -9,-,-1,SANP_MINUS); 
    LPCHECK(-10,-,-1,SANP_MINUS); LPCHECK(-11,-,-1,SANP_MINUS);
    LPCHECK( -1,-,-1,SANP_MINUS); LPCHECK(  9,-,-1,SANP_MINUS); 
    LPCHECK( 10,-,-1,SANP_MINUS); LPCHECK( 11,-,-1,SANP_MINUS);
  }



  if ((diff=pch-pd->pchanged)) {	/* move possible */

/*KoorAus(Pos); printf(" S\n");*/

    *pch = NULL;			/* end marker */

    pd->AltStDiffBW  = pnb->StDiffBW;
    pd->Partei       = col;
    pd->Pos	     = pos;

    pnb->SteinAnz++;
    pnb->SteinSumme += pos;

    p[pos] = col; 

/* pattern updates for move position */

    if (col == BLACK) {

      pnb->StDiffBW += diff+diff+1;

      SANP2_PLUS(pda);

    } else {

      pnb->StDiffBW -= diff+diff+1;

      SANP2_MINUS(pda);

    }

    return true;
  }

  return false;
}



/* undo move (lazy) */

void LastPlyLazyUndo(BRETT *pnb, DELTA *pd)
{
  int      pos;
  POSDATEN *pda;
  POSDATEN **pch;

  pnb->SteinAnz--;
  pnb->SteinSumme -= (pos=pd->Pos);
  pnb->StDiffBW = pd->AltStDiffBW;

  pch = pd->pchanged;

  pda = &pnb->daten[pos];

  *(pda->p) = LEER;

  if (pd->Partei == BLACK) {

    SANP2_MINUS(pda);

    while ((pda=*pch++)) { 

      *(pda->p) = WHITE;
      SANP_MINUS(pda);

    }

  } else {

    SANP2_PLUS(pda);

    while ((pda=*pch++)) { 

      *(pda->p) = BLACK;
      SANP_PLUS(pda);

    }
  }
}



#if 0

/* fast move (without hash+movelist update) */

bool MoveFast(
  BRETT  *pnb,		/* Zeiger auf Brett, auf dem gesetzt wird	*/
  PARTEI eigen,		/* Partei am Zug				*/
  SFPOS	 Pos0,		/* Position des zu setzenden Steins		*/
  DELTA  *pd		/* Änderungen an *pnb				*/
)
{
  int    gegn, Pos1, d, Pos=Pos0;
  sint1	 *p;
  sint1	 *pgedreht;	/* Zeiger auf Liste der umgedrehten Steine in *pd    */  
  POSDATEN *pda;


  p	   = pnb->p; 
  pgedreht = pd->Umgedreht;
  gegn     = GEGNER(eigen);

#if 0
#define MOVECHECKF(dp,vorz)						\
    Pos1 = Pos + dp;							\
    if (p[Pos1] == gegn) {			 /* gegnerischer Stein */\
      d = Pos1 - Pos;							\
      do { Pos1 += d; } while (p[Pos1] == gegn); /* Strahl absuchen */	\
      if (p[Pos1] == eigen) {			 /* Zug möglich */	\
        Pos1 -= d;							\
	pda = &pnb->daten[Pos1];					\
        while (Pos1 != Pos) {						\
	  *pgedreht++ =  Pos1;						\
	  p[Pos1]     =  eigen;						\
	  SANP(vorz);							\
	  pda  -= d;							\
	  Pos1 -= d;							\
	}								\
      }									\
    }

#else
 
/* unrolled (!) */
#define MOVECHECKF(dp,vorz)						\
                                                                        \
    if (p[Pos1=Pos+dp] == gegn) {	     /* opponent's disc adj.? */\
      FOREVER {					                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
        if (p[Pos1+=dp] != gegn) break;		                        \
      }                                                                 \
      if (p[Pos1] == eigen) {			 /* move possible */	\
        Pos1 -= dp;							\
	pda = &pnb->daten[Pos1];					\
        while (Pos1 != Pos) {						\
	  *pgedreht++ =  Pos1;						\
	  p[Pos1]     =  eigen;						\
	  SANP(vorz);		  			                \
	  pda  -= dp;							\
	  Pos1 -= dp;							\
	}								\
      }									\
    }
#endif


  if (eigen == BLACK) {
    MOVECHECKF(1,+); MOVECHECKF(-9,+); MOVECHECKF(-10,+); MOVECHECKF(-11,+);
    MOVECHECKF(-1,+); MOVECHECKF(9,+); MOVECHECKF(10,+); MOVECHECKF(11,+);
  } else {
    MOVECHECKF(1,-); MOVECHECKF(-9,-); MOVECHECKF(-10,-); MOVECHECKF(-11,-);
    MOVECHECKF(-1,-); MOVECHECKF(9,-); MOVECHECKF(10,-); MOVECHECKF(11,-);
  }


  if (pgedreht != pd->Umgedreht)) {	/* Setzen geht */

    int diff = pgedreht-pd->Umgedreht;
    *pgedreht = -1;			/* Endmarkierung */

    pd->AltStDiffBW  = pnb->StDiffBW;
    pd->Partei       = eigen;
    pd->Pos	     = Pos;

    pnb->SteinAnz++;
    pnb->SteinSumme += Pos;


/* Strahlenveränderung für gesetzten Stein */


    if (eigen == BLACK) {

      pnb->StDiffBW += diff+diff+1;
      SANP2(+);

    } else {

      pnb->StDiffBW -= diff+diff+1;
      SANP2(-);

    }

    p[Pos] = eigen;
    return true;
  }

  return false;
}



/* fast move undo */

void BackFast(BRETT *pnb, DELTA *pd)
{
  int   Pos;
  SFPOS *p, gegn;
  sint1 *pgedreht;
  POSDATEN *pda, *daten=pnb->daten;


  pnb->SteinAnz--;
  pnb->SteinSumme -= pd->Pos;
  pnb->StDiffBW = pd->AltStDiffBW;

  p = pnb->p;
  gegn = GEGNER(pd->Partei);

  pgedreht = pd->Umgedreht;

  if (gegn == WHITE) {

    while ((Pos=*pgedreht++) >= 0) { 

      p[Pos] = gegn;

#if PATT_ADJ
      pda = &daten[Pos];
      SANP(-);
#endif

    }

#if PATT_ADJ
    pda = &daten[pd->Pos];
    SANP2(-);
#endif

  } else {

    while ((Pos=*pgedreht++) >= 0) { 

      p[Pos] = gegn;

#if PATT_ADJ
      pda = &daten[Pos];
      SANP(+);
#endif

    }

#if PATT_ADJ
    pda = &daten[pd->Pos];
    SANP2(+);
#endif

  }

  p[pd->Pos] = LEER;
}


#endif




#if 0
int StrahlAnz[STRAHL_ANZ] = { 
  6561, 6561, 6561, 6561, 6561, 6561, 6561, 6561,
  6561, 6561, 6561, 6561, 6561, 6561, 6561, 6561,
  3, 9, 27, 81, 243, 729, 2187, 6561, 2187, 729, 243, 81, 27, 9, 3,
  3, 9, 27, 81, 243, 729, 2187, 6561, 2187, 729, 243, 81, 27, 9, 3
};

#endif


void SfBrett(SPFELD *psf, BRETT *pnb)
{
  int	i, j, SteinAnz=0, StDiffBW=0;
  SFPOS Pos;
  PATT Patt;
  POSDATEN *pda;


  if (!InitSetzenGerufen) Error("InitSetzen nicht aufgerufen");

#if !LAZY_UPDATE
  pnb->LastIndex = -1;
#endif

  FOR (i, 100) pnb->p[i] = psf->p[i];

  memset(pnb->umg, 0, sizeof(pnb->umg));

  pnb->SteinSumme = 0;

  FOR_SFPOS10(Pos) {


    pnb->daten[Pos].p = &pnb->p[Pos];

    if (psf->p[Pos] != LEER) pnb->SteinSumme += Pos;

    if (psf->p[Pos] == LEER) {

      FOR (i, 8)

        if (psf->p[Pos + ds[i]] == BLACK || psf->p[Pos + ds[i]] == WHITE)
	  break;

      if (i < 8) {			/* Pos ist Umgebungsposition */

#if !LAZY_UPDATE
        pnb->umgl[++(pnb->LastIndex)] = Pos;
#endif

	pnb->umg[Pos] = UMG

#if !LAZY_UPDATE
 + (pnb->LastIndex)
#endif

;

      }
 
    } else if (psf->p[Pos] == BLACK) {

      SteinAnz++;
      StDiffBW++;


    } else if (psf->p[Pos] == WHITE) {

      SteinAnz++;
      StDiffBW--;


    } else { 

SfAus(psf, BLACK, 0);
printf("%d ", psf->p[Pos]); Error("unbekannter Eintrag, SfBrett"); 

    }

  } 

  pnb->SteinAnz = SteinAnz;
  pnb->StDiffBW = StDiffBW;


  pnb->Hash1 = HashEntry::board_hash(pnb, BLACK);
  pnb->Hash2 = HashEntry::board_lock(pnb, BLACK);

#if 1

  ComputePatt(pnb->p, BLACK, &Patt);

  pnb->Patt.st[0] = Patt.s1 - 3280;
  pnb->Patt.st[1] = Patt.s2 - 3280;
  pnb->Patt.st[2] = Patt.s3 - 3280;
  pnb->Patt.st[3] = Patt.s4 - 3280;
  pnb->Patt.st[4] = Patt.s5 - 3280;
  pnb->Patt.st[5] = Patt.s6 - 3280;
  pnb->Patt.st[6] = Patt.s7 - 3280;
  pnb->Patt.st[7] = Patt.s8 - 3280;

  pnb->Patt.st[8]  = Patt.sA - 3280;
  pnb->Patt.st[9]  = Patt.sB - 3280;
  pnb->Patt.st[10] = Patt.sC - 3280;
  pnb->Patt.st[11] = Patt.sD - 3280;
  pnb->Patt.st[12] = Patt.sE - 3280;
  pnb->Patt.st[13] = Patt.sF - 3280;
  pnb->Patt.st[14] = Patt.sG - 3280;
  pnb->Patt.st[15] = Patt.sH - 3280;

  pnb->Patt.st[18] = Patt.dm3 - 13;
  pnb->Patt.st[19] = Patt.dm4 - 40;
  pnb->Patt.st[20] = Patt.dm5 - 121;
  pnb->Patt.st[21] = Patt.dm6 - 364;
  pnb->Patt.st[22] = Patt.dm7 - 1093;
  pnb->Patt.st[23] = Patt.dm8 - 3280;
  pnb->Patt.st[24] = Patt.dm9 - 1093;
  pnb->Patt.st[25] = Patt.dm10 - 364;
  pnb->Patt.st[26] = Patt.dm11 - 121;
  pnb->Patt.st[27] = Patt.dm12 - 40;
  pnb->Patt.st[28] = Patt.dm13 - 13;

  pnb->Patt.st[33] = Patt.dp3 - 13;
  pnb->Patt.st[34] = Patt.dp4 - 40;
  pnb->Patt.st[35] = Patt.dp5 - 121;
  pnb->Patt.st[36] = Patt.dp6 - 364;
  pnb->Patt.st[37] = Patt.dp7 - 1093;
  pnb->Patt.st[38] = Patt.dp8 - 3280;
  pnb->Patt.st[39] = Patt.dp9 - 1093;
  pnb->Patt.st[40] = Patt.dp10 - 364;
  pnb->Patt.st[41] = Patt.dp11 - 121;
  pnb->Patt.st[42] = Patt.dp12 - 40;
  pnb->Patt.st[43] = Patt.dp13 - 13;

#endif



  FOR (i, STRAHL_ANZ) pnb->NewPatt.st[i] = 0;

#if 0  
{ PATT Patt;
  SPFELD sf;

printf("--->\n");

  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);
}
#endif

  FOR (i, 100) {

    pnb->daten[i].ZufBLACK1 = HashTab::ZufBLACK1[i];
    pnb->daten[i].ZufBLACK2 = HashTab::ZufBLACK2[i];
    pnb->daten[i].ZufWHITE1 = HashTab::ZufWHITE1[i];
    pnb->daten[i].ZufWHITE2 = HashTab::ZufWHITE2[i];
    pnb->daten[i].ZufBW1    = HashTab::ZufBW1[i];
    pnb->daten[i].ZufBW2    = HashTab::ZufBW2[i];

    pnb->daten[i].sy   = &pnb->Patt.st[StrNrDr[i]];
    pnb->daten[i].dy   = StrNrDr[100+i];
    pnb->daten[i].dy2  = StrNrDr[100+i] / 2;
    pnb->daten[i].sx   = &pnb->Patt.st[StrNrDr[200+i]];
    pnb->daten[i].dx   = StrNrDr[300+i];
    pnb->daten[i].dx2  = StrNrDr[300+i] / 2;
    pnb->daten[i].sxmy = &pnb->Patt.st[StrNrDr[400+i]];
    pnb->daten[i].dxmy = StrNrDr[500+i];
    pnb->daten[i].dxmy2= StrNrDr[500+i] / 2;
    pnb->daten[i].sxpy = &pnb->Patt.st[StrNrDr[600+i]];
    pnb->daten[i].dxpy = StrNrDr[700+i];
    pnb->daten[i].dxpy2= StrNrDr[700+i] / 2;

    {

    FOR (j, DELTA_MAX) {

      if (DeltaInfo[i][j].pnum) {

        pnb->daten[i].s[j]  = &pnb->NewPatt.st[DeltaInfo[i][j].pnum];
	pnb->daten[i].d[j]  = 
                  (DOUBLE_INDEX ? 2 : 1) * 2*Pot3[DeltaInfo[i][j].log3];
        pnb->daten[i].dh[j] = pnb->daten[i].d[j]/2;

      } else {

        pnb->daten[i].s[j]  = &pnb->NewPatt.st[0];
	pnb->daten[i].d[j]  = 0;
        pnb->daten[i].dh[j] = 0;

      }

    }

    }
   
    pda = &pnb->daten[i];

    if (pnb->p[i] == BLACK) { SANP2_PLUS(pda); }
    if (pnb->p[i] == WHITE) { SANP2_MINUS(pda); }

  }


#if 0
{ SPFELD sf;

printf("--->\n");

  BrettSf(pnb, &sf);
  SfAus(&sf, 0, 0);

  printf("%d %d\n", pnb->NewPatt.st[PHV1A], Patt.s1 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2A], Patt.s2 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3A], Patt.s3 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4A], Patt.s4 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4B], Patt.s5 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3B], Patt.s6 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2B], Patt.s7 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV1B], Patt.s8 - 3280);

printf("\n");

  printf("%d %d\n", pnb->NewPatt.st[PHV1C], Patt.sA - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2C], Patt.sB - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3C], Patt.sC - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4C], Patt.sD - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV4D], Patt.sE - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV3D], Patt.sF - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV2D], Patt.sG - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PHV1D], Patt.sH - 3280);

#if 1
printf("\n");

  printf("%d %d\n", pnb->NewPatt.st[PD6C], Patt.dm3 - 13);
  printf("%d %d\n", pnb->NewPatt.st[PD5C], Patt.dm4 - 40);
  printf("%d %d\n", pnb->NewPatt.st[PD4C], Patt.dm5 - 121);
  printf("%d %d\n", pnb->NewPatt.st[PD3C], Patt.dm6 - 364);
  printf("%d %d\n", pnb->NewPatt.st[PD2C], Patt.dm7 - 1093);
  printf("%d %d\n", pnb->NewPatt.st[PD1B], Patt.dm8 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PD2B], Patt.dm9 - 1093);
  printf("%d %d\n", pnb->NewPatt.st[PD3B], Patt.dm10 - 364);
  printf("%d %d\n", pnb->NewPatt.st[PD4B], Patt.dm11 - 121);
  printf("%d %d\n", pnb->NewPatt.st[PD5B], Patt.dm12 - 40);
  printf("%d %d\n", pnb->NewPatt.st[PD6B], Patt.dm13 - 13);

printf("\n");

  printf("%d %d\n", pnb->NewPatt.st[PD6A], Patt.dp3 - 13);
  printf("%d %d\n", pnb->NewPatt.st[PD5A], Patt.dp4 - 40);
  printf("%d %d\n", pnb->NewPatt.st[PD4A], Patt.dp5 - 121);
  printf("%d %d\n", pnb->NewPatt.st[PD3A], Patt.dp6 - 364);
  printf("%d %d\n", pnb->NewPatt.st[PD2A], Patt.dp7 - 1093);
  printf("%d %d\n", pnb->NewPatt.st[PD1A], Patt.dp8 - 3280);
  printf("%d %d\n", pnb->NewPatt.st[PD2D], Patt.dp9 - 1093);
  printf("%d %d\n", pnb->NewPatt.st[PD3D], Patt.dp10 - 364);
  printf("%d %d\n", pnb->NewPatt.st[PD4D], Patt.dp11 - 121);
  printf("%d %d\n", pnb->NewPatt.st[PD5D], Patt.dp12 - 40);
  printf("%d %d\n", pnb->NewPatt.st[PD6D], Patt.dp13 - 13);
#endif

}
#endif

}


 
void BrettSf(BRETT *pbr, SPFELD *psf)
{
  int i;

  FOR (i, 100) psf->p[i] = pbr->p[i];
}
 


void BrettAus(BRETT *pbr)
{
  int a, pos, x, y, i;
  SPFELD sf;


  printf("\n");

  FOR (y, 8) {

    FOR (x, 8) {

      pos = Tab8to10[y * 8 + x];
      a = pbr->p[pos];

      if      (a == LEER) {
	if      (pbr->umg[pos] == 0)   printf("-");
 	else if (pbr->umg[pos] >= UMG) printf("·");
	else 			       printf("!");
      }
      else if (a == BLACK) printf("x");
      else if (a == WHITE) printf("o");
      else printf("?");
    }
    printf("\n");
  }
  printf("\n");


  BrettSf(pbr, &sf);

  SfAus(&sf, BLACK, 0);

#if !LAZY_UPDATE

  FOR (i, pbr->LastIndex+1) {
    int j;

    KoorAus(pbr->umgl[i]);

/*
    printf(" %d Steine: ", pbr->umgl[i].SteinAnz);
    FOR (j, pbr->umgl[i].SteinAnz) { KoorAus(pbr->umgl[i].StPos[j]); printf(" "); }
*/
    printf("\n");
  }
#endif


  printf("h1=%d h2=%d Sanz=%d Ssum=%d Sdiff=%d\n", 
   pbr->Hash1, pbr->Hash2, pbr->SteinAnz, pbr->SteinSumme, pbr->StDiffBW);


  FOR (i, STRAHL_ANZ) printf("%2d: %d\n", i, pbr->NewPatt.st[i]);

  printf("\n");

}




int BrettInh(BRETT *pbr, SFPOS pos)
{
  if (pbr->p[pos] == BLACK) return BLACK;
  if (pbr->p[pos] == WHITE) return WHITE;

  return LEER;
}



/* Steinanzahl einer Partei feststellen */

int BrettAnz(BRETT *pbr, PARTEI Partei)
{
  int	 i, Wert;
  Square  *p;


  Wert = 0;

  p = pbr->p;

  FOR_SFPOS10 (i) if (p[i] == Partei) Wert++;

  return Wert;
}



/* Steinanzahl feststellen */

int BrettAnzBW(BRETT *pbr)
{
  int	 i, Wert=0;
  Square  *p;


  p = pbr->p;

  FOR_SFPOS10 (i) if (p[i] == BLACK || p[i] == WHITE) Wert++;

  return Wert;
}



#if 0

extern int xx;



#define SETZCHECK1(dx,dy,a) \
if (p[Pos+(dy) * 8 + (dx)] == gegn) {\
  Pos1 = Pos + 2*((dy) * 8 + (dx));\
  a\
  while (anz-- && p[Pos1] == gegn) Pos1 += (dy) * 8 + (dx);\
  if (p[Pos1] == eigen) goto geht;\
}



/* neue Variante ohne Unterprogrammaufruf */

int MoeglZuege(BRETT *pbr, PARTEI Partei, SFPOS *Zuege)
{
  short  i, x, y, a, Pos, Pos1, zanz = 0, anz;
  SFPOS  eigen, gegn;
  SFPOS  *p, *u;


  eigen = Partei; gegn = GEGNER(Partei);

  a = pbr->LastIndex+1;
  u = pbr->u;
  p = pbr->p;

  FOR (i, a) {

    Pos = *u++;

    x = Pos & 7; y = Pos >> 3;

    if (x >= 2) {

      SETZCHECK1(-1, 0, anz=x-2;);

      if (y >= 2) SETZCHECK1(-1,-1, anz=(x-2 < y-2) ? x-2 : y-2;); 
      if (y <= 5) SETZCHECK1(-1, 1, anz=(x-2 < 5-y) ? x-2 : 5-y;);
    }

    if (x <= 5) {
 
      SETZCHECK1( 1, 0, anz=5-x;); 
      if (y >= 2) SETZCHECK1( 1,-1, anz=(5-x < y-2) ? 5-x : y-2;);
      if (y <= 5) SETZCHECK1( 1, 1, anz=(5-x < 5-y) ? 5-x : 5-y;);

    }

    if (y >= 2) SETZCHECK1( 0,-1, anz=y-2;); 
    if (y <= 5) SETZCHECK1( 0, 1, anz=5-y;); 

    goto gehtnicht;

geht:
    Zuege[zanz++] = Pos;

gehtnicht:;
  }

  return zanz;
}


#endif



void BrettVergl(BRETT *pb1, BRETT *pb2)
{
  int i;

  FOR (i, 100) if (pb1->p[i] != pb2->p[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("Feld");
  }

  FOR (i, 100) if (pb1->umg[i] != pb2->umg[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("Umg");
  }

#if !LAZY_UPDATE

  if (pb1->LastIndex != pb2->LastIndex) Error("Last");

  FOR (i, pb1->LastIndex+1) {
    if (pb1->umgl[i] != pb2->umgl[i]) Error("UPos");
  
  }
#endif

}


void BrettVergl2(BRETT *pb1, BRETT *pb2)
{
  int i;

  FOR (i, 100) if (pb1->p[i] != pb2->p[i]) Error("Feld");
  FOR (i, 100) if ((pb1->umg[i] != 0) != (pb2->umg[i] != 0)) Error("Umg");

#if !LAZY_UPDATE

  if (pb1->LastIndex != pb2->LastIndex) Error("Last");

  FOR (i, pb1->LastIndex+1) {
    FOR (j, pb1->LastIndex+1)
      if (pb1->umgl[i] == pb2->umgl[j]) break;

    if (j >= pb1->LastIndex+1) Error("nicht da");
  }
#endif

  if (memcmp(pb1->NewPatt.st, pb2->NewPatt.st, sizeof(pb1->NewPatt.st)))
    Error("pattern");

  if (pb1->SteinAnz != pb2->SteinAnz) Error("SteinAnz");
  if (pb1->StDiffBW != pb2->StDiffBW) Error("StDiffBW");
  if (pb1->SteinSumme != pb2->SteinSumme) Error("SteinSumme");

  if (pb1->Hash1 != pb2->Hash1) { 
    printf("%x %x\n", pb1->Hash1, pb2->Hash1); Error("hash1"); 
  }
  if (pb1->Hash2 != pb2->Hash2) Error("hash2");
 
}


void BrettVergl0(BRETT *pb1, BRETT *pb2)
{
  int i;

  FOR (i, 100) if (pb1->p[i] != pb2->p[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("Feld");
  }

  FOR (i, 100) if (pb1->umg[i] != pb2->umg[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("Umg");
  }


#if !LAZY_UPDATE

  if (pb1->LastIndex != pb2->LastIndex) Error("Last");

  FOR (i, pb1->LastIndex+1) {
    if (pb1->umgl[i] != pb2->umgl[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("UPos");
    }
  }
#endif

  if (pb1->Hash1 != pb2->Hash1) Error("hash1");
  if (pb1->Hash2 != pb2->Hash2) Error("hash2");
}



void BrettVergl01(BRETT *pb1, BRETT *pb2, char *s)
{
  int i, m[100];

  FOR (i, 100) m[i] = 0;

  FOR (i, 100) if (pb1->p[i] != pb2->p[i]) {
BrettAus(pb1); BrettAus(pb2);
Error("01 Feld");
  }

  FOR (i, 100) if ((pb1->umg[i] != 0) != (pb2->umg[i] != 0)) {
BrettAus(pb1); BrettAus(pb2);
printf(s); Error("01 Umg");
  }

#if !LAZY_UPDATE

  if (pb1->LastIndex != pb2->LastIndex) Error("01 Last");

  FOR (i, pb1->LastIndex+1) {
    m[pb1->umgl[i]] = 1;
  }

  FOR (i, pb1->LastIndex+1) {
    if (!m[pb1->umgl[i]]) { printf(s); Error("01 UPos"); }
  }
#endif

  if (pb1->Hash1 != pb2->Hash1) Error("hash1");
  if (pb1->Hash2 != pb2->Hash2) Error("hash2");
}




#if 0

#if !LAZY_UPDATE
#error LAZY_UPDATE must be true for NewMove
#endif

#if !WITH3DIAGS
#error NewMove requires WITH3DIAGS != 0
#endif

STRAHLTYP *gps;
BRETT *gpb;



bool NewMove(
  BRETT  *pnb,		/* pointer to board  */
  PARTEI col,		/* colour to move    */
  SFPOS	 pos,		/* move position     */
  DELTA  *pd		/* board differences */
)
{
  int    a;
  sint1	 *p;
  sint1  *umg;
  MOVE_DATA *md;
  
 
#if 0
DELTA delta;
SPFELD sf, sf0;
BRETT board, board0;
int b;

  {
    board0 = *pnb;
    int i;
    
    FOR (i, 100) sf0.p[i] = pnb->p[i];

    sf = sf0;
    b = SfSetzen(&sf, col, pos);

    if (b) {

      SfBrett(&sf, &board);

    }

  }
#endif


 /* important! since update functions assume pos to be free */

  if (!pnb->umg[pos]) return false;   

  md = pnb->daten[pos].movedata;

  pnb->pcalled = pd->called;
  pnb->first_call = false;

  gpb = pnb;
  gps = pnb->NewPatt.st;


#if 0
      if (!*(md[n].f##c[a-1])) {			\
        SPFELD sf;					\
        BrettSf(pnb, &sf);				\
        SfAus(&sf, 0, 0);				\
        printf("%d %d %d "#c#n" l=%d p=%d\n", col, pos, a, md[n].l-pnb->NewPatt.st, md[n].p);	\
	Error("xxx\n");\
      }\

#endif

#define LINE_CHECK(c,n) \
/*printf("%d %d %d -> %d\n", md[n].l-pnb->NewPatt.st, *(md[n].l), md[n].p, md[n].t##c[(*(md[n].l))*8+md[n].p]);*/\
/*  { int i; FOR (i, 8) printf("%d", md[n].t##c[(*(md[n].l))*8+i]); printf(" %d %d\n", *(md[n].l), md[n].p);}*/\
    if ((a=md[n].t##c[(*(md[n].l))*8+md[n].p])) {\
/*      printf("l=%d a=%d\n", md[n].l-pnb->NewPatt.st, a);*/\
      (*(md[n].f##c[a-1]))();\
    }


  if (col == BLACK) {

    LINE_CHECK(b, 0);
    LINE_CHECK(b, 1);
    LINE_CHECK(b, 2);
    LINE_CHECK(b, 3);

  } else {

    LINE_CHECK(w, 0);
    LINE_CHECK(w, 1);
    LINE_CHECK(w, 2);
    LINE_CHECK(w, 3);

  }

  if (pnb->pcalled != pd->called) {	/* there is a legal move ... */

    *(pnb->pcalled) = 0;		/* end marker */

    pd->Partei       = col;
    pd->Pos	     = pos;

    pnb->SteinAnz++;
    pnb->SteinSumme += pos;
    pnb->StDiffBW += col;

    if (col == BLACK) {

      pnb->Hash1 ^= pnb->daten[pos].ZufBLACK1;
      pnb->Hash2 ^= pnb->daten[pos].ZufBLACK2;

    } else {

      pnb->Hash1 ^= pnb->daten[pos].ZufWHITE1;
      pnb->Hash2 ^= pnb->daten[pos].ZufWHITE2;

    }
 
/* examine surrounding squares of move position */

    { register sint1 *umg=&pnb->umg[pos], *p=&pnb->p[pos], *pneu=pd->uneu;

      *p   = col; 
      *umg = 0;

#define UCHECK(dp) \
\
    if (p[dp] == LEER && umg[dp] < UMG) { /* new position */\
      *pneu++ = pos+dp;\
      umg[dp] = UMG;\
    }


    UCHECK(-1); UCHECK(-9); UCHECK(-10); UCHECK(-11);
    UCHECK(+1); UCHECK(+9); UCHECK(+10); UCHECK(+11);

    *pneu = -1;

    }


#if 0
    if (!b) {

       SfAus(&sf0, 0, 0);
       printf("%d %d\n", col, pos);

       BrettAus(&board0);
       Error("setzen geht nicht?");
    }

    SfBrett(&sf, &board);

       SfAus(&sf0, 0, 0);
       printf("%d %d\n", col, pos);
printf("%x %d   %x %d\n", board.daten[pos].ZufBLACK1,  board.daten[pos].ZufBLACK1,  
board.daten[pos].ZufBLACK2, board.daten[pos].ZufBLACK2);



    BrettVergl2(&board, pnb);

#endif

 
#if 0
if (!Setzen(&Brett, eigen, Pos, &delta)) {
SfAus(&sf, 0 ,0);
printf("%d %d\n", Pos, eigen);
Error("setzen==\n");
}
if (memcmp(Brett.p, pnb->p, sizeof(Brett.p))) Error("p==");
if (memcmp(Brett.NewPatt.st, pnb->NewPatt.st, sizeof(Brett.NewPatt.st))) Error("patt==");
if (Brett.Hash1 != pnb->Hash1) Error("h1");
if (Brett.Hash2 != pnb->Hash2) Error("h2");
FOR (j, 100)
  if ((Brett.umg[j] != 0) != (pnb->umg[j] != 0)) Error("umg");
#endif

    return true;
  }

#if 0
if (Setzen(&Brett, eigen, Pos, &delta)) {
SfAus(&sf, 0 ,0);
printf("%d %d\n", Pos, eigen);
Error("setzen??\n");
}
#endif

#if 0
  if (b) Error("setzen geht?");
#endif

  return false;
}




/* undo move */

void NewUndo(BRETT *pnb, DELTA *pd)
{
  int   pos, opp;
  SFPOS *p;
  sint1 *pnew, *umg;
  void (*f)();

  pnb->SteinAnz--;
  pnb->SteinSumme -= (pos=pd->Pos);
  pnb->StDiffBW -= pd->Partei;

  pnb->pcalled = pd->called;
  pnb->first_call = false;

  gpb = pnb;
  gps = pnb->NewPatt.st;

  (*pd->called[0])();

  if ((f=pd->called[1])) {

    (*f)();

    if ((f=pd->called[2])) {
  
      (*f)();

      if ((f=pd->called[3])) {

        (*f)();
      }
    }
  }

  if (pd->Partei == BLACK) {

    pnb->Hash1 ^= pnb->daten[pos].ZufBLACK1;
    pnb->Hash2 ^= pnb->daten[pos].ZufBLACK2;

  } else {

    pnb->Hash1 ^= pnb->daten[pos].ZufWHITE1;
    pnb->Hash2 ^= pnb->daten[pos].ZufWHITE2;

  }
 
  umg = pnb->umg;

  umg[pos] = UMG;
  pnb->p[pos]   = LEER;

  pnew = pd->uneu;

  while ((pos=*pnew++) >= 0) umg[pos] = 0;
}

#endif
